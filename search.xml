<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaUtility]]></title>
    <url>%2F2019%2F03%2F31%2FJavaUtility%2F</url>
    <content type="text"><![CDATA[LombokJavaBean规范代码生成工具]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>utility</tag>
        <tag>tool</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaBean]]></title>
    <url>%2F2019%2F03%2F30%2FJavaBean%2F</url>
    <content type="text"><![CDATA[JavaBean在Java中一个非常重要的组件,可重用.如果想要在多个模块中重用,必须遵循一定的规范. 1.必须使用public修饰 2.必须提供公共的无参数构造器 3.字段都是私有化的 4.提供get和set方法 JavaBean中重要成员方法 事件 属性:property,不是字段,而是通过get/set方法推导出来的 12345678910111213141516171819class HelloWorld &#123; private String name; /** * 标准的get方法 * get之后首字母小写,称之为属性 * */ public String getName() &#123; return name; &#125; /** * 标准的set方法 * set之后首字母大写,称之为属性 * */ public void setName(String name) &#123; this.name = name; &#125;&#125; 内省操作内省机制 核心类:Introspector 专门用来操作JavaBean的属性 核心方法 BeanInfo getBeanInfo(class&lt;?&gt; beanclass) 常用API java.beans.Introspector类常用API: static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass) : 获取字节码对象对应的JavaBean信息 static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass, Class&lt;?&gt; stopClass) java.beans.BeanInfo接口常用API: PropertyDescriptor[] getPropertyDescriptors() : 获取所有的属性描述器 java.beans.PropertyDescriptor类常用API: String getName() : 获得属性的名称 Class&lt;?&gt; getPropertyType() : 获得属性的类型 Method getReadMethod() : 获得用于读取属性值的方法 Method getWriteMethod() : 获得用于设置属性值的方法 JavaBean和Map的转换从浏览器传递过来的数据,服务器获取数据后.需要将数据放到一个对象中,传递的数据类似于key=value的形式.所以需要将map转换成JavaBean 都具有相似的结构 转换操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package me.cscar.con.conversion;import org.junit.Test;import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class JavaBeanMap &#123; @Test public void test() throws Exception &#123; //Person p = new Person("蛤蛤", 90); Class&lt;Person&gt; clz = Person.class; Constructor&lt;Person&gt; con = clz.getConstructor(String.class, Integer.class); Person p = con.newInstance("蛤蛤", 90); Map&lt;String, Object&gt; map = bean2map(p); System.out.println(map); System.out.println(map2bean(map, clz)); &#125; /** * JavaBean对象转换成map * 把JavaBean对象中的属性值,获取出来,放在map中 */ public static Map&lt;String, Object&gt; bean2map(Object obj) throws Exception &#123; BeanInfo beanInfo = Introspector.getBeanInfo(obj.getClass(), Object.class); //创建map对象 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Method m = ele.getReadMethod(); Object value = m.invoke(obj); map.put(key, value); &#125; return map; &#125; /** * map转换成JavaBean对象 * 把map的数据取出来,放到JavaBean对应的属性上 */ public static Object map2bean(Map&lt;String, Object&gt; map, Class clz) throws Exception &#123; //使用字节码对象创建对象 Object obj = clz.newInstance(); //获取字节码对象对应JavaBean信息 BeanInfo beanInfo = Introspector.getBeanInfo(clz, Object.class); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); //遍历 for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Object value = map.get(key); Method m = ele.getWriteMethod(); m.invoke(obj, value); &#125; return obj; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>JavaBean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Annotation注解]]></title>
    <url>%2F2019%2F03%2F30%2FAnnotation%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解(标签)注解的概述解决xml臃肿的问题 在Java5之后,开始对元数据的支持,就是Annotation(注解) 可以用来描述其他数据的一种数据,可以赋予其他数据一些功能 常用注解: @Override 限定覆写父类方法 @Deprecated 标记已过时,不推荐使用.在JDK1.5之前,使用文档注释来标记过时 @SuppressWarings 抑制编译器发出的警告,@SuppressWarings(value=&quot;all&quot;) @SafeVarargs 抑制堆污染警告(Java7开始出现的) @Functionallnterface 标记该接口是一个函数接口(Java8开始出现的) 注解的定义:123public @interface Test&#123; //抽象方法 属性&#125; 注解的使用语法: @注解名(属性名1=属性值1,属性名2=属性值2,...) 注解想要具有某一些功能,最重要的是需要三方程序的参与,必须使用反射来给注解赋予功能 元注解注解是用来约束其他程序元素的(字段,方法,),元注解是用来约束注解的 @Target: 表示注解可以贴在哪些位置(类,方法上,构造器上等等) @Retention: 表示注解可以保存在哪一个时期,存活时间 @Documented: 使用@Documented标注的标签会保存到API文档中 @Inherited: @Inherited标注的标签可以被子类所继承. 自定义注解语法格式 1. 可以为属性设置默认值, 使用default. 2. 如果必须要写的属性(可以有多个,其他的都有默认值),并且这个属性的名字叫value, 可以省略属性名,直接写值. 3. 属性的类型只能是基本类型,String,Class,注解,枚举,以及其数组类型. 4. 抽象方法不能有参数 使用注解是一种硬编码方式**]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Annotation</tag>
        <tag>注解</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置文件]]></title>
    <url>%2F2019%2F03%2F30%2F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[配置文件使用配置文件经常修改,从源文件的编写到部署的过程,都需要重新修改. 解决方案: 把配置保存在一个文件中, Java代码可以通过流(stream)动态的读取 真正解决的问题: 代码中的硬编码,写死到Java代码中,而且是经常改动的值 常用的配置文件1.properties文件. 文件后缀名.properties,用来保存一些简单的数据.保存格式:key=value 重复的key表示更新操作,不能存多个用户信息 2.xml文件 文件后缀名.xml,用来保存一些复杂的数据,按照清晰的格式保存(结构化) properties文件的基本使用常见的操作 创建properties文件,并存储数据 1.文件存放在resource文件夹中. 2.在该配置文件中,所有数据到Java后,都是String类型 3.等号不需要空格 123#这是注释,保存格式:key=valueusername=rootpassword=admin 使用jdk提供好的工具类来加载和获取 void load(InputStream inStream):通过输入流把数据加载到properties对象中 String getProperty(String key):通过指定的key获取value值 使用相对路径12//默认去bin中找Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;user.properties&quot;); 123456789101112131415161718public class PropertiesTest &#123; @Test public void loadProperties() throws Exception &#123; //创建properties对象 Properties pt = new Properties(); //获取相对路径 InputStream in = Thread.currentThread(). getContextClassLoader(). getResourceAsStream("user.properties"); //加载 pt.load(in); //获取 String username = pt.getProperty("username"); System.out.println(username); String password = pt.getProperty("password"); System.out.println(password); &#125;&#125; 反射的优势反射的应用场景 更多的是使用一个全限定名来创建对象(反射) 为了解决硬编码,为了降低代码的耦合性,一般将具体的实现类配置到配置文件中 1234567891011121314151617181920212223package me.cscar.con.reflect;import org.junit.Test;import java.io.InputStream;import java.util.Properties;public class Math implements IMath &#123; @Test public void testMath() throws Exception &#123; Properties ps = new Properties(); InputStream is = Thread. currentThread(). getContextClassLoader(). getResourceAsStream("math.properties"); ps.load(is); //forName获取properties文件中的全限定名称,并且创建对象 IMath math = (IMath) Class.forName(ps.getProperty("clssName")) .newInstance(); //getClass获取math的全限定名 System.out.println(math.getClass()); &#125;&#125; 优点: 1.反射提高了程序的灵活性和扩展性。 2.降低耦合性，提高自适应能力。 3.它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 1.性能问题：使用发射基本上是一种在运行期间解析字节码操作，效率较低，一般程序不建议使用，对灵活性和拓展性要求较高的工具或框架上使用较多。 2.代码复杂性：反射发生在运行期，程序员无法在源代码中看到程序的逻辑，反射代码比相应的直接的代码更复杂，因而会带来维护的问题 框架中大量使用反射,用来提高框架的扩展性和灵活性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JunitTest]]></title>
    <url>%2F2019%2F03%2F29%2FJunitTest%2F</url>
    <content type="text"><![CDATA[Junit回归测试框架的基本使用测试先行的思想 单元测试Junit属于白盒测试 定义一个测试方法:1.测试方法,必须是公共的无参数无返回的方法.建议使用test开头. 2.想要测试哪个方法,需要在该方法上贴一个注解@Test 12345678import org.junit.Test;public class HelloTest &#123; @Test public void addTest() &#123; System.out.println("添加用户信息"); &#125;&#125; Junit细节:更多是针对接进行测试,要测试一个接口中的方法,必须按照规范流程 定义一个接口:1234567891011121314151617181920212223242526package me.cscar.Junit;/** * 接口规范:文档注释 * 数学运算的加减乘除方法 * * @author cscar * @date 2019/3/29 */public interface IMath &#123; /** * 计算两个数相加 * @param a * @param b * @return 和 */ int add(int a, int b); /** * 计算两个数相除 * @param a * @param b * @return 商 */ int div(int a, int b);&#125; 根据接口生成实现类:1234567891011121314151617package me.cscar.Junit;/** * 实现IMath接口 */public class Math implements IMath &#123; @Override public int add(int a, int b) &#123; return a + b; &#125; @Override public int div(int a, int b) &#123; return a / b; &#125;&#125; 根据接口生成实现类:1234567891011121314151617181920212223242526package me.cscar.Junit;import org.junit.Test;import static org.junit.Assert.*;//测试数学运算public class MathTest &#123; /** * 面向接口,创建数学类对象 */ private IMath math = new Math(); @Test public void add() &#123; int result = math.add(3, 4); System.out.println(result); &#125; @Test public void div() &#123; int result = math.div(10, 0); System.out.println(result); &#125;&#125; 断言:猜测一个程序结果是否是期望结果 1.:Assert.assertEquals(message, expected, actual):比较的值 三个参数: message: 断言失败的提示信息,断言成功不会显示. expected: 期望值 actual: 真实值 2.:Assert.assertSame(message, expected, actual):比较地址,是同一个对象 Assert.assertNotSame(message, expected, actual):断言不是同一个对象 3.:Assert.assertTrue(message, condition):断言condition应该为TRUE. Assert.assertFalse(message, condition):断言condition应该为FALSE. 4.:Assert.assertNull(message, object):断言对象object为null. Assert.assertNotNull(message, object):断言对象object不为null. 5.:@Test(expected=ArithmeticException.class) 期望该方法报错ArithmeticException. 6.:@Test(timeout=400) 期望该方法在400毫秒之内执行完成. 123456789101112@Testpublic void add() &#123; int result = math.add(3, 4); //System.out.println(result); Assert.assertEquals(&quot;3+4我都能算错?&quot;, 8, result);&#125;@Test(expected = ArithmeticException.class)public void div() &#123; int result = math.div(10, 0); System.out.println(result);&#125; Junit自动化操作自动初始化自动销毁 1.@Test:需要测试的方法,必须贴Test注解.并且测试方法必须是公共无参数无返回的方法. 2.@Before:在所有的测试方法之前,都会执行的代码 3.@After:在所有的测试方法之后,都会执行的代码 4.@BeforeClass:在所有操作之前执行,只执行一次. 5.@AfterClass:在所有操作之前执行,只执行一次. 1234567891011121314151617181920212223242526272829303132333435package me.cscar.junit.work;import org.junit.*;public class WorkTest &#123; @Test public void query() &#123; System.out.println("查询用户信息"); &#125; @Test public void delete() &#123; System.out.println("删除用户信息"); &#125; @Before public void init() &#123; System.out.println("登录"); &#125; @After public void story() &#123; System.out.println("注销"); &#125; @BeforeClass public static void BeforeClass() &#123; System.out.println("所有操作之前"); &#125; @AfterClass public static void AfterClass() &#123; System.out.println("所有操作之后"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Junit</tag>
        <tag>测试类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect反射]]></title>
    <url>%2F2019%2F03%2F29%2FReflect%2F</url>
    <content type="text"><![CDATA[反射为什么要使用反射1234567891011121314151617181920//定义一个类class Person&#123; public Object work()&#123; //假设看不到源码,无法获取真实类型 return new Date(); &#125; //调用work方法 @Test public void testWork()&#123; Person p = new Person(); Object obj = new Person(); //返回值是一个对象,可以继续调用该对象的方法. Date d = (Date)obj; //打印本地的时间风格,但是却不知道应该用什么来接收(不知道返回的是date) String str = d.toLocalString(); System.out.println(str); &#125;&#125; Person类是别人提供好的字节码文件.看不到源码是不能直接强转的. 不爽:我都已经获取到真正的对象了,居然不能知道他的真实类型. 什么是反射:通过字节码(Class)对象,动态的获取该字节码中的成员(构造器,方法,字段,父类,包…) 字节码对象(Class):将多个Class类抽象出来,形成一个字节码的结构(everything is object) 当JVM加载完字节码后.会使用一个对象,来描述该字节码文件的结构.该对象包含操作字节码中成员的方法. 字节码对象,是JVM加载字节码文件的时候,给我们创建的一个对象,一份字节码,只会创建一个字节码对象. 获取字节码对象的三种方法:1.通过Class类的forName来获取. public static Class&lt;?&gt; forName(String className):根据全限定名来获取字节码对象. 全限定名:包名.类名.指定到唯一的一个类上. 2.所有的对象,都有一个公共的方法.getClass. public final Class&lt;?&gt; getClass(): 通过对象返回字节码对象. 3.任何类型都有一个class属性. int.class / Person.class/ 1234567891011121314151617181920212223242526272829303132package me.cscar.reflect.getClassObject;import org.junit.Test;public class GetClassTest &#123; @Test public void getClassObject() throws Exception &#123; //1.通过forName静态方法获取,抛出异常 Class clz = Class.forName("me.cscar.reflect.getClassObject.Person"); //2.通过对象.getClass()方法获取 Object obj = new Person(); Class clz1 = obj.getClass(); //3.任何类型都有一个class属性 Class clz2 = Person.class; //class me.cscar.reflect.getClassObject.Person System.out.println(clz); //true System.out.println(clz == clz1); //true System.out.println(clz == clz2); //int类型的class属性不等于integer的class属性,结果为false System.out.println(int.class == Integer.class); //integer的包装类型是int,结果为true System.out.println(int.class == Integer.TYPE); //class [Ljava.lang.String; System.out.println(String[].class); &#125;&#125; 构造器的操作获取构造器获取单个构造器 parameterTypes:参数类型 想要定位到一个构造器,必须要指明构造器的参数列表. 1.获取单个构造器: public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes):获取public的指定的构造器 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) :获取不管权限的构造器 2.获取所有构造器: Constructor&lt;?&gt;[] getConstructors() :获取所有public 的构造器 Constructor&lt;?&gt;[] getDeclaredConstructors() :获取所有构造器,不管权限. 123456789101112131415161718192021222324252627282930313233343536package me.cscar.reflect.getConstructor;import org.junit.Test;import java.lang.reflect.Constructor;public class GetConstructor &#123; @Test public void testGetConstructor() throws Exception &#123; //创建字节码对象 Class clz = Class.forName("me.cscar.reflect.getConstructor.Person"); //1.获取所有的public构造器 Constructor[] cons = clz.getConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //2.获取所有的构造器 cons = clz.getDeclaredConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //3.获取无参数构造器 Constructor con = clz.getConstructor(); //System.out.println(con); //4.获取带参数的public构造器 Constructor conagsP = clz.getDeclaredConstructor(Long.class, String.class, int.class); //System.out.println(conagsP); //5.获取带参数的构造器(暴力反射) Constructor conage = clz.getDeclaredConstructor(String.class, int.class); System.out.println(conage); &#125;&#125; 通过构造器创建对象 public T newInstance(Object... initargs):通过构造器,创建对象. initargs:实际参数. 如果想要调用私有的成员.必须要先设置可以访问. public void setAccessible(boolean flag): 设置为true. 12345678910111213141516171819202122232425262728293031323334package me.cscar.reflect.createObject;import org.junit.Test;import java.lang.reflect.Constructor;public class CreateObject &#123; @Test public void createObj() throws Exception &#123; Class&lt;Person&gt; clz = Person.class; //1)调用空参构造 Constructor&lt;Person&gt; con = clz.getConstructor(); Person p = con.newInstance(); System.out.println(p); //调用空参构造器方式二,字节码对象需要加泛型,直接使用字节码对象调用 p = clz.newInstance(); System.out.println(p); //2)获取带参数构造并创建对象 Constructor&lt;Person&gt; conargs = clz.getConstructor(Long.class, String.class, int.class); Person p1 = conargs.newInstance(9527L, "蛤蛤", 70); System.out.println(p1); //3)获取私有构造并创建对象 Constructor&lt;Person&gt; constructor = clz.getDeclaredConstructor(String.class, int.class); //设置非public的成员访问许可 constructor.setAccessible(true); Person p2 = constructor.newInstance("包包", 51); System.out.println(p2); &#125;&#125; 操作方法获取方法 name:方法名 parameterTypes:参数列表的类型 想要定位到一个方法,必须要指定方法签名(方法名+参数列表) 1.获取多个方法 Method[] getMethods() :获取到所有的public方法,包括继承的. Method[] getDeclaredMethods() :获取所有的方法,不包括继承的. 2.获取单个方法 Method getMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的public方法 Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的方法,不管权限. 12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.reflect.getMethod;import org.junit.Test;import java.lang.reflect.Method;public class GetMethod &#123; @Test public void getMethod() throws Exception &#123; //使用反射创建对象 Class&lt;Person&gt; clz = Person.class; Person p = clz.newInstance(); //1)执行无参无返回的方法 Method m = clz.getMethod("method1"); Object ret = m.invoke(p); System.out.println(ret); //2)执行有参无返回的方法 Method m1 = clz.getMethod("method2", String.class); Object ret1 = m1.invoke(p, "蛤蛤"); System.out.println(ret1); //3)执行无参有返回的方法 Method m2 = clz.getMethod("method3"); Object ret2 = m2.invoke(p); System.out.println(ret2); //4)执行有参有返回的方法 Method m3 = clz.getMethod("method4", String.class); Object ret3 = m3.invoke(p, "蛤蛤蛤"); System.out.println(ret3); //5)执行私有方法 Method m4 = clz.getDeclaredMethod("method5"); //设置可以访问 m4.setAccessible(true); Object ret4 = m4.invoke(p); System.out.println(ret4); &#125;&#125; 反射的其他API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package me.cscar.reflect.staticmethod;import org.junit.Test;import java.lang.reflect.Method;public class MethodTest &#123; /** * 调用静态方法 */ @Test public void testInvokeStaticMethod() throws Exception &#123; //找到静态方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method6", String.class); //调用方法.由于是static修饰,执行静态方法,不需要对象,第一个参数传递为null m.invoke(null, "蛤蛤蛤"); &#125; /** * 调用参数是基本类型数组的方法 */ @Test public void testInvokeIntArray() throws Exception &#123; //找到基本类型数组方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method7", int[].class); int[] arr = new int[]&#123;1, 2, 3&#125;; //person有公共的无参数构造器,可以直接通过,字节码对象去调用 m.invoke(clz.newInstance(), new Object[]&#123;arr&#125;); &#125; /** * 调用参数是引用类型数组的方法 * 在Invoke方法中,第二个参数实际上要的是一个Object数组 * 底层将所有的实际参数放在一个Object类型的数组中 */ @Test public void testInvokeString() throws Exception &#123; Class&lt;? extends Person&gt; clz = new Person().getClass(); Method m = clz.getMethod("method8", String[].class); String[] str = new String[]&#123;"A", "B"&#125;; //wrong number of arguments:参数个数错误 /* 如果显式的传递到Invoke方法中,已经是一个Object数组了.那么会解包 解开之后是-&gt;String[].class 如果传递的是散数据-&gt;1,2,3,会装成一个Object数组,装包之后,invoke再解包 解开之后是-&gt;int.class,int.class 基本类型数组,不是Object类型的数组,所以会装包,也会拆包. 把int类型数组装进Object数组,再拆成int类型数组 引用类型数组,已经是Object类型数组,不会装包,直接拆-&gt; String.class,String.class不匹配方法参数的String[]数组 */ m.invoke(clz.newInstance(), new Object[]&#123;str&#125;); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>reflect</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL初识]]></title>
    <url>%2F2019%2F03%2F28%2FGraphQL%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[GraphQL是一个用于API的查询语言.一个GraphQL服务是通过定义类型和类型上的字段来创建,然后给每个类型上的每个字段提供解析函数.基本用法:12345678type Query &#123; me: User &#125;type User &#123; id: ID name: String&#125; 每个类型上字段的解析函数1234567function Query_me(request) &#123; return request.auth.user;&#125;function User_name(user) &#123; return user.getName();&#125; 一个GraphQL服务运行起来(通常在web服务的一个URL上),它就能接收GraphQL查询,并验证和执行.查询会检查确保只会引用已经定义的类型和字段,然后运行指定的解析函数来生成结果12345&#123; me&#123; name &#125;&#125; 会返回一个JSON结果12345&#123; "me": &#123; "name": "hhh" &#125;&#125; 字段也能指代对象类型(Object).对这个对象的字段进行次级选择(Sub-selection).遍历相关对象及其字段,使得客户端可以一次请求查询大量相关数据.12345678910&#123; hero&#123; name # 这是注释 # 这里friens指代一个对象类型 friends &#123; name &#125; &#125;&#125; 返回结果:123456789101112131415161718&#123; "data": &#123; "hero": &#123; "name": "R2-D2", "friends": [ &#123; "name": "Luke Skywalker" &#125;, &#123; "name": "Han Solo" &#125;, &#123; "name": "Leia Organa" &#125; ] &#125; &#125;&#125; friens返回了一个数组的项目,GraphQL查询会同等看成单个项目或者一个列表项目 传递参数:1234567&#123; human(id: "1000")&#123; id name height &#125;&#125; 返回结果:123456789&#123; "data": &#123; "human": &#123; "id": "1000", "name": "Luke Skywalker", "height": 1.72 &#125; &#125;&#125; 每一个字段和嵌套对象都能有自己的一组参数,从而使得GraphQL可以替代多次API请求.可以给标量(scalar)字段传递参数,用于实现服务端的一次转换1234567&#123; human(id: "1000")&#123; name #传入参数把单位转换为英尺 height(unit: FOOT) &#125;&#125; 12345678&#123; "data": &#123; "human": &#123; "name": "Luke Skywalker", "height": 5.6430448 &#125; &#125;&#125; 别名:通过设置别名可以通过不同参数查询相同字段12345678&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125; 12345678910&#123; "data": &#123; "empireHero": &#123; "name": "Luke Skywalker" &#125;, "jediHero": &#123; "name": "R2-D2" &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>PHP</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
</search>
