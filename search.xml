<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring框架-Ioc-DI]]></title>
    <url>%2F2019%2F05%2F11%2FSpring%E6%A1%86%E6%9E%B6-IoC-DI%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MyBatis增强]]></title>
    <url>%2F2019%2F05%2F10%2FMyBatis%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[使用mapper接口1.这个接口的全限定类名===对应的Mapper文件的namespace;2.这个接口中的方法和Mapper文件中的SQL元素一一对应: XML文件1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- StudentMapper的全限定类名 --&gt;&lt;mapper namespace="me.cscar.many2many.mapper.StudentMapper"&gt; &lt;insert id="save" useGeneratedKeys="true" keyProperty="id" keyColumn="id"&gt; INSERT INTO student (name) VALUES (#&#123;name&#125; ) &lt;/insert&gt;&lt;/mapper&gt; 测试类文件1234SqlSession session = MybatisUtil.getSession();StudentMapper studentMapper = session.getMapper(StudentMapper.class);/* 通过传入StudentMapper.class获得全限定名,就是namespace返回StudentMapper对象,调用save方法 */ mapper接口12void save(Student stu);//方法名为id 动态SQLif set where switch在多个中选择一个 foreach trim #{}和${}的区别相同: #和$都可以从对象或者Map中获取参数值 不同:使用#设置参数时候,先将参数转为?占位符,然后再赋值:使用PreparedStatement 使用$设置参数时,直接将参数拼接到sql中,使用Statement使用$设置参数可能存在SQL注入隐患. 使用#设置参数,如果是字符串,会自动加上’’, 而$不会,它会原样输出 在一些情况下,比如排序,比如分组操作时候拼接参数时不应该拼接’’ 总结:一般设置参数使用#,如果要拼接sql比如 排序,分组等.使用 $ (因为他们是按照列名来排序和分组的) 使用@param设置多个参数MyBatis在#{}中参数流程:1.会去参数对象中,按照属性或者Map的key去查询;2.如果找不到,尝试直接把方法的实际参数作为查询参数值 如果一定要在Mapper接口上的一个方法中添加多个参数,就一定要在每个参数前使用@Param标签. 原理:Mybatis在处理这些Mapper方法的时候,会自动的把这些参数包装成一个Map对象,@Param中的value就会作为这个Map的key,对应的参数值,就会作为这个Key的value; 原理:mybatis自动把参数封装成map 对象关系1.依赖关系:如果A对象离开了B对象,A对象就不能正常编译,则A对象依赖B对象. 2.关联关系:A对象依赖B对象,并且把B对象作为A对象的一个属性,则A和B是关联关系.(特殊的依赖关系) 3.聚合关系:表示整体和部分的关系,整体和部分之间可以相互独立存在,一定是有两个模块来分别管理整体和部分. 4.组合关系:强聚合关系,但是整体和部分不能独立存在,一定是在一个模块中同时管理整体和部分,生命周期必须相同. 5.泛化关系:其实就是继承关系. 关联关系划分1.一对一:一个A对象属于一个B对象,一个B对象属于一个A对象.2.一对多:一个A对象包含多个B对象. (判断基准:谁占主导地位),通过谁找到谁3.多对一:多个A对象属于一个B对象,并且每个A对象只能属于一个B对象.4.多对多:一个A对象属于多个B对象,一个B对象属于多个A对象.(老师和学生) MyBatis一级缓存缓存的作用/原理: 缓存本质来说就是Map,缓存是存在内存中的,可以在查询的时候减少数据库的访问次数,加快查询速度. 1.当第一次查询的时候get(1L),先将这次的调用转出一个字符串的key =Employee:1L首先在缓存中查询是否有这个key对应的对象,如果没有,去数据库中查询.查询之后会把该对象放入到缓存中,在把数据返回给调用者. 2.第二次查询的时候get(1L),先将这次的调用转出一个字符串的key =Employee:1L,在缓存中查询是否有可以key对应的对象,直接从内存中的缓存获取到对应的对象,直接返回一级缓存默认是开启的.一级缓存生命周期==session的生命周期,在多个session中是无法进行数据共享. 在一次会话中,如果需要查询多次相同id的对象,此时后面几次的查询都会从的缓存中获取,加快了查询速度,减少了访问数据库的次数.一级缓存的作用有限,只提高了一点点的性能. sqlsession的缓存操作注意问题:1: 缓存在同一个sqlsession才有效 2: 一旦sqlsession执行DML/DDL操作, 会清空缓存 3: 如果不想使用缓存,想直接从数据库获取: 可以执行: session.clearCache(); 4:开发中, sqlsession缓存仅仅针对某一个session, 对于整个系统性能提升不是很高, 一般来说, 不使用. 一般会使用二级缓存.(对应SqlSessionFactory) 二级缓存1.二级缓存生命周期==sessionFactory的生命周期. 2.二级缓存可以在不同的session之间进行数据的共享. 3.二级缓存默认是关闭的,需要手动的去开启. 4.不是所有对象都适合放到二级缓存中,只有是读远远大于写的对象才适合放到二级缓存中. 5.只要对象发生DML操作,MyBatis中的二级缓存都会给清除. 6手动开启的二级缓存.在对应的mapper.xml文件中添加一行: 一添加上就报错. java.io.NotSerializableException: cn.wolfcode._1_crud.User要求缓存的对象需要实现序列化接口. 缓存有个策略,当内存中的对象已经达到设置的存储最大值.超出的对象如果需要也缓存起来.支持把缓存对象序列化到硬盘中.要获取的时候再反序列化回来.]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie & Session]]></title>
    <url>%2F2019%2F05%2F05%2FCookie-Session%2F</url>
    <content type="text"><![CDATA[会话跟踪技术: Cookie SessionHTTP是无状态协议,也就是没有记忆力,每个请求之间无法共享数据. CookieCookie是客户端技术,程序把每个用户的数据以cookie的形式写给用户各自的浏览器.当用户使用浏览器再去访问服务器中的 web资源时,就会带着各自的数据去.这样,web资源处理的就是用户各自的数据了. Cookie 的使用:1.Cookie 是谁来创建,怎么创建的? 服务器端程序来创建: Cookie cookie = new Cookie(String name,String value); 参数: name: 给共享的数据起一个唯一的标志 value: 要存入的用户的数据 Cookie c = new Cookie(“currentName”,”xiaoming”); 2.如何响应 Cookie 给 浏览器. response对象.addCookie(Cookie cookie); resp.addCookie(c); 3.如何获取 Cookie 中的数据. 浏览器带过来的数据理应在请求对象中. Cookie[] cookies = request对象.getCookies(); 遍历数组拼配一个name是currentName 的数据. cookie.getName() : 获取Cookie 中的唯一标志的名称 cookie.getValue(): 当前Cookie 的数据. 4.修改Cookie 方式一: 再创建一个同 name 值的Cookie 对象来做覆盖的操作: Cookie cookie = new Cookie(“currentName”,”小明”) 方式二: 直接重新给Cookie赋值 cookie.setValue(“新的数据”) 注意: 两种方式都需要重新响应给浏览器去覆盖之前的Cookie 5.Cookie的中文问题 URLEncoder : 把中文转为非中文的字符串 URLDecoder : 把非中文的字符串转回中文 6 Cookie的分类 : 会话Cookie: 浏览器关闭 Cookie 就失效. 持久Cookie: Cookie 可以保留一定的时间. cookie.setMaxAge(int value): 使用的秒为单位: 负数: -1 : 不保存Cookie (会话Coookie); 0: 删除Cookie 正数: 设置存活的时间(秒) SessionSession是服务器端技术,利用这个技术,服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象,由于session为用户浏览器独享.所以用户在访问服务器的web资源时,可以把各自的数据放在各自的session中,当用户再去访问服务器中的其它web资源时,其它web资源再从用户各自的session中取出数据为用户服务. Session的使用Session 的使用:1 创建或获取Session 对象 HttpSession request.getSession(true) : 获取HttpSession对象,如果存在直接返回,如果不存在,创建一个新的Session对象然后返回. HttpSession request.getSession(false) : 获取HttpSession对象,如果存在直接返回,如果不存在返回null HttpSession request.getSession() : 同 1 2 设置共享数据 session.setAttribute(String name,Object value); 参数: name : 共享的数据的唯一标志 value : 要设置的共享数据 3 获取共享数据 session.getAttribute(String name); 4 移除 Session 中的数据 1:删除Session中指定属性名的值. session.removeAttribute(String name); 2:销毁Session对象 session对象.invalidate(); 5 Session的超时管理. 默认的超时时间: 30分钟 : 在Tomcat/conf/web.xml session.setMaxInactiveInterval(int seconds) 6 URL重写:Session 是一个特殊的Cookic ,存在浏览器上,用户可选择不接受Cookie方式一: 使用参数形式 jsessionid 传递给下一个请求,使用 ; 来设置参数的值方式二: 调用方法来生成带有 jsessionid 的 urlString url = resp.encodeURL(“/session/content”);开发中不要拒收Cookie]]></content>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三层架构]]></title>
    <url>%2F2019%2F05%2F05%2F%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[三层构架 表示层:位于最上层,最接近用户,用于显示数据和接收用户输入的数据,为用户提供一种交互式操作的界面 业务逻辑层:表示层和 DAL(DAO)层之间的桥梁,实现业务逻辑.业务逻辑具体包含:验证,计算,业务规则等等 数据访问层:与数据库打交道.主要实现对数据的增、删、改、查.将存储在数据库中的数据提交给业务层,同时将业务层处理的数据保存到数据库(Dao) 逻辑图: 业务逻辑层(service)其实是一个组件(可以重复使用),包括:接口和接口的实现类 service 组件起名规范:以下使用 Xxx 都表示一个对象比如 Employee,Department.service 接口 : IEmployeeServiceservice 实现类: EmployeeServiceImplservice 测试类: EmployeeServiceTestservice 对象的名字: Employee,Department]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL增强]]></title>
    <url>%2F2019%2F05%2F03%2FMySQL%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[数据库数据库（DataBase）：是一个按数据结构来存储和管理数据的计算机软件系统. 简而言之:存储数据的仓库/存储数据的特殊文件. 1.数据定义语言:DDL数据库建立、修改、变更及扩充功能2.数据操纵语言:DML实现数据的插入,修改,删除,查询,统计等数据存取操作的功能称为数据操纵功能3.数据查询语言:DQL用以从表中获得数据,确定数据怎样在应用程序给出.保留字SELECT是DQL(也是所有SQL)用得最多的动词,其他DQL常用的保留字有WHERE,ORDER BY,GROUP BY和HAVING.这些DQL保留字常与其他类型的SQL语句一起使用 数据库基础关系型数据库和非关系型数据库关系型数据库：在关系模型中，数据的逻辑结构为满足一定条件的二维表，表具有固定的列数和任意的行数，在数学上称为”关系” 关系型数据库的三范式:第一范式(1NF):是对关系模式的基本要求,不满足第一范式就不是关系数据库.是指数据表的每一列都是不可分割的基本数据项,同一个列中不能有多个值. 第二范式(2NF):每个实例或行&apos;必须有主键&apos;,区分每一行数据(可以被打破) 第三范式(3NF):要求一个数据表中,不包含其它表中的非主键信息.(在设计表的时候,为了性能,有时会打破第3范式) 常见的数据库1.Oracle：大型企业数据库，支持数据量，速度较快，安全性非常好，提供完善的存储过程支持；新的版本提供了众多新功能； 2.DB2（IBM）：大型企业数据库，支持数据量，速度较快，安全性较好, 恢复性强； 3.SQL Server（MS）：大型企业数据库，支持数据量，速度较快，安全性较好； 4.MySQL（Oracle）：性能不错，使用方便，体积小，易扩展；是目前使用最广的关系型数据库； 查询多表查询-笛卡尔积没有连接条件的表关系返回结果,多表查询会产生笛卡尔积.解决方案: 在WHERE加入有效的连接条件—-&gt;等值连接隐藏内连接查询语法:1234SELECT &lt;select_list&gt;FROM 表名称 A, 表名称 BWHERE 查询条件 AND 消除笛卡尔积的连接条件[ORDER BY 排序字段 [ASC|DESC] [,排序字段 [ASC|DESC] ,…]]; 显示内连接查询语法:12SELECT &lt;select_list&gt;FROM A [INNER] JOIN B ON 消除笛卡尔积的连接条件 [JOIN ...] 内连接查询,两种查询的结果完全相同,区别在于是否能看到JOIN关键字 unionJOIN是用于把表横向连接，UNION/UNION ALL是用于把表纵向连接(一般用于做查询的临时表)UNION 操作符用于合并两个或多个 SELECT 语句的结果集.1234语法：SELECT column_name(s) FROM table_name1UNION|UNION ALLSELECT column_name(s) FROM table_name2 单行函数DAY(date):获取日期中的天数（DAYOFMONTH）HOUR(time):返回time 对应的小时数。对于日时值的返回值范围是从 0 到 23MINUTE(time):返回 time 对应的分钟数,范围是从 0 到 59MONTH(date):返回date 对应的月份，范围时从 1 到 12YEAR(date):返回date 对应的年份,范围是从1000到9999LAST_DAY(date):获取一个日期或日期时间值，返回该月最后一天对应的值DATE_FORMAT(data,format) 聚合分组函数AVG：计算平均值SUM：计算总和 COUNT ({ |[DISTINCT|ALL]expr})COUNT()返回表中所有符合条件的记录数COUNT(字段) 返回所有符合条件并且字段值非空的记录(右键设置某个字段为null,如果加了where条件后, 就以where 后面的列作为计数条件)COUNT(distinct(expr))返回不重复的，非空值的数量 MIN and MAX适用于任何数据类型MIN： 计算最小值MAX：计算最大值 分组查询分组查询的语法:SELECT [DISTINCT] *|分组字段1 [别名] [,分组字段2 [别名] ,…] | 统计函数/分组函数/聚合函数FROM 表名称 [别名], [表名称 [别名] ,…][WHERE 条件(s)][GROUP BY 分组字段1 [,分组字段2 ,…]][ORDER BY 排序字段 ASC | DESC [,排序字段 ASC | DESC]]; 注意: 1出现在SELECT列表中的字段,如果出现的位置不是在聚合函数中,那么必须出现在 GROUP BY 子句中 2.在GROUP BY 子句中出现的字段，可以不出现在SELECT列表中 3.如果没有GROUP BY子句, SELECT列表中的任何列或表达式不能和统计/分组/聚合函数同时使用： 错误操作: select ename, sal, count(empno) from emp; 如果现在要进行分组的话，则SELECT子句之后，只能出现分组的字段和统计函数，其他的字段不能出现 使用HAVING子句对分组的结果进行限制 1.不能在 WHERE 子句中 对分组之后的结果过滤. 2.使用group by语句后,如果需要过滤, 必须使用 HAVING 子句(分组后的过滤). 3.不能在 WHERE 子句中使用聚合函数. 其他123select -- from --- where --- group by ----having --- order by --- limit?,?sql 执行顺序~~~from -- where -- group by -- having -- select -- order by -- limit ?, ? 子查询子查询指的就是在一个查询之中嵌套了其他的若干查询.在where查询条件中的限制条件不是一个确定的值,而是来自于另一个查询结果. 子查询一般出现在FROM和WHERE子句中. 使用子查询的注意事项: 1.子查询要用括号括起来 2.将子查询放在比较运算符的右边(增强可读性) 3.对单行子查询使用单行运算符 4.对多行子查询使用多行运算符 语法:123SELECT &lt;select_list&gt;FROM 'table'WHERE 条件 操作符 (SELECT select_list FROM table); 子查询的分类:单行单列子查询,得到的是一个值,返回的结果只包含一行数据 多行单列子查询,得到的是一个集合,返回多行或零行 多行多列子查询,得到的是一个二维表,包含多个字段的返回(一张临时的表) 单行单列子查询:1.返回一行记录,好比一个值.2.使用单行记录比较运算符=;&gt;;&gt;=;&lt;;&lt;=!=(针对于一个值得运算符) 多行子查询返回多行单列1.返回多行,好比多个值2.使用多行比较运算符 IN:与列表中的任意一个值相等 =ANY:此时和IN操作符相同 &gt;ANY:大于子查询中最小数据 &lt;ANY:小于子查询中最大数据 &gt;ALL:大于子查询中最大的数据 &lt;ALL:小于子查询中最小的数据 多列子查询子查询返回的结果是多行多列/一行多列,只要是多列,就可以看成是一张表.一般会把多列子查询.返回的结果当成一个临时表,接着在临时表上继续查询或者询注意:多行多列的子查询返回的结果必须要设置一个临时表的名称. DML操作1.插入操作1INSERT INTO table [(column [, column...])] VALUES (value [, value...]),(value [, value...]),... 一条SQL的长度是有限的，可以通过调整max_allowed_packet参数(可以在my.ini文件中修改) 2.更新操作123UPDATE tableSET column = value [,column = value]…[WHERE condition]; UPDATE语句也可以使用表连接，子查询等多种方式执行3.删除操作12DELETE FROM table[WHERE condition]; 事务控制开启事务: begin提交事务: commit回滚事务: rollback 事务的ACID:原子性:Atomicity一致性:Consistency隔离性:Isolation持久性:Durability 控制事务的SQL语句(命令):commit 和 rollback可以显示的控制事务好处：1.保证数据一致性,修改过的数据在没有提交之前是不能被其他用户看到的2.在数据永久性生效前重新查看修改的数据3.将相关操作组织在一起,一个事务中相关的数据改变或者都成功,或者都失败 数据库的并发问题:MySQL使用的是repreatable read隔离级别 避免第二类丢失更新 方案1:悲观锁: 使用数据库自身的排它锁机制(写锁)(排斥其他锁).DML操作自动会加上排它锁 (排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁). DQL操作需要我们手动加上排他锁.1SELECT * FROM 表名 FOR UPDATE. 方案2:乐观锁: 在表中额外增加一个列,用来表示修改的版本(整数类型),修改一次就把版本增加1. 1:在表中新增一个列,用来表示修改的版本号,类型使用整数类型,初始值为0. 2:每次在修改数据之前,先发送SELECT语句去查询当前被修改数据的信息(包括版本号).1SELECT id,name,version FROM person WHERE id = 10; 查询出来的版本号为0. 3:发送UPDATE语句去更新数据:版本号修改递增1/判断条件中的版本号必须是刚刚查询出来的版本.1UPDATE person set name = 'Java' ,version = version + 1 WHERE id = 10 AND version = 刚刚查询出来的版本号(0). 4:判断update语句执行之后的受影响行数(rows),若rows&gt;0则提交事务,否则回滚事务. 数据库的权限权限相关命令:GRANT:MySQL中用于赋权限的命令是GRANT，语法为：完整语法：GRANT 权限 (columns)ON 数据库对象TO 用户 IDENTIFIED BY “密码”WITH GRANT OPTION 三种具体的语法: 给一个存在用户赋予权限:语法1:GRANT 权限 (columns) ON 数据库对象 TO 用户:赋予will账户:SELECT和INSERT权限.GRANT select,insert ON . TO will@localhost; 左边是数据库 . 右边是数据表. 表示全局权限 创建用户,设置密码,赋予权限:语法2:GRANT 权限 (columns) ON 数据库对象 TO 用户 IDENTIFIED BY “密码”创建lucy用户:GRANT ALL ON . TO lucy@localhost IDENTIFIED BY ‘1234’; 创建用户,设置密码,赋予权限,并且该用户可以继续授权给其他用户:语法3:GRANT 权限 (columns) ON 数据库对象 TO 用户 IDENTIFIED BY “密码” WITH GRANT OPTION]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web组件交互_el_jstl]]></title>
    <url>%2F2019%2F04%2F22%2Fweb%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92-el-jstl%2F</url>
    <content type="text"><![CDATA[web组件在web应用中,servlet/jsp就是web的组件 跳转:请求转发和重定向 共享数据:作用域对象 jsp页面取数据EL表达式 优雅的显示数据JSTL 请求转发1.请求转发:forward2.重定向:redirect3.请求包含:include常用api: 在HttpServletRequest对象中 RequestDispatcher getRequestDispatcher(String path):获取请求分发器. String path: 请求转发到的目标资源 void forward(ServletRequest request, ServletResponse response) :请求转发的动作. 12//获取到请求分发器,请求转发到WEB-INF/view/product/table.jsp资源上 req.getRequestDispatcher("WEB-INF/view/product/table.jsp").forward(req, resp); url重定向在HttpServletResponse对象中. void sendRedirect(java.lang.String location) : 重定向, String location: 重新定位的资源的地址.12//url重定向resp.sendRedirect("/pro?cmd=list"); 1.地址栏会发生变化.是s2. 2.只会有目标资源s2的响应,s1的响应不生效. 3.重定向会发送两次请求.在多个组件不能共享数据. 4.重定向,不能访问WEB-INF中的资源,相当于是把目标资源放在浏览器的地址栏敲回车. 5.重定向可以访问别人(域外)的资源. 请求转发和url重定向选择请求转发: 共享数据 请求到WEB-INF中的资源url重定向: 访问域外资源都能使用的情况,使用重定向 三大作用域对象 作用域 类型 描述 request HttpServletRequest 在一次请求中,多个组件都共享数据,需要使用请求.request在service方法中,tomcat在调用这个生命周期方法的时候,就会创建. session HttpSession HttpSession session = request.getSession(); 使用请求对象获取session对象 application ServletContext ServletContext application = getServletContext(); ServletContext application = request.getServletContext(); 共享数据的基本操作 1.新增数据: void setAttribute(java.lang.String name, java.lang.Object o): 保存数据,包含唯一的名字,和可重复值.2.删除数据: void removeAttribute(java.lang.String name):根据共享属性名.来删除共享数据3.修改数据: void setAttribute(java.lang.String name, java.lang.Object o):同新增4.查询数据: java.lang.Object getAttribute(java.lang.String name):通过共享数据(属性)的唯一名字,找到对应的值. 三大作用域范围1.请求作用域对象:1req.setAttribute("MSG_IN_REQUEST","request"); 只能在一次请求中共享数据,如果不是同一个请求,是多次请求,一定不能共享.如果想要在一次请求过程中的多个组件,要共享,需要使用请求转发. 2.会话作用域对象:1req.getSession().setAttribute("MSG_IN_SESSION","session"); 想在访问站点之后,多次请求都需要共享.可以使用session对象.从访问开始到浏览器关闭为止.3.应用作用域对象:1req.getServletContext().setAttribute("MSG_IN_APPLICATION","application"); 只要服务器开启,都可以共享. 上下文对象:环境.整个应用的生命周期.从服务器启动,到服务器关闭,只有一个. 对象的获取方式: 1.当前servlet中,可以调用getServletContext来获取. 2.request对象可以调用getServletContext获取. 3.session对象可以调用getServletContext来获取. 不管用什么对象来获取到的上下文对象,都是同一个对象. 常用的API: java.lang.String getRealPath(java.lang.String path) :传递一个地址,可以得到真正的磁盘地址. 负责把路径直接拼接到webapp根的后面,不负责去校验是否合法. String getContextPath();获取上下文路径. EL表达式:语法格式:${共享数据的属性名.属性名.属性名}.从page作用域开始,一直找到application为止,如果找到,直接返回,如果没找到,返回的是空字符串. JSTL使用JSTL标签库消除JSP中的java代码 条件判断1.if单条件判断123&lt;c:if test="$&#123;用EL表达式取出来的值&#125;" //如果test返回true,执行&lt;/c:if&gt; 2.choose多条件判断12345678&lt;c:choose&gt;&lt;c:when test="$&#123;用EL表达式取出来的值&#125;"&gt; //&lt;/c:when&gt;&lt;c:otherwise&gt; //TODO...&lt;/c:otherwise&gt;&lt;/c:choose&gt; 循环标签1234567&lt;c:forEach var="stu" items="$&#123;result.listData&#125;" varStatus="vs"&gt; &lt;tr&gt; &lt;td&gt;$&#123;vs.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; items代表源数据,需要使用EL表达式去取var代表每一个变量,该变量将会存储到PageContext作用域中varStatus代表迭代状态.vs.index:从0开始,vs.count:从1开始 时间格式化标签1&lt;fmt:formatDate value="$&#123;date&#125;" pattern="yyyy-MM-dd"/&gt;]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>网络编程</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis设计模式总结]]></title>
    <url>%2F2019%2F04%2F17%2FMyBatis%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MyBatis设计模式总结Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder； 工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory； 单例模式，例如ErrorContext和LogFactory； 代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；组合模式，例如SqlNode和各个子类ChooseSqlNode等；模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；迭代器模式，例如迭代器模式PropertyTokenizer； Builder模式在SqlSessionFactoryBuilder类中,重载了build方法这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决,对于builder的具体类，方法都大都用build*开头.即根据不同的输入参数来构建SqlSessionFactory这个工厂对象]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2019%2F04%2F17%2FMyBatis%2F</url>
    <content type="text"><![CDATA[ORM思想对象关系映射Object Relational MappingORM主要解决对象-关系的映射 对象 关系 类 表 对象 表的行(记录) 属性 表的列(字段) MyBatis:本是apache的一个开源项目iBatis,提供的持久层框架包括SQL Maps和DAO,允许开发人员直接编写SQL主配置文件,关联映射文件 XML映射配置文件 mybatis-config.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- properties配置文件 --&gt; &lt;properties resource="db.properties"&gt;&lt;/properties&gt; &lt;!-- domain的全限定名 --&gt; &lt;typeAliases&gt; &lt;package name="me.cscar.smis.domain.Student"/&gt; &lt;/typeAliases&gt; &lt;!-- 告知框架,链接数据库的四要素,以及事务的处理 --&gt; &lt;environments default="dev"&gt; &lt;!-- id属性是某一个环境的唯一标记 --&gt; &lt;environment id="dev"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 驱动名,键值对,对应properties --&gt; &lt;property name="driver" value="$&#123;driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 找到Sql的映射文件,包名开头(域名倒写)的路径 --&gt; &lt;mappers&gt; &lt;mapper resource="me/cscar/smis/mapper/StudentMapper.XML" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; StudentMapper.XML123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 命名空间mapper接口的全限定名 --&gt;&lt;mapper namespace="me.cscar.smis.mapper.StudentMapper"&gt; &lt;!-- id属性:当前的sql语句,在mapper的唯一标记 --&gt; &lt;insert id="save"&gt; &lt;!-- 占位符#&#123;&#125;,mybatis从对应的对象中,取出指定的属性值 --&gt; INSERT INTO student (name,age) VALUES (#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 如果是DML操作,直接告知sql.在执行的时候,传递参数,使用OGNL表达式来获取值. 如果是DQL(查询)操作,还必须告知框架,查询的结果的每一行封装成什么类型的对象. sql语句的执行流程: 首先,会将#{}更改成占位符?, 然后,通过传递过来的参数来设置给占位符. 如果列名和属性名匹配,可以使用resultType,也可以使用resultMap. 如果不匹配,要使用resultMap. Mybatis.java1234567891011121314151617181920212223242526package me.cscar.smis.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;public class MybatisUtil &#123; private static SqlSessionFactory factory = null; static &#123; try &#123; factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream("mybatis-config.xml")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession() &#123; return factory.openSession(); &#125;&#125; mybatis操作流程: 加载主配置文件,获取factory对象. factory = new SqlSessionFactoryBuilder().build(); 获取xml文件,等同于thread… Resources.getResourceAsStream(“mybatis-config.xml”) 通过factory对象获取session对象. 调用Mybatis的getSqlSession方法,返回openSession 通过session执行sql. … DML操作要手动提交事务. … 关闭资源]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2F04%2F15%2FServlet%2F</url>
    <content type="text"><![CDATA[Servlet概述Java Servlet(服务小程序),生成动态的web内容Servlet运行于支持Java的web应用服务器中 1.导入jar包.在/Library/Tomcat/lib/servlet-api.jar 2.创建一个类,实现servlet接口 3.配置web.xml web.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!-- 配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;me.cscar.network.servlet.HelloServlet&lt;/servlet-class&gt; &lt;!-- 初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 一个实现servlet接口的类1234567891011121314151617181920212223242526272829303132333435package me.cscar.network.servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.IOException;public class HelloServlet implements javax.servlet.Servlet&#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("success"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; servlet的生命周期1.创建对象 2.初始化 3.执行操作 4.销毁 整个生命周期的过程都是用Tomcat来管理调用123456789101112131415161718192021//初始化方法public void init(ServletConfig servletConfig) throws ServletException &#123;&#125;//获取当前servlet的配置信息public ServletConfig getServletConfig() &#123; return null;&#125;//执行操作的方法public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;&#125;//返回作者,版权信息,版本信息public String getServletInfo() &#123; return null;&#125;//销毁方法public void destroy() &#123;&#125; 注意:在servlet整个生命周期中,都是单例的.servlet的构造器必须是公共无参数构造器 servlet的请求流程1.在当前项目的根路径下的WEB-INF目录中,读取web.xml文件2.获取web.xml中所有的元素,判断是否存在标签里的资源名称,不存在返回404错误3.根据/资源名称获取对应的servlet的全限定名.4.根据获取到的全限定名,使用反射来调用构造器,创建对象1Object obj = Class.forName("全限定名").newInstance(); 5.使用创建的servlet对象,调用init(config)方法.或者,从Tomcat中的servlet实例缓冲池中取出”全限定名”对应的对象,Servlet obj = …6.创建ServletRequest对象,ServletResponse对象,再使用servlet对象调用service方法.1obj.service(req,resp) 7.在service方法中对客户端做响应操作 Servlet接口配置web.xml初始化参数12345&lt;!-- 初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; 通过servlet对象获取参数1String encoding = obj.getInitParameter("encoding") //utf-8 获取所有的初始化参数名称123456Enumeration&lt;String&gt; names = obj.getInitParameterNames(); //使用迭代器遍历while (names.hasMoreElements()) &#123; String name = names.nextElement(); String value = config.getInitParameter(name); System.out.println(name + ":" + value);&#125; 方法1234String getServletName() //获取当前Servlet 的&lt;servlet-name&gt;中的内容ServletContext getServletContext() //获取上下文对象,一个应用就只有一个上下文对象String getInitParameter(String name) //获取指定名称的初始化参数值Enumeration&lt;String&gt; getInitParameterNames() //获取所有的初始化参数的名称 Servlet的继承体系12345678910111213141516171819package me.cscar.network.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HttpServletDemo extends HttpServlet &#123; @Override public void init() throws ServletException &#123; System.out.println("自己的初始化代码"); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("执行操作"); &#125;&#125; HttpServletRequest常用方法 常用方法 返回 req.getMethod() 请求方式(post,get) req.getRequestURI 返回请求行中的资源名字部分 req.getRequestURL() 返回客户端请求的完整url req.getContextPath() 获取当前项目的上下文路径path的值 req.getRemoteAddr() 发出请求的客户机ip地址 req.getHeader(“User-Agent”) 指定名称的头字段的值 获取表单请求参数 方法 返回 req.getParameter(“value”) 获取表单请求参数 getParameterValues(“hobby”) 指定名字参数的多个参数值。(复选框) req.getParameterNames() 获取表单的所有参数名 req.getParameterMap() 把所有的表单数据保存在map中 getOutputStream() 获取字节输出流对象. ( 文件下载) getWriter() 获取字符输出流对象 response.setContentType(“text/html;charset=utf-8”) 设置输出的MIME类型和编码方式 123456789101112131415161718192021222324252627282930313233343536//req.getMethod():返回请求方式System.out.println(req.getMethod());//req.getRequestURI:返回请求行中的资源名字部分System.out.println(req.getRequestURI());//返回客户端请求的完整urlSystem.out.println(req.getRequestURL());//获取当前项目的上下文路径&lt;context&gt;path的值System.out.println("ContextPath" + req.getContextPath());//返回发出请求的客户机ip地址System.out.println(req.getRemoteAddr());//返回指定名称的头字段的值System.out.println(req.getHeader("User-Agent"));//设置编码req.setCharacterEncoding("UTF-8");System.out.println("name:" + req.getParameter("username"));System.out.println("password:" + req.getParameter("psw"));//获取表单中的多个数据String[] values = req.getParameterValues("hobby");System.out.println(Arrays.toString(values));//获取表单的所有参数名Enumeration&lt;String&gt; names = req.getParameterNames();while (names.hasMoreElements()) &#123; String name = names.nextElement(); System.out.println(name);&#125;//把所有的表单数据保存在map中Map&lt;String, String[]&gt; map = req.getParameterMap();Set&lt;Map.Entry&lt;String, String[]&gt;&gt; entrySet = map.entrySet();for (Map.Entry&lt;String, String[]&gt; entry : entrySet) &#123; String name = entry.getKey(); String[] value = entry.getValue(); System.out.println(name + ":" + Arrays.toString(value));&#125; JSP的原理流程:1.所有的jsp,jspx的访问都交给JspServlet来处理2.把jsp文件转化为java文件3.把所有java文件都转化为字节码文件4.把转化的文件存放在tomcat/work/…文件下 体系:HttpServlet &lt;- HttpJspBase &lt;- myDemo_jspjsp就是一个Servlet在java文件中123out.write("");...out.print(...); 存在字符输出流对象,输出了html jsp语法:123456789&lt;%!Java代码%&gt;&lt;%-- 注释,不会编译到servlet中 --%&gt;&lt;%= 表达式(调用out.print,输出到页面上) %&gt; JSP 三大指令 page include taglib page指令:作用：定义JSP页面的各种属性 属性：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748language:指示JSP页面中使用脚本语言。默认值java，目前只支持java。extends：指示JSP对应的Servlet类的父类。不要修改。*import：导入JSP中的Java脚本使用到的类或包。（如同Java中的import语句）JSP引擎自动导入以下包中的类： javax.servlet.* javax.servlet.http.* javax.servlet.jsp.*注意：一个import属性可以导入多个包，用逗号分隔。*sessioin:指示JSP页面是否创建HttpSession对象。默认值是true，创建*buffer：指示JSP用的输出流的缓存大小.默认值是8Kb。autoFlush：自动刷新输出流的缓存。isThreadSafe：指示页面是否是线程安全的（过时的）。默认是true。 true：不安全的。 false：安全的。指示JSP对应的Servlet实现SingleThreadModel接口。 *errorPage: 指示当前页面出错后转向（转发）的页面。 目标页面如果以"/"（当前应用）就是绝对路径。配置全局错误提示页面：web.xml&lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;&lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt;&lt;/error-page&gt;*isErrorPage:指示当前页面是否产生Exception对象。*contentType：指定当前页面的MIME类型。作用与Servlet中的response.setContentType()作用完全一致*pageEncoding：通知引擎读取JSP时采用的编码（因为要翻译） 还有contentType属性的作用。*isELIgnored:是否忽略EL表达式。$&#123;1+1&#125;。默认值是false。 page指令最简单的使用方式：&lt;%@ page pageEncoding="UTF-8"%&gt;2.include（静态包含,开发中能用静的不用动的） 作用：包含其他的组件。 语法：&lt;%@include file=""%&gt;file指定要包含的目标组件。路径如果以"/"（当前应用）就是绝对路径。 原理：把目标组件的内容加到源组件中，输出结果。 动态包含： 采用动作元素：&lt;jsp:include page=""/&gt;路径如果以"/"（当前应用）就是绝对路径。 3.taglib 作用：引入外部的标签 语法 &lt;%@ taglib uri="标签名称空间" prefix="前缀"%&gt; &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>网络编程</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F04%2F15%2FHttp%2F</url>
    <content type="text"><![CDATA[HTTP概述特点:无状态,,默认端口是80HTTP协议:浏览器(客户端)于web服务器之间一问一答的交互过程必须遵循一定的规则 UDP:面向数据报包,基于无连接,可能会丢包,速度快.广播.一堆人都可以听到,但是可能有部分人丢失数据.TCP:面向连接,传输可靠.性能低一些.相当于是一对一的教学,保证客户端和服务端一定能传输数据.基于浏览器的开发,都是TCP连接. HTTP1.1规范在一次TCP连接之间,多次请求,多次响应,响应完之后再关闭连接 GET和POST的区别GET:在请求某个服务器资源,如果没有指定请求方式,默认为GET可以通过GET的方式向服务器传递数据.方式:在URL路径加上?,多个参数用&amp;分割GET请求方式数据不安全(在URL显示),且URL有长度限制1Kget可以缓存,查询的时候可以使用getPOST:数据安全,且没有长度限制只有post才有请求实体.表单全部使用post提交]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>网络编程</tag>
        <tag>服务器</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接池]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[连接池在Java中,连接池使用javax.sql.DataSource接口来表示连接池.DataSource(数据源)和连接池(Connection Pool)是同一个. DBCP: Spring框架推荐的 druid: 阿里巴巴的连接池(号称Java语言中性能最好的连接池) DBCP连接池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package me.cscar.dbcp.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCutil &#123; private static Properties prs = new Properties(); private static BasicDataSource bds = null; //private static DataSource dsf = null; static &#123; try &#123; InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("db.properties"); prs.load(in); Class.forName(prs.getProperty("driverClassName")); //在静态代码块中初始化连接池对象,连接池只需一个即可 bds = BasicDataSourceFactory.createDataSource(prs); //druid连接池 //dsf = DruidDataSourceFactory.createDataSource(prs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; Connection conn = bds.getConnection(); //Connection conn = dsf.getConnection(); return conn; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(ResultSet rs, PreparedStatement ps, Connection conn) &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; druid连接池阿里巴巴研发出来的号称Java语言领域性能最高的连接池.wiki地址:https://github.com/alibaba/druid/wiki 使用起来,类似于DBCP连接池.方便检测性能/状态.支持:MySQL,Oracle,DB2,sql Server等.支持:对配置文件的密码加密.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package me.cscar.dbcp.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCutil &#123; private static Properties prs = new Properties(); //private static BasicDataSource bds = null; private static DataSource dsf = null; static &#123; try &#123; InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("db.properties"); prs.load(in); Class.forName(prs.getProperty("driverClassName")); //在静态代码块中初始化连接池对象,连接池只需一个即可 //bds = BasicDataSourceFactory.createDataSource(prs); //druid连接池 dsf = DruidDataSourceFactory.createDataSource(prs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; //Connection conn = bds.getConnection(); Connection conn = dsf.getConnection(); return conn; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(ResultSet rs, PreparedStatement ps, Connection conn) &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码重构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package me.cscar.dbcp.dao.impl;import me.cscar.dbcp.dao.IemployeeDAO;import me.cscar.dbcp.domain.Employee;import me.cscar.dbcp.util.JDBCutil;import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class EmployeeDAOimpl implements IemployeeDAO &#123; public static EmployeeDAOimpl instance = new EmployeeDAOimpl(); /** * dml操作 * * @param sql * @param obj */ @Override public void dml(String sql, Object... obj) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; obj.length; i++) &#123; ps.setObject(i + 1, obj[i]); &#125; ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(null, ps, conn); &#125; &#125; /** * 查 * * @param emp,args * @return */ @Override public List&lt;Employee&gt; get(String sql, Object emp, Object... args) &#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); Class&lt;?&gt; clz = emp.getClass(); while (rs.next()) &#123; BeanInfo info = Introspector.getBeanInfo(clz, Object.class); PropertyDescriptor[] pds = info.getPropertyDescriptors(); Object obj = clz.newInstance(); for (PropertyDescriptor ele : pds) &#123; //id,name,salary String cloumnName = ele.getName(); Object cloumnValue = rs.getObject(cloumnName); //getter,setter Method m = ele.getWriteMethod(); m.invoke(obj, cloumnValue); &#125; list.add((Employee) obj); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(rs, ps, conn); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>DataBase</category>
        <category>pool</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2019%2F04%2F10%2F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务事务(Transaction,简写为tx)1.当一个逻辑操作单元全部完成的时候,提交(commit)事务,这个操作就永久的保存到数据库中 2.如果回退(rollback),则放弃这个逻辑单元的所有操作 3.对于多个操作来说,作为一个整体(不可分割),所有操作成功(提交事务),数据库的数据才会改变 事务的ACID属性1.原子性(Atomicity) 2.一致性(Consistency) 3.隔离性(Isolation) 4.持久性(Durability) 事务的操作1.如果要控制事务,需要手动提交2.在MySQL中,只有InnoDB存储引擎支持事务123456789101112131415161718192021222324252627282930313233343536373839404142434445package me.cscar.account.test;import me.cscar.account.dao.impl.AccountDAOimpl;import me.cscar.account.util.JDBCutil;import org.junit.Test;import java.math.BigDecimal;import java.sql.Connection;import java.sql.SQLException;public class TXBalance &#123; @Test public void testTx() throws Exception &#123; BigDecimal money = new BigDecimal("1000"); AccountDAOimpl account = AccountDAOimpl.getInstance(); Connection conn = null; try &#123; if (account.getBalance("嘤嘤", money)) &#123; conn = JDBCutil.getConnection(); //设置手动处理事务 conn.setAutoCommit(false); account.addBalance("蛤蛤", money, conn); //假设出错 int i = 1 / 0; account.reduceBalance("嘤嘤", money, conn); //全部操作成功,提交事务 conn.commit(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); conn.rollback(); &#125; &#125;&#125; 获取自动生成的主键在数据库中保存数据的时候,要使用到自增id的时候就需要取出来. 1.如果要获取,需要设置一个标记. PreparedStatement prepareStatement(String sql, int autoGeneratedKeys):获取预编译语句对象的时候,可以设置标记,是否要获取自动生成的主键. autoGeneratedKeys: 是否要获取自动生成的主键. Statement.RETURN_GENERATED_KEYS 2.获取自动生成的主键. ResultSet getGeneratedKeys(): 获取自动生成的主键. 12345678910111213141516171819202122public class GetKey &#123; @Test public void testGetKey() throws Exception &#123; //插入一条数据到account表中获取自动生成的组件 String sql = "INSERT INTO account (name,balance) VALUES (?,?)"; Connection conn = JDBCutil.getConnection(); PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); ps.setObject(1, "包包"); ps.setObject(2, 10000); ps.executeUpdate(); //获取自动生产的组件 ResultSet rs = ps.getGeneratedKeys(); while (rs.next()) &#123; System.out.println(rs.getObject(1)); &#125; rs.close(); JDBCutil.close(ps, conn); &#125;&#125;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F04%2F06%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC概述可以为多种关系数据库提供统一访问,为开发者屏蔽了一些细节问题 获取数据库链接对象Connection -&gt; 数据库连接对象 导入驱动包 获取数据库连接对象 1.加载注册驱动: Driver驱动类:应该加载驱动包中实现Driver接口类的对象 public static void registerDriver(Driver driver):注册驱动 API中,建议使用Class.forName(“com.mysql.jdbc.Driver”);加载字节码对象的时候,会执行这个类的静态代码块. 调用Class.forName不是目的,目的是为了执行com.mysql.jdbc.Driver这个类的静态代码块. 而这个类的静态代码块就是在加载注册驱动 2.获取数据库连接对象 DriverManager驱动管理类: public static Connection getConnection(String url, String user, String password): 获取数据库连接对象. JDBC操作模板1.加载注册驱动 2.获取数据库连接对象 3.生成预编译语句对象 4.执行SQL命令 5.释放资源 相关操作executeQuery(String sql): 执行DQL操作,返回单个ResultSet对象.executeUpdate(String sql): 执行DDL和DML操作 DML操作123456789101112131415161718192021222324252627package me.cscar.dml;import me.cscar.util.JDBCUtil;import org.junit.Test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class InsertTable &#123; @Test public void testInsertTable() throws Exception &#123; String sql = "INSERT INTO student(name,age) VALUES('东方翠花',20)"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.链接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javaweb", "***", "***"); //3.创建语句对象 Statement st = conn.createStatement(); //4.执行SQL命令 st.executeUpdate(sql); //5.释放资源 JDBCUtil.close(conn, st); &#125;&#125; 抽象出JDBCUtil包,复用释放资源代码 1234567891011121314151617181920212223public class JDBCUtil &#123; public JDBCUtil() &#123; &#125; public static void close(Connection conn, Statement st) &#123; try &#123; if (st != null) &#123; st.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 预编译语句对象PreparedStatement对象:又叫做预编译语句对象,是一个包含占位符?的sql模板. 1.PreparedStatement ps= conn.prepareStatement(sql模板);// 传递的是sql模板,不能直接执行. 2.ps.setObject(int parameterIndex, Object x):给占位符?设置值,parameterIndex代表第N个?号,x是具体参数 3.执行sql语句:不能调用父类带参数的方法. 如果直接调用父类的带sql参数方法,会直接将带占位符?的sql模板拿过去执行 123456789101112131415161718192021222324public class Insert &#123; @Test public void TestInsert() throws Exception &#123; Student stu = new Student(null, "小茗同学", 20); //问号表示占位符 String sql = "INSERT INTO student(name,age) VALUES(?, ?)"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.链接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///javaweb", "root", "admin"); //3.获取预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //4.执行SQL语句,给占位符设置值 ps.setObject(1, stu.getName()); ps.setObject(2, stu.getAge()); ps.executeUpdate(); //释放资源 JDBCUtil.close(conn, ps); &#125;&#125; DQL操作ResultSet常用的API: Object getObject(int columnIndex): 根据数据的列的索引获取数据. columnIndex: 表示第几列的意思,从1开始. Object getObject(String columnLabel): 根据数据的列名来获取数据. columnLabel: 表示列名. boolean next(): 是否有下一行, 如果返回是true,表示已经移动到下一行了. 获取单条数据12345678910111213141516171819202122232425public class TestGet &#123; @Test public void testGet() throws Exception &#123; //?表示占位符 String sql = "SELECT * FROM student WHERE id=?"; //注册加载驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //获得数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javaweb", "root", "admin"); //获取预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //给SQL设置值 ps.setObject(1, 5L); ResultSet resultSet = ps.executeQuery(); if (resultSet.next()) &#123; Object obj = resultSet.getObject("name"); System.out.println(obj); &#125; JDBCUtil.close(conn, ps); &#125;&#125; 获取全部数据,用list装1234567891011121314151617181920212223242526272829303132public class TestListAll &#123; @Test public void testListAll() throws Exception &#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); String sql = "SELECT * FROM student"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.获得连接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///javaweb", "root", "admin"); //3.获得预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //执行查询 ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; Student stu = new Student(); long id = rs.getLong("id"); String name = rs.getString("name"); Integer age = rs.getInt("age"); stu.setId(id); stu.setName(name); stu.setAge(age); list.add(stu); &#125; System.out.println(list); JDBCUtil.close(conn, ps); &#125;&#125; DAO规范使用DAO规范对数据库的增删改查,避免重复代码,直接调用DAO方法 DAO的设计1.保存方法 void save(Object obj) 把要保存的信息,封装成一个对象,传递给方法. 用来描述数据库表结构的javabean, 是一个特殊的javabean. ---&gt; domain 2.删除方法 void delete(Long id) 根据主键id来删除数据 3.修改方法 void update(Object obj) 把传递过来的新的信息设置到指定的数据库的记录 4.查询单个 Student get(Long id) 把查询数据封装到domain中. 5.查询多个 List&lt;Student&gt; listAll(); 使用ArrayList装 DAO的规范DAO规范,只要有操作数据库的地方,都需要该规范.主要就是针对包以及类名进行规范. 1.DAO接口. me.cscar.smis.dao:IXxxDAO ====&gt; Xxx 就是domain 2.DAO接口的实现类. me.cscar.smis.dao.impl:StudentDAOImpl 3.domain类: me.cscar.smis.domain:Student 4. 测试类: me.cscar.smis.test:StudentDAOTest 5. 工具类: me.cscar.smis.util:StringUtil/JDBCUtil 开发流程1.创建数据库表 2.根据数据库表来创建domain包以及类.1234567891011121314151617package me.cscar.refactorpro.domain;import lombok.*;import java.math.BigDecimal;@Getter@Setter@AllArgsConstructor@NoArgsConstructor@ToStringpublic class Product &#123; private Long id; private String productName; private BigDecimal salePrice; private BigDecimal cutoff;&#125; 3.根据domain来创建DAO包以及接口.1234567891011121314151617181920212223242526272829303132333435363738394041424344package me.cscar.refactorpro.dao;import me.cscar.refactorpro.domain.Product;import java.util.List;public interface IProductDAO &#123; /** * 增加 * * @param pro */ void save(Product pro); /** * 删除 * * @param id */ void delete(Long id); /** * 修改 * * @param pro */ void update(Product pro); /** * 查询指定 * * @param id * @return */ Product get(Long id); /** * 查询全部 * * @return */ List getAll();&#125; 4.根据DAO接口来生成实现类.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190package me.cscar.refactorpro.dao.impl;import me.cscar.refactorpro.dao.IProductDAO;import me.cscar.refactorpro.domain.Product;import me.cscar.refactorpro.util.JDBCutil;import java.math.BigDecimal;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class ProductDAOImpl implements IProductDAO &#123; public static ProductDAOImpl getInstance() &#123; return new ProductDAOImpl(); &#125; /** * 增加 * * @param pro */ @Override public void save(Product pro) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "INSERT INTO t_product (productName,salePrice,cutoff) VALUES (?,?,?)"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, pro.getProductName()); ps.setObject(2, pro.getSalePrice()); ps.setObject(3, pro.getCutoff()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(conn, ps); &#125; &#125; /** * 删除 * * @param id */ @Override public void delete(Long id) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "DELETE FROM t_product WHERE id = ?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, id); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBCutil.close(conn, ps); &#125; /** * 修改 * * @param pro */ @Override public void update(Product pro) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "UPDATE t_product SET productName=?,salePrice=?,cutoff=? WHERE id=?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, pro.getProductName()); ps.setObject(2, pro.getSalePrice()); ps.setObject(3, pro.getCutoff()); ps.setObject(4, pro.getId()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(conn, ps); &#125; &#125; /** * 查询指定 * * @param id * @return */ @Override public Product get(Long id) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; String sql = "SELECT * FROM t_product WHERE id = ?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, id); rs = ps.executeQuery(); while (rs.next()) &#123; Product pro = new Product(); String productName = rs.getString("productName"); BigDecimal salePrice = rs.getBigDecimal("salePrice"); BigDecimal cutoff = rs.getBigDecimal("cutoff"); Long proid = rs.getLong("id"); pro.setId(proid); pro.setProductName(productName); pro.setSalePrice(salePrice); pro.setCutoff(cutoff); return pro; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBCutil.close(conn, ps); &#125; throw new RuntimeException("查询错误"); &#125; /** * 查询全部 * * @param pro * @return */ @Override public List getAll() &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; String sql = "SELECT * FROM t_product"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); rs = ps.executeQuery(); List&lt;Product&gt; list = new ArrayList&lt;&gt;(); while (rs.next()) &#123; Product pro = new Product(); String productName = rs.getString("productName"); BigDecimal salePrice = rs.getBigDecimal("salePrice"); BigDecimal cutoff = rs.getBigDecimal("cutoff"); Long proid = rs.getLong("id"); pro.setId(proid); pro.setProductName(productName); pro.setSalePrice(salePrice); pro.setCutoff(cutoff); list.add(pro); &#125; return list; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); JDBCutil.close(conn, ps); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; throw new RuntimeException("查询出错"); &#125;&#125; 5.根据测试先行,根据DAO接口生成测试类.完成测试类.12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.refactorpro.test;import me.cscar.refactorpro.dao.impl.ProductDAOImpl;import me.cscar.refactorpro.domain.Product;import me.cscar.refactorpro.util.JDBCutil;import org.junit.Test;import java.math.BigDecimal;import java.sql.Connection;import java.util.List;public class ProductDAOTest &#123; @Test public void save() &#123; Product pro = new Product(null, "mac", new BigDecimal("15000"), new BigDecimal("0.9")); ProductDAOImpl.getInstance().save(pro); &#125; @Test public void delete() &#123; ProductDAOImpl.getInstance().delete(6L); &#125; @Test public void update() &#123; Product newpro = new Product(5L, "suffer", new BigDecimal("14000"), new BigDecimal("0.99")); ProductDAOImpl.getInstance().update(newpro); &#125; @Test public void get() &#123; Product product = ProductDAOImpl.getInstance().get(4L); System.out.println(product); &#125; @Test public void getAll() &#123; List all = ProductDAOImpl.getInstance().getAll(); System.out.println(all); &#125;&#125; 抽取和完善JDBCutil新建配置文件,properties1234ClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql:///javawebuserName=xxxpassword=xxx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package me.cscar.refactorpro.util;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;import java.util.Properties;public class JDBCutil &#123; private static Properties pre = new Properties(); static &#123; InputStream is = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("prodb.properties"); try &#123; pre.load(is); Class.forName(pre.getProperty("ClassName")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; Connection conn = DriverManager.getConnection(pre.getProperty("url"), pre.getProperty("userName"), pre.getProperty("password")); return conn; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(Connection conn, PreparedStatement ps) &#123; try &#123; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 预编译语句对象原理避免了sql语句字符串拼接.有的数据库有DBMS有缓冲区,预编译语句对象可以提交效率. mysql不支持 DBMS1.安全检查2.语义分析检查语句在缓存中是否存在3.编译SQL4.执行SQL 有缓存区会存储编译好的sql模板,? 使用预编译语句对象可以防止SQL注入]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pocketbook]]></title>
    <url>%2F2019%2F04%2F04%2Fpocketbook%2F</url>
    <content type="text"><![CDATA[pocketbook基于Swing和JDBC开发的桌面程序,JavaSE基础的综合.使用git进行版本管理,合作开发 github地址:https://github.com/Cscar2H/pocketbook 数据库和表1create database pocketbook 根据需求,设计了3个表 1.配置表信息 config 用于保存预算和用于备份还原的路径 2.消费分类表 category 用于保存消费分类 3.记录表 record 用于保存每一笔的消费记录,并且会用到消费分类 config表使用键值对保存了key_和value,例如key=”budget” value=”200”,表示预算是200元 category表name表示分类的类名 record表spend 表示单次花费cid 对应的消费分类表的中记录的idcomment 备注信息date 日期分类表和记录表之间的关系是一对多,record表中cid就是外键 功能开发主界面:在startup包下新建一个类Bootstrap,这个类专门负责启动程序,作为一个程序的启动入口,可以执行一些初始化操作. 使用了SwingUtilities.invokeAndWait的方式启动图形界面同时使用了调度线程,保证创建和显示界面的操作都在同一个线程中123456789SwingUtilities.invokeAndWait(new Runnable() &#123; @Override public void run() &#123; //是否显示主窗体 MainFrame.instance.setVisible(true); //在主界面中显示SpendPanel的界面 MainPanel.instance.workingPanel.show(SpendPanel.instance); &#125; &#125;); 使用监听器界面效果创建一个独立的监听器类ToolBarListener,实现接口ActionListener,重写了该接口中的actionPerformed方法。 在工具栏里的每一个按钮都使用一个这样的监听器. 通过ActionEvent.getSource()获取事件是哪个按钮发出来的.根据不同的按钮,发出切换不同的功能面板.1234567891011121314151617181920212223242526272829public class ToolBarListener implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; MainPanel p = MainPanel.instance; JButton b = (JButton) e.getSource(); if (b == p.bReport) &#123; p.workingPanel.show(ReportPanel.instance); &#125; if (b == p.bCategory) &#123; p.workingPanel.show(CategoryPanel.instance); &#125; if (b == p.bSpend) &#123; p.workingPanel.show(SpendPanel.instance); &#125; if (b == p.bRecord) &#123; p.workingPanel.show(RecordPanel.instance); &#125; if (b == p.bConfig) &#123; p.workingPanel.show(ConfigPanel.instance); &#125; if (b == p.bBackup) &#123; p.workingPanel.show(BackupPanel.instance); &#125; if (b == p.bRecover) &#123; p.workingPanel.show(RecoverPanel.instance); &#125; &#125;&#125; 实例化一个ToolBarListener监听器,给工具栏的按钮添加listener监听器对象.在MainPanel面板中使用监听器123456789101112private void addListener() &#123; ToolBarListener listener = new ToolBarListener(); bSpend.addActionListener(listener); bRecord.addActionListener(listener); bCategory.addActionListener(listener); bReport.addActionListener(listener); bConfig.addActionListener(listener); bBackup.addActionListener(listener); bRecover.addActionListener(listener);&#125; 初始化数据库配置效果 业务类ConfigService业务类,这个类是监听器直接调用的类,然后再通过ConfigService去调用ConfigDAO。 之前DAO是直接链接数据库,在操作数据库之前,需要对一些数据进行预处理,这些就可以放在业务类里进行. ConfigService 1.初始化 因为设置信息里有两个数据，一个是预算，一个是Mysql路径。 这两个信息，无论如何都应该是存在数据库中的。 所以会调用init把他们俩初始化。 2.init(String key, String value) 方法 首先根据key去查找，如果不存在，就使用value的值插入一条数据。 3.get(String key) 根据键获取相应的值 4.update(String key, String value) 更新键对应的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package me.cscar.service;import me.cscar.dao.ConfigDAO;import me.cscar.domain.Config;public class ConfigService &#123; public static final String BUDGET = "budget"; public static final String PATH = "mysqlPath"; public static final String DEFAULT_BUDGET = "500"; static ConfigDAO dao= new ConfigDAO(); static&#123; init(); &#125; public static void init()&#123; init(budget, default_budget); init(mysqlPath, ""); &#125; private static void init(String key, String value) &#123; Config config= dao.getByKey(key); if(config==null)&#123; Config c = new Config(); c.setKey(key); c.setValue(value); dao.add(c); &#125; &#125; public String get(String key) &#123; Config config= dao.getByKey(key); return config.getValue(); &#125; public void update(String key, String value)&#123; Config config= dao.getByKey(key); config.setValue(value); dao.update(config); &#125; public int getIntBudget() &#123; return Integer.parseInt(get(budget)); &#125; &#125; ConfigListener 监听器ConfigListener，这个监听器是用在更新按钮上的 1.判断输入的预算是否为整数 2.判断输入的MySQL 3.如果判断通过,就调用业务类ConfigService更新数据 12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.gui.listener; import me.cscar.gui.panel.ConfigPanel;import me.cscar.gui.util.GUIUtil;import me.cscar.service.ConfigService;import java.awt.event.ActionEvent; import java.awt.event.ActionListener;import java.io.File; import javax.swing.JOptionPane; public class ConfigListener implements ActionListener&#123; @Override public void actionPerformed(ActionEvent e) &#123; ConfigPanel p = ConfigPanel.instance; //判断 if(!GUIUtil.checkNumber(p.tfBudget, "预算")) &#123; return; &#125; String mysqlPath =p.tfMysqlPath.getText(); //判断MySQL路径是否正确 if(0!=mysqlPath.length())&#123; File commandFile = new File(mysqlPath,"bin/mysql"); if(!commandFile.exists())&#123; JOptionPane.showMessageDialog(p, "Mysql路径不正确"); p.tfMysqlPath.grabFocus(); return; &#125; &#125; ConfigService cs= new ConfigService(); cs.update(ConfigService.budget,p.tfBudget.getText()); cs.update(ConfigService.mysqlPath,mysqlPath); JOptionPane.showMessageDialog(p, "设置修改成功"); &#125; &#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>desktop</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F04%2F03%2FMySQL%2F</url>
    <content type="text"><![CDATA[SQLSQL：结构化查询语言(Structured Query Language)SQL包含6个部分 1.数据库查询语言(DQL) 2.数据操作语言(DML) 3.事务处理语言(TCL) 4.数据控制语言(DCL) 5.数据定义语言(DDL) MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。MyISAM：拥有较高的插入，查询速度，但不支持事务，不支持外键。InnoDB：支持事务，支持外键，支持行级锁定，性能较低。 InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但对比MyISAM，处理效率差，且会占用更多的磁盘空间以保留数据和索引。 ORM思想: 对象关系映射 –&gt; Java的对象和关系型数据库的映射 表 面向对象 表结构 类 表的列 属性 表的行 对象 MySQL命令行1.sudo mysql.server start : 启动数据库 2.sudo mysql.server stop : 关闭数据库 3.mysql -u root -p : 进入数据库(我的版本信息:Server version: 8.0.12 Homebrew) 4.use mysqlname; : 进入数据库 5.show tables; : 查看表 6.desc table_name; : 查看表结构 7.create table table_name : 创建表 8.drop table table_name : 删除表 MySQL列的常见类型 Java MySQL int INT long BIGINT BigDecimal DECIMAL boolean BIT java.util.Date DATE/DATETIME String VARCHAR 表约束 1.非空约束：NOT NULL(NK)，不允许某列的内容为空。 2.设置列的默认值：DEFAULT。 3.唯一约束：UNIQUE(UK)，在该表中，该列的内容必须唯一。 4.主键约束：PRIMARY KEY(PK)， 非空且唯一。 5.主键自增长：AUTO_INCREMENT，从1开始，步长为1。(MySQL特有) 6.外键约束：FOREIGN KEY(FK)，A表中的外键列的值必须参照于B表中的某一列(B表主键)。 数据操作(DML)保存操作 1INSERT INTO table_name(column1,column2,colum3...) VALUES (value1, value2, value3); 更新操作 1UPDATE table_name SET `columnName` = &apos;value&apos; WHERE (`condition` = &apos;num&apos;); 删除操作 1DELETE FROM table_name WHERE (`condition` = &apos;num&apos;); 数据查询操作(DQL)基本语法1SELECT * FROM table_name; 说明：SELECT 选择查询列表,列与列之间用逗号隔开FROM 提供数据源(表、视图或其他的数据源) 如果为 * 和创建表时的顺序一致。可以自己调整顺序，在select后边加上要查询的列名。 消除结果中重复的数据1SELECT DISTINCT 列名.. FROM table_name; 数学运算 数学运算:对NUMBER型数据可以使用算数操作符创建表达式（+ - * /） 对DATE型数据可以使用部分算数操作符创建表达式 （+ -） 运算符优先级： 1、乘法和除法的优先级高于加法和减法 2、同级运算的顺序是从左到右 3、表达式中使用&quot;括号&quot;可强行改变优先级的运算顺序 设置显示格式: 一旦遇到变量和常量拼接就必须使用CONCAT函数 把多个值以字符串拼接的形式拼在一起,可以使用函数concat(...) 设置列名的别名 1.改变表的名字； 2.用于表示计算结果的含义； 3.作为列的别名； 4.如果别名中使用特殊字符，或者是强制大小写敏感，或有空格时，都需加引号；别名以后都不加引号.加了引号的别名导致排序失效. 过滤查询 过滤查询比较运算符 运算符 含义 = 等于 &gt; 大于 &gt;= 大于或等于 &lt; 小于 &lt; 小于 &lt;= 小于或等于 !=(&lt;&gt;) 不等于 逻辑运算符 运算符 含义 AND(&amp;&amp;) 如果组合的条件都是TRUE,返回TRUE OR(&#124;&#124;) 如果组合的条件之一是TRUE,返回TRUE NOT(!) 如果下面的条件是FALSE,返回TRUE 范围查询 使用BETWEEN运算符显示某一值域范围的记录，这个操作符最常见的使用在数字类型数据的范围上，但对于字符类型数据和日期类型数据同样可用。 格式： SELECT &lt;columnList&gt; FROM table_name WHERE 列名 BETWEEN minvalue AND maxvalue：闭区间。 集合查询 使用IN运算符，判断列的值是否在指定的集合中。 格式： WHERE 列名 IN (值1，值2....); 空值查询 IS NULL:判断列的值是否为空。 空值是特指没有值的列 格式：WHERE 列名 IS NULL; 模糊查询 使用LIKE运算符执行通配查询，查询条件可包含文字字符或数字： %通配符：可表示任意个数的任意字符。 _通配符：可表示一个任意字符。 通配符：用来实现匹配部分值得特殊字符。 结果排序使用ORDER BY子句将记录排序ASC升序DESC降序ORDER BY 子句出现在SELECT语句的最后。格式：SELECT FROM table_nameWHERE 条件ORDER BY 列名1 [ASC/DESC],列名2 [ASC/DESC]…;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识XML]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%88%9D%E8%AF%86XML%2F</url>
    <content type="text"><![CDATA[XMLXML概述使用XML文件,可以保存复杂的数据,数据结构清晰(树状结构) 传输数据是一种通用的数据格式 传递数据,作为配置文件存在 XML语法 版本 &lt;?xml version=&quot;1.0&quot;?&gt; 用encoding属性说明文档所使用的字符编码，默认为UTF-8。保存在磁盘上的文件编码要与声明的编码一致。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 用standalone属性说明文档是否独立，即是否依赖其他文档。 &lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt; 标签的属性,描述该标签 &lt;linkman 属性名=&quot;属性值&quot;&gt; 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;contacts&gt; &lt;person id="1"&gt; &lt;name&gt;蔡徐坤&lt;/name&gt; &lt;address&gt;荷兰&lt;/address&gt; &lt;email&gt;kk@nmsl&lt;/email&gt; &lt;age&gt;17&lt;/age&gt; &lt;/person&gt; &lt;person id="2"&gt; &lt;name&gt;孙笑川&lt;/name&gt; &lt;address&gt;日本&lt;/address&gt; &lt;email&gt;cc@nmsl&lt;/email&gt; &lt;age&gt;18&lt;/age&gt; &lt;/person&gt;&lt;/contacts&gt; DOM解析(Document Object Model)文档对象模型,可以将xml的操作当做是操作对象 特点: 在加载XML文档的时候,会一次性把所有的信息加载到内存中(DOM树) 使用document这一对象来描述,剩下的操作都是操作内存中的对象 缺点: 如果XML文档内容比较多,文件比较大,一加载到内存中会导致,内存溢出 注意: 1.使用DOM解析,导入的类都是在org.w3c.dom包中.如果发现让你强转.意识到可能导错包了. 2.在XML中,一切皆节点 ####获取Document对象 三个类 Document DocumentBuilder DocumentBuilderFactory newDocumentBuilder:单例设计模式,需要通过自身的newInstance方法,获取一个新的实例 DocumentBuilder:需要通过newDocumentBuilder的实例中的newDocumentBuilder获取对象,该类重写了parse方法和newDocument方法 Document:接口,不能创建对象.抽象的parse方法和newDocument方法 12345678910111213141516171819202122232425262728package me.cscar.DOM.object;import org.junit.Test;import org.w3c.dom.Document;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.File;import java.io.InputStream;public class GetDOMObject &#123; @Test public void getObject() throws Exception &#123; File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.newDocument(); InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); Document doc1 = db.parse(is); //Document doc = db.parse(file); System.out.println(doc.equals(doc1)); &#125;&#125; ####常用API(增删改查)常用的API: Document对象: Element getDocumentElement(): 获取根节点. Element getElementById(String elementId) :根据唯一ID获取节点. Element对象: NodeList getElementsByTagName(String name):根据标签名获取到标签列表. String getAttribute(String name) :根据属性名,获取属性值 void setAttribute(String name, String value) :设置属性名和属性值. Node 对象: String getTextContent(): 返回当前节点的文本内容. void setTextContent(String value): 设置文本内容. ADD1234567891011121314151617181920212223242526272829303132333435363738394041424344package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;public class Add &#123; @Test public void useAdd() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //创建document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根节点 Element element = doc.getDocumentElement(); //创建节点 Element person = doc.createElement("person"); person.setAttribute("id", "4"); Element name = doc.createElement("name"); Element email = doc.createElement("email"); Element address = doc.createElement("address"); Element age = doc.createElement("age"); //创建层级关系 element.appendChild(person); person.appendChild(name); person.appendChild(email); person.appendChild(address); person.appendChild(age); //给节点设置数据 name.setTextContent("蛤蛤"); email.setTextContent("haha@china.com"); address.setTextContent("中国"); age.setTextContent("90"); SynchroFile.synchor(doc); &#125;&#125; REMOVE123456789101112131415161718192021222324252627282930313233343536373839package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 删除操作 */public class Remove &#123; @Test public void useRemove() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //获取document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根节点 Element de = doc.getDocumentElement(); //person标签 NodeList person = de.getElementsByTagName("person"); //获取第三个人的标签 Element p3 = (Element) person.item(2); System.out.println(p3.getAttribute("id")); p3.getParentNode().removeChild(p3); //同步操作,把修改的document对象写入 SynchroFile.synchor(doc); &#125;&#125; QUERY12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 查询操作 */public class Query &#123; @Test public void useQuery() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); Element de = doc.getDocumentElement(); //第1个人的信息节点 NodeList person = de.getElementsByTagName("person"); System.out.println("长度是"+person.getLength()); Element item = (Element) person.item(2); //获取ID编号 //System.out.println(item.getAttribute("id")); //找到第1个联系人的name节点 Element nameNode = (Element) item.getElementsByTagName("name").item(0); int re = item.getElementsByTagName("name").getLength(); //System.out.println(re); String name = nameNode.getTextContent(); System.out.println(name); //获取所有人的信息 for (int i = 0; i &lt; person.getLength(); i++) &#123; Element item1 = (Element) person.item(i); String name1 = item1.getElementsByTagName("name").item(0).getTextContent(); String email = item1.getElementsByTagName("email").item(0).getTextContent(); String address = item1.getElementsByTagName("address").item(0).getTextContent(); String age = item1.getElementsByTagName("age").item(0).getTextContent(); System.out.println(name1 + '\n' + email + '\n' + address + '\n' + age); System.out.println("-------------"); &#125; &#125;&#125; UPDATE12345678910111213141516171819202122232425262728293031323334353637package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 修改操作 */public class Update &#123; @Test public void useUpdate() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //获取document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根标签 Element element = doc.getDocumentElement(); //获取第3个人信息 Element person = (Element) element.getElementsByTagName("person").item(2); //获取name标签 Element name = (Element) person.getElementsByTagName("name").item(0); //修改name标签 name.setTextContent("包包"); //调用同步方法 SynchroFile.synchor(doc); &#125;&#125; 同步操作12345678910111213141516171819202122232425262728293031323334package me.cscar.DOM.frequently;import org.w3c.dom.Document;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.File;import java.io.InputStream;/** * 增删改的同步操作 * 把修改的document真正写入 */public class SynchroFile &#123; public static void synchor(Document doc) throws Exception &#123; File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); //获取工厂对象 TransformerFactory factory = TransformerFactory.newInstance(); //获取转换器 Transformer transformer = factory.newTransformer(); //调用转换器中的方法 Source src = new DOMSource(doc); Result target = new StreamResult(file); transformer.transform(src, target); &#125;&#125; 创建新的XML12345678910111213141516171819202122232425262728293031323334353637383940package me.cscar.DOM.create;import me.cscar.DOM.frequently.SynchroFile;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.File;public class Create &#123; @Test public void CreateDoc() throws Exception &#123; //File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); File newFile = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML_Copy.xml"); Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument(); //创建一个根节点 Element element = doc.createElement("contacts"); //添加根节点 doc.appendChild(element); TransformerFactory factory = TransformerFactory.newInstance(); Transformer tf = factory.newTransformer(); Source src = new DOMSource(doc); Result target = new StreamResult(newFile); tf.transform(src, target); &#125;&#125; ####XML约束(了解)]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>配置文件</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaUtility]]></title>
    <url>%2F2019%2F03%2F31%2FJavaUtility%2F</url>
    <content type="text"><![CDATA[LombokJavaBean规范代码生成工具]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>utility</tag>
        <tag>tool</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaBean]]></title>
    <url>%2F2019%2F03%2F30%2FJavaBean%2F</url>
    <content type="text"><![CDATA[JavaBean在Java中一个非常重要的组件,可重用.如果想要在多个模块中重用,必须遵循一定的规范. 1.必须使用public修饰 2.必须提供公共的无参数构造器 3.字段都是私有化的 4.提供get和set方法 JavaBean中重要成员方法 事件 属性:property,不是字段,而是通过get/set方法推导出来的 12345678910111213141516171819class HelloWorld &#123; private String name; /** * 标准的get方法 * get之后首字母小写,称之为属性 * */ public String getName() &#123; return name; &#125; /** * 标准的set方法 * set之后首字母大写,称之为属性 * */ public void setName(String name) &#123; this.name = name; &#125;&#125; 内省操作内省机制 核心类:Introspector 专门用来操作JavaBean的属性 核心方法 BeanInfo getBeanInfo(class&lt;?&gt; beanclass) 常用API java.beans.Introspector类常用API: static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass) : 获取字节码对象对应的JavaBean信息 static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass, Class&lt;?&gt; stopClass) java.beans.BeanInfo接口常用API: PropertyDescriptor[] getPropertyDescriptors() : 获取所有的属性描述器 java.beans.PropertyDescriptor类常用API: String getName() : 获得属性的名称 Class&lt;?&gt; getPropertyType() : 获得属性的类型 Method getReadMethod() : 获得用于读取属性值的方法 Method getWriteMethod() : 获得用于设置属性值的方法 JavaBean和Map的转换从浏览器传递过来的数据,服务器获取数据后.需要将数据放到一个对象中,传递的数据类似于key=value的形式.所以需要将map转换成JavaBean 都具有相似的结构 转换操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package me.cscar.con.conversion;import org.junit.Test;import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class JavaBeanMap &#123; @Test public void test() throws Exception &#123; //Person p = new Person("蛤蛤", 90); Class&lt;Person&gt; clz = Person.class; Constructor&lt;Person&gt; con = clz.getConstructor(String.class, Integer.class); Person p = con.newInstance("蛤蛤", 90); Map&lt;String, Object&gt; map = bean2map(p); System.out.println(map); System.out.println(map2bean(map, clz)); &#125; /** * JavaBean对象转换成map * 把JavaBean对象中的属性值,获取出来,放在map中 */ public static Map&lt;String, Object&gt; bean2map(Object obj) throws Exception &#123; BeanInfo beanInfo = Introspector.getBeanInfo(obj.getClass(), Object.class); //创建map对象 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Method m = ele.getReadMethod(); Object value = m.invoke(obj); map.put(key, value); &#125; return map; &#125; /** * map转换成JavaBean对象 * 把map的数据取出来,放到JavaBean对应的属性上 */ public static Object map2bean(Map&lt;String, Object&gt; map, Class clz) throws Exception &#123; //使用字节码对象创建对象 Object obj = clz.newInstance(); //获取字节码对象对应JavaBean信息 BeanInfo beanInfo = Introspector.getBeanInfo(clz, Object.class); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); //遍历 for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Object value = map.get(key); Method m = ele.getWriteMethod(); m.invoke(obj, value); &#125; return obj; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>JavaBean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Annotation注解]]></title>
    <url>%2F2019%2F03%2F30%2FAnnotation%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解(标签)注解的概述解决xml臃肿的问题 在Java5之后,开始对元数据的支持,就是Annotation(注解) 可以用来描述其他数据的一种数据,可以赋予其他数据一些功能 常用注解: @Override 限定覆写父类方法 @Deprecated 标记已过时,不推荐使用.在JDK1.5之前,使用文档注释来标记过时 @SuppressWarings 抑制编译器发出的警告,@SuppressWarings(value=&quot;all&quot;) @SafeVarargs 抑制堆污染警告(Java7开始出现的) @Functionallnterface 标记该接口是一个函数接口(Java8开始出现的) 注解的定义:123public @interface Test&#123; //抽象方法 属性&#125; 注解的使用语法: @注解名(属性名1=属性值1,属性名2=属性值2,...) 注解想要具有某一些功能,最重要的是需要三方程序的参与,必须使用反射来给注解赋予功能 元注解注解是用来约束其他程序元素的(字段,方法,),元注解是用来约束注解的 @Target: 表示注解可以贴在哪些位置(类,方法上,构造器上等等) @Retention: 表示注解可以保存在哪一个时期,存活时间 @Documented: 使用@Documented标注的标签会保存到API文档中 @Inherited: @Inherited标注的标签可以被子类所继承. 自定义注解语法格式 1. 可以为属性设置默认值, 使用default. 2. 如果必须要写的属性(可以有多个,其他的都有默认值),并且这个属性的名字叫value, 可以省略属性名,直接写值. 3. 属性的类型只能是基本类型,String,Class,注解,枚举,以及其数组类型. 4. 抽象方法不能有参数 使用注解是一种硬编码方式**]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Annotation</tag>
        <tag>注解</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置文件]]></title>
    <url>%2F2019%2F03%2F30%2F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[配置文件使用配置文件经常修改,从源文件的编写到部署的过程,都需要重新修改. 解决方案: 把配置保存在一个文件中, Java代码可以通过流(stream)动态的读取 真正解决的问题: 代码中的硬编码,写死到Java代码中,而且是经常改动的值 常用的配置文件1.properties文件. 文件后缀名.properties,用来保存一些简单的数据.保存格式:key=value 重复的key表示更新操作,不能存多个用户信息 2.xml文件 文件后缀名.xml,用来保存一些复杂的数据,按照清晰的格式保存(结构化) properties文件的基本使用常见的操作 创建properties文件,并存储数据 1.文件存放在resource文件夹中. 2.在该配置文件中,所有数据到Java后,都是String类型 3.等号不需要空格 123#这是注释,保存格式:key=valueusername=rootpassword=admin 使用jdk提供好的工具类来加载和获取 void load(InputStream inStream):通过输入流把数据加载到properties对象中 String getProperty(String key):通过指定的key获取value值 使用相对路径12//默认去bin中找Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;user.properties&quot;); 123456789101112131415161718public class PropertiesTest &#123; @Test public void loadProperties() throws Exception &#123; //创建properties对象 Properties pt = new Properties(); //获取相对路径 InputStream in = Thread.currentThread(). getContextClassLoader(). getResourceAsStream("user.properties"); //加载 pt.load(in); //获取 String username = pt.getProperty("username"); System.out.println(username); String password = pt.getProperty("password"); System.out.println(password); &#125;&#125; 反射的优势反射的应用场景 更多的是使用一个全限定名来创建对象(反射) 为了解决硬编码,为了降低代码的耦合性,一般将具体的实现类配置到配置文件中 1234567891011121314151617181920212223package me.cscar.con.reflect;import org.junit.Test;import java.io.InputStream;import java.util.Properties;public class Math implements IMath &#123; @Test public void testMath() throws Exception &#123; Properties ps = new Properties(); InputStream is = Thread. currentThread(). getContextClassLoader(). getResourceAsStream("math.properties"); ps.load(is); //forName获取properties文件中的全限定名称,并且创建对象 IMath math = (IMath) Class.forName(ps.getProperty("clssName")) .newInstance(); //getClass获取math的全限定名 System.out.println(math.getClass()); &#125;&#125; 优点: 1.反射提高了程序的灵活性和扩展性。 2.降低耦合性，提高自适应能力。 3.它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 1.性能问题：使用发射基本上是一种在运行期间解析字节码操作，效率较低，一般程序不建议使用，对灵活性和拓展性要求较高的工具或框架上使用较多。 2.代码复杂性：反射发生在运行期，程序员无法在源代码中看到程序的逻辑，反射代码比相应的直接的代码更复杂，因而会带来维护的问题 框架中大量使用反射,用来提高框架的扩展性和灵活性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JunitTest]]></title>
    <url>%2F2019%2F03%2F29%2FJunitTest%2F</url>
    <content type="text"><![CDATA[Junit回归测试框架的基本使用测试先行的思想 单元测试Junit属于白盒测试 定义一个测试方法:1.测试方法,必须是公共的无参数无返回的方法.建议使用test开头. 2.想要测试哪个方法,需要在该方法上贴一个注解@Test 12345678import org.junit.Test;public class HelloTest &#123; @Test public void addTest() &#123; System.out.println("添加用户信息"); &#125;&#125; Junit细节:更多是针对接进行测试,要测试一个接口中的方法,必须按照规范流程 定义一个接口:1234567891011121314151617181920212223242526package me.cscar.Junit;/** * 接口规范:文档注释 * 数学运算的加减乘除方法 * * @author cscar * @date 2019/3/29 */public interface IMath &#123; /** * 计算两个数相加 * @param a * @param b * @return 和 */ int add(int a, int b); /** * 计算两个数相除 * @param a * @param b * @return 商 */ int div(int a, int b);&#125; 根据接口生成实现类:1234567891011121314151617package me.cscar.Junit;/** * 实现IMath接口 */public class Math implements IMath &#123; @Override public int add(int a, int b) &#123; return a + b; &#125; @Override public int div(int a, int b) &#123; return a / b; &#125;&#125; 根据接口生成实现类:1234567891011121314151617181920212223242526package me.cscar.Junit;import org.junit.Test;import static org.junit.Assert.*;//测试数学运算public class MathTest &#123; /** * 面向接口,创建数学类对象 */ private IMath math = new Math(); @Test public void add() &#123; int result = math.add(3, 4); System.out.println(result); &#125; @Test public void div() &#123; int result = math.div(10, 0); System.out.println(result); &#125;&#125; 断言:猜测一个程序结果是否是期望结果 1.:Assert.assertEquals(message, expected, actual):比较的值 三个参数: message: 断言失败的提示信息,断言成功不会显示. expected: 期望值 actual: 真实值 2.:Assert.assertSame(message, expected, actual):比较地址,是同一个对象 Assert.assertNotSame(message, expected, actual):断言不是同一个对象 3.:Assert.assertTrue(message, condition):断言condition应该为TRUE. Assert.assertFalse(message, condition):断言condition应该为FALSE. 4.:Assert.assertNull(message, object):断言对象object为null. Assert.assertNotNull(message, object):断言对象object不为null. 5.:@Test(expected=ArithmeticException.class) 期望该方法报错ArithmeticException. 6.:@Test(timeout=400) 期望该方法在400毫秒之内执行完成. 123456789101112@Testpublic void add() &#123; int result = math.add(3, 4); //System.out.println(result); Assert.assertEquals(&quot;3+4我都能算错?&quot;, 8, result);&#125;@Test(expected = ArithmeticException.class)public void div() &#123; int result = math.div(10, 0); System.out.println(result);&#125; Junit自动化操作自动初始化自动销毁 1.@Test:需要测试的方法,必须贴Test注解.并且测试方法必须是公共无参数无返回的方法. 2.@Before:在所有的测试方法之前,都会执行的代码 3.@After:在所有的测试方法之后,都会执行的代码 4.@BeforeClass:在所有操作之前执行,只执行一次. 5.@AfterClass:在所有操作之前执行,只执行一次. 1234567891011121314151617181920212223242526272829303132333435package me.cscar.junit.work;import org.junit.*;public class WorkTest &#123; @Test public void query() &#123; System.out.println("查询用户信息"); &#125; @Test public void delete() &#123; System.out.println("删除用户信息"); &#125; @Before public void init() &#123; System.out.println("登录"); &#125; @After public void story() &#123; System.out.println("注销"); &#125; @BeforeClass public static void BeforeClass() &#123; System.out.println("所有操作之前"); &#125; @AfterClass public static void AfterClass() &#123; System.out.println("所有操作之后"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Junit</tag>
        <tag>测试类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect反射]]></title>
    <url>%2F2019%2F03%2F29%2FReflect%2F</url>
    <content type="text"><![CDATA[反射为什么要使用反射1234567891011121314151617181920//定义一个类class Person&#123; public Object work()&#123; //假设看不到源码,无法获取真实类型 return new Date(); &#125; //调用work方法 @Test public void testWork()&#123; Person p = new Person(); Object obj = new Person(); //返回值是一个对象,可以继续调用该对象的方法. Date d = (Date)obj; //打印本地的时间风格,但是却不知道应该用什么来接收(不知道返回的是date) String str = d.toLocalString(); System.out.println(str); &#125;&#125; Person类是别人提供好的字节码文件.看不到源码是不能直接强转的. 不爽:我都已经获取到真正的对象了,居然不能知道他的真实类型. 什么是反射:通过字节码(Class)对象,动态的获取该字节码中的成员(构造器,方法,字段,父类,包…) 字节码对象(Class):将多个Class类抽象出来,形成一个字节码的结构(everything is object) 当JVM加载完字节码后.会使用一个对象,来描述该字节码文件的结构.该对象包含操作字节码中成员的方法. 字节码对象,是JVM加载字节码文件的时候,给我们创建的一个对象,一份字节码,只会创建一个字节码对象. 获取字节码对象的三种方法:1.通过Class类的forName来获取. public static Class&lt;?&gt; forName(String className):根据全限定名来获取字节码对象. 全限定名:包名.类名.指定到唯一的一个类上. 2.所有的对象,都有一个公共的方法.getClass. public final Class&lt;?&gt; getClass(): 通过对象返回字节码对象. 3.任何类型都有一个class属性. int.class / Person.class/ 1234567891011121314151617181920212223242526272829303132package me.cscar.reflect.getClassObject;import org.junit.Test;public class GetClassTest &#123; @Test public void getClassObject() throws Exception &#123; //1.通过forName静态方法获取,抛出异常 Class clz = Class.forName("me.cscar.reflect.getClassObject.Person"); //2.通过对象.getClass()方法获取 Object obj = new Person(); Class clz1 = obj.getClass(); //3.任何类型都有一个class属性 Class clz2 = Person.class; //class me.cscar.reflect.getClassObject.Person System.out.println(clz); //true System.out.println(clz == clz1); //true System.out.println(clz == clz2); //int类型的class属性不等于integer的class属性,结果为false System.out.println(int.class == Integer.class); //integer的包装类型是int,结果为true System.out.println(int.class == Integer.TYPE); //class [Ljava.lang.String; System.out.println(String[].class); &#125;&#125; 构造器的操作获取构造器获取单个构造器 parameterTypes:参数类型 想要定位到一个构造器,必须要指明构造器的参数列表. 1.获取单个构造器: public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes):获取public的指定的构造器 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) :获取不管权限的构造器 2.获取所有构造器: Constructor&lt;?&gt;[] getConstructors() :获取所有public 的构造器 Constructor&lt;?&gt;[] getDeclaredConstructors() :获取所有构造器,不管权限. 123456789101112131415161718192021222324252627282930313233343536package me.cscar.reflect.getConstructor;import org.junit.Test;import java.lang.reflect.Constructor;public class GetConstructor &#123; @Test public void testGetConstructor() throws Exception &#123; //创建字节码对象 Class clz = Class.forName("me.cscar.reflect.getConstructor.Person"); //1.获取所有的public构造器 Constructor[] cons = clz.getConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //2.获取所有的构造器 cons = clz.getDeclaredConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //3.获取无参数构造器 Constructor con = clz.getConstructor(); //System.out.println(con); //4.获取带参数的public构造器 Constructor conagsP = clz.getDeclaredConstructor(Long.class, String.class, int.class); //System.out.println(conagsP); //5.获取带参数的构造器(暴力反射) Constructor conage = clz.getDeclaredConstructor(String.class, int.class); System.out.println(conage); &#125;&#125; 通过构造器创建对象 public T newInstance(Object... initargs):通过构造器,创建对象. initargs:实际参数. 如果想要调用私有的成员.必须要先设置可以访问. public void setAccessible(boolean flag): 设置为true. 12345678910111213141516171819202122232425262728293031323334package me.cscar.reflect.createObject;import org.junit.Test;import java.lang.reflect.Constructor;public class CreateObject &#123; @Test public void createObj() throws Exception &#123; Class&lt;Person&gt; clz = Person.class; //1)调用空参构造 Constructor&lt;Person&gt; con = clz.getConstructor(); Person p = con.newInstance(); System.out.println(p); //调用空参构造器方式二,字节码对象需要加泛型,直接使用字节码对象调用 p = clz.newInstance(); System.out.println(p); //2)获取带参数构造并创建对象 Constructor&lt;Person&gt; conargs = clz.getConstructor(Long.class, String.class, int.class); Person p1 = conargs.newInstance(9527L, "蛤蛤", 70); System.out.println(p1); //3)获取私有构造并创建对象 Constructor&lt;Person&gt; constructor = clz.getDeclaredConstructor(String.class, int.class); //设置非public的成员访问许可 constructor.setAccessible(true); Person p2 = constructor.newInstance("包包", 51); System.out.println(p2); &#125;&#125; 操作方法获取方法 name:方法名 parameterTypes:参数列表的类型 想要定位到一个方法,必须要指定方法签名(方法名+参数列表) 1.获取多个方法 Method[] getMethods() :获取到所有的public方法,包括继承的. Method[] getDeclaredMethods() :获取所有的方法,不包括继承的. 2.获取单个方法 Method getMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的public方法 Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的方法,不管权限. 12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.reflect.getMethod;import org.junit.Test;import java.lang.reflect.Method;public class GetMethod &#123; @Test public void getMethod() throws Exception &#123; //使用反射创建对象 Class&lt;Person&gt; clz = Person.class; Person p = clz.newInstance(); //1)执行无参无返回的方法 Method m = clz.getMethod("method1"); Object ret = m.invoke(p); System.out.println(ret); //2)执行有参无返回的方法 Method m1 = clz.getMethod("method2", String.class); Object ret1 = m1.invoke(p, "蛤蛤"); System.out.println(ret1); //3)执行无参有返回的方法 Method m2 = clz.getMethod("method3"); Object ret2 = m2.invoke(p); System.out.println(ret2); //4)执行有参有返回的方法 Method m3 = clz.getMethod("method4", String.class); Object ret3 = m3.invoke(p, "蛤蛤蛤"); System.out.println(ret3); //5)执行私有方法 Method m4 = clz.getDeclaredMethod("method5"); //设置可以访问 m4.setAccessible(true); Object ret4 = m4.invoke(p); System.out.println(ret4); &#125;&#125; 反射的其他API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package me.cscar.reflect.staticmethod;import org.junit.Test;import java.lang.reflect.Method;public class MethodTest &#123; /** * 调用静态方法 */ @Test public void testInvokeStaticMethod() throws Exception &#123; //找到静态方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method6", String.class); //调用方法.由于是static修饰,执行静态方法,不需要对象,第一个参数传递为null m.invoke(null, "蛤蛤蛤"); &#125; /** * 调用参数是基本类型数组的方法 */ @Test public void testInvokeIntArray() throws Exception &#123; //找到基本类型数组方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method7", int[].class); int[] arr = new int[]&#123;1, 2, 3&#125;; //person有公共的无参数构造器,可以直接通过,字节码对象去调用 m.invoke(clz.newInstance(), new Object[]&#123;arr&#125;); &#125; /** * 调用参数是引用类型数组的方法 * 在Invoke方法中,第二个参数实际上要的是一个Object数组 * 底层将所有的实际参数放在一个Object类型的数组中 */ @Test public void testInvokeString() throws Exception &#123; Class&lt;? extends Person&gt; clz = new Person().getClass(); Method m = clz.getMethod("method8", String[].class); String[] str = new String[]&#123;"A", "B"&#125;; //wrong number of arguments:参数个数错误 /* 如果显式的传递到Invoke方法中,已经是一个Object数组了.那么会解包 解开之后是-&gt;String[].class 如果传递的是散数据-&gt;1,2,3,会装成一个Object数组,装包之后,invoke再解包 解开之后是-&gt;int.class,int.class 基本类型数组,不是Object类型的数组,所以会装包,也会拆包. 把int类型数组装进Object数组,再拆成int类型数组 引用类型数组,已经是Object类型数组,不会装包,直接拆-&gt; String.class,String.class不匹配方法参数的String[]数组 */ m.invoke(clz.newInstance(), new Object[]&#123;str&#125;); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>reflect</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL初识]]></title>
    <url>%2F2019%2F03%2F28%2FGraphQL%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[GraphQL是一个用于API的查询语言.一个GraphQL服务是通过定义类型和类型上的字段来创建,然后给每个类型上的每个字段提供解析函数.基本用法:12345678type Query &#123; me: User &#125;type User &#123; id: ID name: String&#125; 每个类型上字段的解析函数1234567function Query_me(request) &#123; return request.auth.user;&#125;function User_name(user) &#123; return user.getName();&#125; 一个GraphQL服务运行起来(通常在web服务的一个URL上),它就能接收GraphQL查询,并验证和执行.查询会检查确保只会引用已经定义的类型和字段,然后运行指定的解析函数来生成结果12345&#123; me&#123; name &#125;&#125; 会返回一个JSON结果12345&#123; "me": &#123; "name": "hhh" &#125;&#125; 字段也能指代对象类型(Object).对这个对象的字段进行次级选择(Sub-selection).遍历相关对象及其字段,使得客户端可以一次请求查询大量相关数据.12345678910&#123; hero&#123; name # 这是注释 # 这里friens指代一个对象类型 friends &#123; name &#125; &#125;&#125; 返回结果:123456789101112131415161718&#123; "data": &#123; "hero": &#123; "name": "R2-D2", "friends": [ &#123; "name": "Luke Skywalker" &#125;, &#123; "name": "Han Solo" &#125;, &#123; "name": "Leia Organa" &#125; ] &#125; &#125;&#125; friens返回了一个数组的项目,GraphQL查询会同等看成单个项目或者一个列表项目 传递参数:1234567&#123; human(id: "1000")&#123; id name height &#125;&#125; 返回结果:123456789&#123; "data": &#123; "human": &#123; "id": "1000", "name": "Luke Skywalker", "height": 1.72 &#125; &#125;&#125; 每一个字段和嵌套对象都能有自己的一组参数,从而使得GraphQL可以替代多次API请求.可以给标量(scalar)字段传递参数,用于实现服务端的一次转换1234567&#123; human(id: "1000")&#123; name #传入参数把单位转换为英尺 height(unit: FOOT) &#125;&#125; 12345678&#123; "data": &#123; "human": &#123; "name": "Luke Skywalker", "height": 5.6430448 &#125; &#125;&#125; 别名:通过设置别名可以通过不同参数查询相同字段12345678&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125; 12345678910&#123; "data": &#123; "empireHero": &#123; "name": "Luke Skywalker" &#125;, "jediHero": &#123; "name": "R2-D2" &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>PHP</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
</search>
