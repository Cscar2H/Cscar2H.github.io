<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[权限管理系统-rbac]]></title>
    <url>%2F2019%2F05%2F29%2Frbac%2F</url>
    <content type="text"><![CDATA[1.事先为用户分配角色,为角色分配权限.2.用户访问资源,检查当前用户是否有权限访问对应的资源.3.公共资源不需要权限.使用注解来描述是否要权限,要什么权限才能访问.注解称为元数据,用来描述数据的数据,可以对类,方法,字段,做描述.部门模块,员工模块,角色模块,权限模块.]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>综合</tag>
        <tag>权限</tag>
        <tag>crud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的ajax]]></title>
    <url>%2F2019%2F05%2F26%2FjQuery%E7%9A%84ajax%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2019%2F05%2F25%2FJSON%2F</url>
    <content type="text"><![CDATA[JSON是一种轻量级的数据交换格式语法格式:1234[ &#123;“名称1” : 值, “名称2” : 值2&#125;, &#123;“名称1” : 值, ”名称2“ : 值2&#125;] JSON字符串和JS对象之间转换1JSON.parse(jsonStr)//json字符串转JS对象 1JSON.stringify(obj)//js对象转JSON字符串 JSON库Jackson:在 SpringMVC 中内置的一个转换 JSON 的插件,速度也挺快,稳定性比较好.Fastjson:阿里出品,号称是 Java 领域中转换 JSON 最快的一个插件,中文文档比较齐全.用起来比较友好的 Java 对象 JSON 字符串 java对象转json字符串1new ObjectMapper().writeValueAsString(java对象) json字符串转java对象12objectMapper.readValue(objectMapper.writeValueAsString(emps), objectMapper.getTypeFactory().constructParametricType(ArrayList.class, Employee.class)) java对象转json字符串1JSON.toJSON(java对象); json字符串转java对象12JSON.parseObject();JSON.parseArray(); jackson标签手动处理:把对象封装成map(键值对)再调用封装的方法.标签:@JsonIgnore : 忽略该字段.@JsonProperty(“xxx”) : 对象转换json时换一个名字@JsonFormat(pattern = “yyyy-MM-dd”,timezone=”GMT+8”)]]></content>
      <categories>
        <category>JSON</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>JS</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX和jQuery]]></title>
    <url>%2F2019%2F05%2F23%2FAJAX%E5%92%8CjQuery%2F</url>
    <content type="text"><![CDATA[AJAX:AJAX是Javascript,XHTML,CSS 和 DOM,XML,XMLHttpRequest的综合应用.AJAX核心是在JavaScript中调用 XMLHttpRequest 类,用这个特殊的JavaScript对象发送请求和接收响应.XMLHttpRequest也被称为AJAX对象. AJAX作用: 客户端于服务器进行异步交互. 网页内容的局部更新.缺陷: 浏览器的兼容性; 网页后退功能失效; 对流媒体支持不好; AJAX不支持跨域访问,不做特殊处理只能请求同源的资源; jQuery:jQuery是一个JavaScript框架.JS库,兼容CSS3作用: 操作文档对象,选择DOM元素,制作动画效果,事件处理,使用AJAX以及其他功能. jQuery引入1&lt;script type="text/javascript" src="../static/jquery-2.1.4.js"&gt;&lt;/script&gt; 验证引入123&lt;script type="text/javascript"&gt; alert($);&lt;/script&gt; jQuery体验12345678910111213141516171819window.onload = function () &#123; var btn = document.getElementById("btn"); btn.onclick = function () &#123; var div = document.getElementById("div"); if (div.style.display) &#123; div.style.display = ""; &#125; else &#123; div.style.display = "none"; &#125; &#125;&#125;;$(function () &#123; $("#btn_jq").click(function () &#123; $("#div_jq").toggle(1000); &#125;)&#125;); jQuery对象通过 document.getElementById() 找到的元素和通过 $() 找不到元素不一样.通过jQuery方法获取的页面元素,都是jQuery对象.jQuery对象其实就是对DOM对象进行了包装,增强了相关的方法.虽然jQuery对象包装了DOM对象,但是两种不能混用. $ 表示 jQuery对象. $===jQuery. DOM对象—&gt;jQuery对象1$(DOM对象) jQuery对象—&gt;DOM对象1$btn.get(o) jQuery常用方法.size() / .length: 获取jQuery中包含DOM个数.val : 获取元素的value属性值..val(‘xxx’) : 设置value属性值..html() : 获取所有标签中的内容..text : 获取所有标签中的文本内容..css : 设置样式. 基本选择器id : 返回值单个元素的组成的集合.1$("mydiv") element : 返回值元素集合1$("div") class : 返回值元素集合1$(".myClass") : 返回值元素集合1$("*") selector1, selector2, selectorN : 返回值元素集合1$("div,span,p,myClass") 层次选择器ancestor descendan 祖先 后代1$("form input"); //返回值元素集合 parent &gt; child 父亲 &gt; 儿子1$("form &gt; input"); // 返回值元素集合 prev + next 兄 + 二弟1$("label + input"); //返回值元素集合 prev ~ siblings 兄 + 所有弟弟1$("form ~ input"); 过滤选择器1$("初步过滤:准确过滤"); jQuery事件绑定mouseover + mouseout = hover DOM操作-内部插入1234567父.append(子);子.appendTO(父)父.prepend(子-&gt;带哥)(子-&gt;带哥).prependTO(父); DOM操作-外部插入1234567891011//在div后面插入span$('#div').after($('#span'));//在div前面插入span$('#div').before($('#span'));//将span插入到div后面$('#span').insertAfter($('#div'))//将span插入到div前面$('#span').insertBefore($('#div')) DOM操作-删除12345678//删除id为ul的所有子元素$('#ul').empty();//detach删除之后元素绑定事件跟数据不会被删除$('#btn').detach();//remove删除之后元素绑定事件跟数据会删除$('#btn').remove(); DOM操作-复制和替换123456//克隆id为btn的元素$('#btn').clone(true);//替换 $(源).replaceWith(目标)$('input').replaceWith('&lt;p&gt;123&lt;p&gt;')//(目标).replaceAll$(源)$('&lt;p&gt;123&lt;p&gt;').replaceAll($('input')) 获取和设置属性获取:1$('#li').attr('value') 设置:123$('li').attr('value',function(index,item)&#123; return item + '_' + index;&#125;) 样式操作为元素添加样式1$(':button').addClass('Mybtn') 删除元素样式1removeClass 判断某个样式1toggleClass 判断是否有某个样式1hasClass]]></content>
      <categories>
        <category>AJAX</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合总结]]></title>
    <url>%2F2019%2F05%2F21%2FSSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Spring作用:通过使用Spring提供的IoC容器,可以将对象之间的依赖关系交给Spring进行控制.方便解耦,简化开发. IoCIoC容器:BeanFactory 是 Spring 最底层的接口.只提供了的 IoC 功能,负责创建、组装、管理 bean.在应用中,一般不使用 BeanFactory,而推荐使用 ApplicationContextBeanFactory:需要等到获取某一个bean的时候才会创建该beanApplicationContext:在启动Spring容器的时候就会创建所有的bean,ApplicationContext接口继承了 BeanFactory.除此之外还提供 AOP 集成、国际化处理、事件传播、统 一资源价值等功能. IoC:控制反转.把创建对象的控制权交给Spring来管理,只需要描述对象如何被创建(在配置文件描述),之后一个容器(IoC容器)负责把他们组装起来 Bean的作用域指其创建的 Bean 对象相对于其他 Bean 对象的请求可见范围.Singleton - 单例,缺省值.在 Spring IoC 容器中仅存在一个 Bean 实例,在开发中主要使用scope=”singleton”.Prototype - 多例,每次从容器中调用 Bean 时,都返回一个新的实例. Request - 每一次 HTTP 请求都会产生一个新的实例,并且该 bean 仅在当前 HTTP 请求内有效.Session - 每一次 HTTP 请求都会产生一个新的 bean,同时该 bean 仅在当前 HTTP session 内有效.Global-session - 类似于标准的 HTTP Session 作用域,不过它仅仅在基于 portlet 的 web 应用中才有意义.Portlet 规范定义了全局 Session 的概念,它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享.在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内.如果你在 web 中使用 global session 作用域来标识 bean,那么 web 会自动当成 session 类型来使用. Bean的初始化和销毁init-method和destroy-method,一般用于连接池的初始化和销毁(关闭资源). DIDI注入:为IoC容器创建对象的时候,设置相关的属性值.IoC是开发目的,DI是实现的手段.注入方式有两种:setter方法注入构造器注入注入值的类型:常量值(简单类型) : value元素对象(复合类型) : ref 元素集合 : 对应集合类型元素 AOP代理模式的定义:为其他对象提供一种代理以控制对这个对象的访问.代理模式的特点:代理对象完全包含真实对象,客户端使用的都是代理对象的方法,和真实对象没有关系.代理模式的职责:把不是真实对象该做的事情从真实对象上撇开,职责清晰. 实现动态代理:针对有接口:使用JDK动态代理.针对无接口:使用CGLIB或Javassist组件 动态代理原理:调用代理对象方法,在代理对象中插入增强代码.通过invoke方法,去调用真实对象中的真实方法,实现业务功能. AOP思想:AOP 把多个业务方法需要调用的代码封装到不同的模块中去(责任分离思想),使用动态代理机制来动态的增强业务功能,从而达到了代码的复用,也提高了维护性. Joinpoint:通过在连接点插入代码,从而增强功能.Pointcut(切点) : 指定哪些类的哪些方法上织入横切逻辑Advice(增强) : 描述横切逻辑和方法的具体织入点Advisor(切面) : 将Pointcut和Advice两者组装起来,有了Advisor信息,Spring就可以利用JDK/CGLIB动态代理技术采用统一的方式为目标Bean创建织入切面的代理对象. 增强时机:aop:before(前置增强): 在方法执行之前增强aop:after-returning(后置增强): 在方法正常执行完成之后执行增强aop:throwing(异常增强): 在方法抛出异常退出时执行增强aop:after(最终增强): 在方法执行之后执行,相当于在finally里执行aop:around(环绕增强): 可以在方法调用前/后完成自定义增强 事务管理并发会导致以下问题:第一类丢失更新:两个事务更新相同的数据,如果一个事务提交,另一个事务回滚,第一个事务也会回滚脏读:第二个事务查询到第一个事务未提交的数据,第一个事务根据该数据进行操作,但是第一个事务却回滚了…虚读:一个事务查询到另一个事务已经提交的数据,导致多次查询数据不一致.不可重复读:一个事务查询到另一个事务已经修改的数据,导致多次查询不一致第二类丢失更新:多个事务同时读取相同的数据,并且完成各种对该数据的操作提交,会导致最后一次的提交覆盖前面所有对数据的修改. READ UNCOMMITED &lt; READ COMMITED &lt; REPEATABLE READ &lt; SERIALIZABLEOracle 支持 READ COMMITED(缺省)和 SERIALIZABLEMySQL 支持 四种隔离级别,缺省为 REPEATABLE READ(可重复读) 事务类型:本地事务,分布式事务,JDBC 事务,JTA 事务编程式事务:通过编写代码来管理事务声明式事务:通过 注解 或 XML 配置来管理事务 Spring MVC]]></content>
      <categories>
        <category>Spring MVC</category>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript语法]]></title>
    <url>%2F2019%2F05%2F20%2FJavaScript%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScriptjs是一种直译式脚本语言,动态类型,弱类型,基于原型的语言.解释器被称为JavaScript引擎,为浏览器的一部分. 组成ECMAScript(核心):JavaScript 语言基础DOM(文档对象模型):规定了访问 HTML 和 XML 的接口BOM:(浏览器对象模型) 变量声明变量:使用关键字 var.如果变量没有初始化,默认是 undefined不事先声明变量而直接使用会报错 打印变量:方式一:alert(变量名);方式二:console.log(变量名): (info,log,debug,warm,error) 基本类型和常量1.整数常量(10进制8进制16进制)十六进制以 0x 或 0X 开头，例:0x8a八进制必须以 0 开头 例如:0123十进制的第一位不能是 0 (数字0除外) 2.实数常量12.32、193.98、 5E7、4e5等.特殊数值:NaN、Infinity (除数为零),所对应的判断函数 isNaN()、isFinite() 3.typeof 运算符 typeof 判断变量的数据类型var msg=’hello’;console.log(typeof msg );msg=18;console.log(typeof msg ); 运算符比较运算符:= 和 == 以及 === 之间的区别：= 赋值运算符：用于把一个常量/变量的值赋值给另外一个变量== 比较运算符：用于比较两个数据的值是否相等，不会去判断类型 console.log(“18” == 18 );=== 比较运算符：先判断数据类型是否相等，然后在去判断值是否相等 console.log(“18” === 18); 逻辑运算符在逻辑运算中 0、””、false、NaN、undefined、null 表示为 false,其他类型数据都表示 trueNaN:not a number a &amp;&amp; b 将 a, b 先转换为 Boolean 类型,在执行逻辑与,若 a 为 false,则返回 a,否则就返回 b; a || b 将 a, b 先转换为 Boolean 类型,再执行逻辑或,若 a 为 true,则返回 a,否则就返回 b; 函数作用:写在函数里面的js代码,只需要定义一次,就可以多次调用定义普通函数:1234function 函数名([参数名称1, 参数名称2, ..., 参数名称N]) &#123; //程序代码 [return 值;]&#125; 无参数无返回,有参数无返回,有参数有返回.如果函数没有返回值,就默认返回 undefined 定义匿名函数:123var add = function(x, y)&#123; return x+y;&#125; 给函数一个固定的名称,我们称之为函数名,把匿名函数当成一个普通的值来理解 全局变量和局部变量全局变量:function外部定义的变量就是全局变量.局部变量:function内部定义使用var声明的变量就是局部变量.访问变量的原则:就近原则.变量声明会提前 全局函数encodeURI 及 encodeURIComponent 方法:返回对一个 URI 字符串编码后的结果.decodeURI 及 decodeURIComponent() 方法:将一个已编码的 URI 字符串解码成最初始的字符串并返回。. parseInt 方法 : 将一个字符串转换成对应的整数(尽可能多地转换) parseFloat 方法 : 将一个字符串转换成对应的小数(尽可能多地转换) eval 方法 : 将参数字符串作为一个 JavaScript 表达式执行. 面向对象对象的属性和方法统一的被称为成员对象的构造函数(函数首字母大写,以区分普通函数)语法格式:1var objInstance=new ObjName([实际参数列表]); 可以动态给对象添加属性 this关键字:在构造函数中,this指新创建的对象:在普通的函数/方法中,谁调用this所在的函数/方法,this就指向谁. 参数传值基本类型:传递的是值的拷贝引用类型:传递的是内存地址的拷贝. 内置对象1.Object创建对象,并设置属性和方法12345678910var obj = new Object();obj.name = "xxx";obj.age = 18;obj.sayHello = function()&#123;&#125;;//对象的构造函数alert(obj.constructor);//是否有指定的属性```jsconsole.log(obj.hasOwnProperty("name1")); 2.Date打印当前系统时间12var d = new Date();var time = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate() + " " + d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds(); 3.Math123var num = Math.random();//随机[0.0,1.0)//随机生成[0,25)//随机生成[65,91] 数组定义方式一:创建数组对象1var arr = new Array(); 方式二:类似数组中的静态初始化12var arr2 = new Array("西施","王昭君","貂蝉","杨贵妃");var arr2 = new Array(1, 2, 3, 4) --&gt; arr2=new Array(2); 方式三:类似数组的动态初始化1var arr3 = new Array(4); 方式四:1var arr4 = ["西施","王昭君","貂蝉","杨贵妃"]; 注意:对于js中的数组不会出现数组越界的异常,也不是定长的. 数组的属性和方法1.属性length属性,获取数组长度 2.方法连接两个或更多的数组,并返回结果1concat(array1, array2, ......, arrayX); 把数组的所有元素放入一个字符串.元素通过指定的分隔符进行分隔1join(separator); 颠倒数组中元素的顺序（该方法会改变原来的数组,而不会创建新的数组)1reverse(); 从某个已有的数组返回选定的元素(返回的是一个新数组)1slice(start[, end]); 删除并返回数组的最后一个元素1pop(); 删除并返回数组的第一个元素1shift(); 向数组的末尾添加一个或更多元素，并返回新的长度1push(newelement1, newelement2, ...., newelementX); 向数组的开头添加一个或更多元素,并返回新的长度1unshift(newelement1, newelement2, ...., newelementX); 用于插入、删除或替换数组的元素1splice(index, howmany, element1, ....., elementX); 数组遍历1.普通遍历123for (var i = 0; i &lt; arr.length; i++)&#123; console.log(arr[i]);&#125; 2.forEach123arr.forEach(function (value) &#123; console.log(value);&#125;) 3.for-in123456789for(var i in arr) &#123; console.log(arr[i]);&#125;var obj = &#123;name:"小强",age:'18'&#125;;for(var p in obj)&#123; console.log(obj.p); console.log(obj[p]);&#125; 4.map123arr.map(function(ele,index,arr)&#123; return ele+10;&#125;) BOMBOM:浏览器对象模型 消息框,输入框,对话框123456789101112console.log(window.location);console.log(location);window.alert(1);var v = window.prompt('蛤蛤','嘟嘟');var v2 = prompt('你是','蛤蛤');console.log(v);//嘟嘟console.log(v2);//蛤蛤var v3 = confirm("傻逼?");console.log(v3)//true 定时器第一种:只会执行一次,指定时间后,执行某一个操作.第二种:周期性执行,间隔多少时间后,周期性执行某一个操作.setTimeout(fn, time)函数,返回 timer,用于指定一段时间后执行某函数setInterval(fn, time)函数,返回 timer,用于周期性执行某函数. 参数 fn可以是字符串组成的 Javascript 代码,也可以是一个函数名称. 参数 time 表示时间,毫秒为单位. clearTimeout(timer) 函数清,除由 setTimeout 创建的定时器.clearInterval(timer) 函数,清除由 setInterval 指定的定时器. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript"&gt; var timer = setInterval(function () &#123; var spanEle = document.getElementById('time'); var time = spanEle.innerHTML; if (time &gt; 0) &#123; spanEle.innerHTML = time - 1; &#125; if (time == 0) &#123; location.href = 'http://cscar.me'; clearInterval(timer) &#125; &#125;,1000);&lt;/script&gt;&lt;body&gt;&lt;span id="time"&gt;5&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; DOM定义DOM是文档对象模型的缩写.DOM是一种于浏览器,平台,语言无关的接口,可动态的修改XML和HTML. HTML DOMDOM是将HTML文档表达为树结构,定义了访问和操作HTML文档的标准方法.DOM树:节点(node)的层次,文档节点(document),元素节点,属性节点,文本节点.DOM把一个文档表示为一颗家谱树. 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt; &lt;script type="text/javascript"&gt; console.log(window.navigator); console.log(window.document.images); console.log(window.document.links); console.log(window.document.forms); &lt;/script&gt;&lt;body&gt; &lt;a href=""&gt;a1&lt;/a&gt; &lt;a href=""&gt;a2&lt;/a&gt; &lt;form id="form1"&gt;&lt;/form&gt; &lt;form id="form2"&gt;&lt;/form&gt; &lt;img src=""/&gt; &lt;img src=""/&gt;&lt;/body&gt;&lt;/html&gt; DOM获取元素的三种方式1.通过元素id:1getElementById 返回拥有指定id的第一个元素,如果不存在则返回null.2.通过标签名字1getElementsByTagName 返回一个包含所有给定标签名称的元素,如果没有匹配的元素,返回一个空集.3.通过class名字1getElementsByClassName 返回一个包含所有指定class名称的元素集合,可以在任意元素上调用该方法. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .b &#123; color: pink; &#125;&lt;/style&gt;&lt;script&gt; window.onload = function () &#123; var spanEle = document.getElementById("span1"); console.log(spanEle); var span = document.getElementsByTagName("span"); console.log(span[1]); var classEle = document.getElementsByClassName("b"); console.log(classEle[2]) &#125;&lt;/script&gt;&lt;body&gt;&lt;span id="span1" class="b"&gt;你好&lt;/span&gt;&lt;span id="span2" class="b"&gt;你好&lt;/span&gt;&lt;div id="div1" class="b"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Node对象的属性和方法1234567891011window.onload = function () &#123; var divEle = document.getElementById("div1"); console.log(divEle.firstChild); console.log(divEle.lastChild); console.log(divEle.childNodes); var span2Ele = document.getElementById("span2"); console.log(span2Ele.parentNode); console.log(span2Ele.previousSibling); console.log(span2Ele.nextSibling); &#125; 元素节点的属性操作元素上的标准属性和自定义属性操作1.操作标准属性获取属性值元素对象[“属性名”]元素对象.属性名元素对象.setAttribute(“属性名”, 值) 2.操作自定义属性获取属性值:元素对象.getAttribute(“属性名”) 设置属性值:元素对象.setAttribute(“属性”,值) 其他特殊属性操作1.操作属性名和默认属性值相同的属性,如: checked, selected元素对象.checked = true | false2.操作 class 属性元素对象.className = xxx,原因:class是js中的关键字3.操作style的属性,如:background-color4.操作readonly属性元素对象.readOnly=true | false1234567891011121314151617181920212223242526window.onload = function () &#123; var inputEle = document.getElementById("username"); console.log(inputEle.type); console.log(inputEle['type']); console.log(inputEle.getAttribute('type')); //inputEle['value'] = "中米"; //inputEle.value="大米"; inputEle.setAttribute('value', '黑米'); inputEle.setAttribute('xx', '嘟嘟'); console.log(inputEle.getAttribute('xx')); console.log(inputEle.className); inputEle.className = 'a'; console.log(inputEle.className); var inputEle2 = document.getElementById("admin"); console.log(inputEle2.checked); console.log(inputEle2.readOnly); console.log(inputEle2.style.backgroundColor); inputEle2.style.backgroundColor = "green"; console.log(inputEle2.style.backgroundColor); &#125; 元素节点的常用方法 事件处理事件驱动编程事件源:发出事件通知,发出消息,也是事件主体事件名称:发出什么样的通知的名称.事件响应函数,当这个事件发生时,执行操作.事件对象:一般来说,当事件发生时,会产生一个描述该事件的具体对象. 123456789101112131415161718192021222324//方式1function func(srcEle, event) &#123; console.log(srcEle); console.log(event);&#125;window.onload = function () &#123; //方式2 var btn2 = document.getElementById("btn2"); btn2.onclick = function (ev) &#123; console.log(ev); alert(111); &#125;; //方式3 var btn3 = document.getElementById("btn3"); btn3.addEventListener('click',function (ev) &#123; console.log(ev); alert(222); &#125;); btn3.addEventListener('click',function (ev) &#123; alert(333); &#125;)&#125; 事件相关鼠标事件123456789window.onload = function () &#123; var imgEle = document.getElementById("man"); imgEle.onmouseover = function () &#123; imgEle.src = "../image/man2.png"; &#125;; imgEle.onmouseout = function () &#123; imgEle.src = "../image/man.png"; &#125;; &#125; 原生JS事件绑定使用原生的加载事件,后面的会覆盖前面的.使用jQuery则不会.12345678910111213window.onload=function () &#123; alert(111);&#125;;window.onload=function () &#123; alert(222);&#125;;$(function () &#123; alert(111);&#125;);$(function () &#123; alert(222);&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM综合]]></title>
    <url>%2F2019%2F05%2F17%2FSSM%E7%BB%BC%E5%90%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[spring请求和响应]]></title>
    <url>%2F2019%2F05%2F16%2Fspring%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[spring注解归类]]></title>
    <url>%2F2019%2F05%2F15%2Fspring%E6%B3%A8%E8%A7%A3%E5%BD%92%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[IoC注解:XML:1&lt;ben id="" class=""/&gt; 作用:被贴的类,交给spring管理(会被创建对象,存储在spring容器中) 注解:(四个作用一样)Repository : 一般贴DAO类Service : 一般贴Service类Controller : 一般贴Controller类Component : 非上述三种类型的类 解析器:1&lt;context:component-scan basePackage="me.cscar.ssm"&gt; xml:1&lt;bean id="someBean" class="...SomeBean" scope="singleton" init-method="open" destory-method="close"/&gt; 1234567891011@Component("someBean")@Scope("singleton")class SomeBean&#123; @PostConstruct public void open()&#123;&#125; @PreDestory public void close()&#123;&#125; &#125; DI注解:作用:从容器中找到指定的bean对象,并设置给该字段. 注解:AutowiredResource二者功能一样 解析器:1&lt;context:annotation-config/&gt; xml:12345&lt;bean id="otherBean" class="..OtherBean"&gt;&lt;bean id="someBean" class="..SomeBean"&gt; &lt;property name="other" ref="otherBean"/&gt;&lt;/bean&gt; 12345678@Componentclass OtherBean&#123;&#125; @Component class SomeBean&#123; @Autowired private OtherBean other; &#125; Tx注解:作用:增加Service组件支持事务管理 注解:Transactional 解析器:1&lt;tx:annotation-driven transaction-manager="txManager"/&gt; xml配置配置事务管理器(what)123&lt;bean id="txManager" class="...DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt; 配置事务增强(配置事务方法的属性 when)12345678&lt;tx:advice id="txAdvice" tansaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;tx:method name="list*" read-only="true"/&gt; &lt;tx:method name="query*" read-only="true"/&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 配置切入点(where)1234&lt;aop:config&gt; &lt;aop:pointcut expression="execution(* com.huawei.xx.service.*Service.*(..))" id="txPointcut"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/&gt;&lt;/aop:config&gt; 注解操作:1:what:配置事务管理器123&lt;bean id="txManager" class"...DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt; 2:增加解析器1&lt;tx:annotation-driven transaction-manager="txManager"/&gt; 3:到service实现类上,使用Transactional注解 MVC注解:注解:Controller : 声明当前类为控制器,spring容器创建对象RequestMapping : 贴在方法上,表示访问当前方法的URL. 使用:12345678@Controller@RequestMapping("/hello")public class HelloController&#123; @RequestMapping("/say") public ModelAndView sayHello()&#123; return null; &#125;&#125; 此时的访问规则: http://localhost:8080/hello/say AOP注解:12345class LogAdvice&#123; public void writeLog()&#123; sout("记录日志...") &#125;&#125; XML:1234567891011&lt;!--what:--&gt;&lt;bean id="logAdvice" class="..LogAdvice"&gt;&lt;aop:config&gt; &lt;aop:aspect ref="logAdvice"&gt; &lt;!--where:--&gt; &lt;aop:pointcut expression="execution(* cn.wolfcode.ssm.*Service.*(..))" id="logPointcut"/&gt; &lt;!--when:--&gt; &lt;aop:before method="writeLog" pointcut-ref="logPointcut"/&gt; &lt;/aop:aspect&gt;&lt;aop:config&gt; 使用注解:注解: Aspect 贴在增强类之上,表示一个切面 Pointcut 编写切入点表达式 Before 前置增强 AfterReturning AfterThrowing After Around 解析器1234&lt;!-- 解析Component --&gt;&lt;context:component-scan basePackage="cn.wolfcde.ssm"/&gt;&lt;!--AOP注解解析器--&gt;&lt;aop:aspectj-autoproxy/&gt; 使用123456789101112@Component@Aspectclass LogAdvice&#123; @Pointcut("execution(* cn.wolfcode.ssm.*Service.*(..))") public void logPointcut()&#123;&#125; @Before("logPointcut()") public void writeLog()&#123; sysou("记录日志...") &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC]]></title>
    <url>%2F2019%2F05%2F14%2FspringMVC%2F</url>
    <content type="text"><![CDATA[MVC原理model(模型) : 数据模型,包含要展示的数据和业务功能.view(视图) : 用户界面,在界面上显示模型数据controller(控制器) : 起调度作用,接收用户请求,调用业务处理请求,共享数据模型并跳转界面. 在web开发中的模型是无法主动推给视图(无法主动更新用户界面),因为在web开发是请求-响应模型 前端控制器(controller)所有的请求都被发往该控制器统一处理,然后把请求分发给各自相应的处理程序. MVC框架都有前端控制器,在web开发中必须在web.xml中配置前端控制器,一般的要么是Filter,要么是Servlet.springMVC基于Servlet MVC流程图 涉及组件 springMVCspringMVC和spring WebFluxspring WebFlux是基于异步非阻塞springMVC是同步阻塞的IO模型 使用注解开发控制层(mvc) @Controller业务逻辑层(service) @Service数据持久层(DAO) @Resposotory其他组件使用通用注解 @Component java代码: xml配置: requestMapping注解 静态资源访问]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解开发]]></title>
    <url>%2F2019%2F05%2F14%2Fspring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[DI注解Autowired 注解和 Resource 注解:共同点:1.可以自动的把属性需要的对象找出来,并自动注入2.可以贴在字段或者 setter 方法上面,一般贴在字段上(不再需要 setter 方法)3.可以注入一些 Spring 内置的重要对象,甚至是 Servlet 的 API 比如 BeanFactory、 ApplicationContext、ServletContext 等不同点:1.Autowired 和 Resource 注解都必须要能找到对应的对象,否则报错.只是 Autowired 注解可以通过 required=false 来避免这个问题:@Autowired(required=false)2.Autowired:先按照类型找,找不到再按名字去找,可以配合@Qualifier 注解一起使用.Resource:先按照名字找,找不到再按类型找.@Resource(name=””) 开发中建议必须配置1&lt;context:annotation-config /&gt; 使用 Autowired 注解12345public class SomeBean &#123; @Autowired @Qualifier("otherBean") private OtherBean other;&#125; 使用 Resource 注解1234public class SomeBean &#123; @Resource(name=”otherBean”) private OtherBean other;&#125; Value 注解Autowired 和 Resource 注解用于注入对象,Value 注解用于注入常量数据(简单类型数据)server.properties 文件12server.port=8888server.path=/ Java 代码12@Value("$&#123;server.port&#125;")private int port; 引入配置文件1&lt;context:property-placeholder location="classpath:db.properties,classpath:server.properties"/&gt; 或者1234&lt;context:property-placeholder location="classpath:db.properties" ignore-unresolvable="true"/&gt;&lt;context:property-placeholder location="classpath:server.properties" ignore-unresolvable="true"/&gt; IoC 注解不同组件的注解bean 组件版型:组件的功能是相同的,只是用于标注不同类型的组件 @Repository 用于标注数据访问组件,即 DAO 组件.@Service 用于标注业务层组件,即 Service 组件.@Controller 只用于标注控制层组件(SpringMVC 的 Controller).@Component 泛指组件,当组件不好归类的时候,我们可以使用这个注解进行标注 此时需要配置 IoC 注解的解析器1&lt;context:component-scan base-package=""/&gt;表示去哪些包中及其子包中去扫描组件注解 Java 代码(同时实现 IoC 和 DI 配置)123456789@Component("otherBean") public class OtherBean &#123;&#125;@Componentpublic class SomeBean &#123; @Autowired private OtherBean other;&#125; xml配置1234&lt;!-- DI 注解解释器 --&gt;&lt;context:annotation-config/&gt;&lt;!-- IoC 注解解释器 --&gt;&lt;context:component-scan base-package="me.cscar.ssm"/&gt; 作用域注解XML配置1&lt;bean id="otherBean" class="...OtherBean" scope="singleton"/&gt; 使用:使用 Scope 注解，设置 Bean 的作用域12345@Component@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)public class OtherBean &#123;&#125; 初始化和销毁注解使用 XML 方式的配置 bean 的初始化和销毁方法1234&lt;bean id="someBean" class="...SomeBean" init-method="open" destroy-method="close"/&gt; @PostConstruct 用于贴在初始化方法上@PreDestroy 用于贴在销毁方法上12345678@PostConstructpublic void open() &#123; System.out.println("初始化方法"); &#125;@PreDestroypublic void close() &#123; System.out.println("销毁方法"); &#125; AOP 注解使用 XML 方式的配置 AOP(基于 JDK 动态代理)xml配置:一定要先开启 AOP 注解的解释器12345&lt;!-- IoC 注解解释器 --&gt;&lt;context:component-scan base-package="cn.wolfcode.ssm" /&gt; &lt;!-- DI 注解解释器 --&gt;&lt;context:annotation-config /&gt;&lt;!-- AOP 注解解释器 --&gt;&lt;aop:aspectj-autoproxy /&gt; Aspect : 声明一个切面,贴在增强类之上Pointcut : 贴到一个方法上,用于声明 pointcut 语法,被贴方法的名字作为 pointcut 语法 idBefore : 贴到需要做前置增强的方法上After : 贴到需要做后置增强的方法上AfterThroing : 贴到需要做异常增强的方法上AfterReturing : 贴到需要做最终增强的方法上Around : 贴到需要做环绕增强的方法上 Java 代码:123456789101112131415161718192021222324252627282930313233343536373839404142@Component@Aspectpublic class TransctionManager &#123; @Pointcut("execution(* cn.wolfcode.ssm.service.*Service.*(..))") public void txPoint() &#123; &#125; @org.aspectj.lang.annotation.Before("txPoint()") public void begin(JoinPoint jp) &#123; System.out.println("开启事务"); &#125; @org.aspectj.lang.annotation.AfterReturning("txPoint()") public void commit() &#123; System.out.println("提交事务"); &#125; @org.aspectj.lang.annotation.After("txPoint()") public void close() &#123; System.out.println("释放资源"); &#125; @org.aspectj.lang.annotation.AfterThrowing(value = "txPoint()", throwing = "ex") public void rollback(Throwable ex) &#123; System.out.println("回滚事务" + ex); &#125; @org.aspectj.lang.annotation.Around(value = "txPoint()") public Object around(ProceedingJoinPoint pjp) &#123; Object ret = null; System.out.println("开启事务"); try &#123; //执行目标方法 ret = pjp.proceed(); System.out.println("提交事务"); &#125; catch (Throwable ex) &#123; System.out.println("回滚事务"); &#125; finally &#123; System.out.println("释放资源"); &#125; return ret; &#125;&#125; 默认使用的 JDK 动态代理方式,可以设置使用 CGLIB 方式XML 配置:1&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 修改切入点表达式123@Pointcut("execution(* me.cscar.ssm.service..*(..))")public void txPoint() &#123;&#125; Tx注解1234567&lt;tx:advice id="crudAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;!-- service 中查询方法 --&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;tx:method name="list*" read-only="true"/&gt; &lt;tx:method name="query*" read-only="true"/&gt; &lt;!-- service 中其他方法 --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 具体使用贴在类上:该类中所有的方法,都使用 Transactional 注解的属性配置贴在方法上:只针对被贴的这一个方法,一般用于做单独配置.一般的,我们可以在业务类上直接贴该注解,并在查询方法上设置 readOnly 属性为 true.注意:一定要记得开启 Tx 注解的解释器 使用JDK12345678910111213&lt;!-- IoC 注解解析器 --&gt;&lt;context:annotation-config /&gt;&lt;!-- DI 注解解析器 --&gt;&lt;context:component-scan base-package="cn.wolfcode.ssm" /&gt; &lt;!-- TX 注解解析器 --&gt;&lt;tx:annotation-driven transaction-manager="txManager" /&gt;&lt;!-- 配置 JDBC 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;........... 使用 CGLIB1&lt;tx:annotation-driven transaction-manager="txManager" proxy-target-class="true"/&gt; java代码1234567891011@Service@Transactionalpublic class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDAO dao; public void trans(Long outId, Long inId, int money) &#123; dao.transOut(outId, money); int a = 1 / 0; dao.transIn(inId, money); &#125; &#125;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring事务管理]]></title>
    <url>%2F2019%2F05%2F14%2Fspring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Spring 事务管理事务的操作:1.原子性(Atomicity):事务是不可分割的最小工作单元,事务内的操作要么全做,要么全不做. 2.一致性(Consistency):在事务执行前数据库的数据处于正确的状态,而事务执行完成后数据库的数据依然处于正确的状态,即数据完整性约束没有被破坏,如 A 给 B 转账,不论转账成功与否转账之后 的 A 和 B 的账户总额和转账之前是相同的. 3.隔离性(Isolation):当多个事务处于并发访问同一个数据库资源时,事务之间相互影响程度,不同的隔离级别决定了各个事务对数据资源访问的不同行为. 4.持久性(Durability):事务一旦执行成功它,对数据库的数据的改变是不可逆的. Spring 的事务管理主要包括 3 个接口:1.PlatformTransactionManager:根据 TransactionDefinition 提供的事务属性配置信息,创建事务. 2.ransactionDefinition:封装事务的隔离级别和超时时间,是否为只读事务和事务的隔离级别和传播规则等事务属性. 3.TransactionStatus:封装了事务的具体运行状态.如是否是新开启事务,是否已经提交事务,设置当前事务为 rollback-only 等. PlatformTransactionManager:1:TransactionStatus getTransaction(TransactionDefinition definition):根据事务定义信息从事务环境中返回一个已存在的事务,或者创建一个新的事务.2:void commit(TransactionStatus status):根据事务的状态提交事务,如果事务状态已经标识为rollback-only,该方法执行回滚事务的操作.3:void rollback(TransactionStatus status):将事务回滚,当 commit 方法抛出异常时,rollback 会被隐式调用 TransactionDefinition:封装事务的隔离级别和超时时间,是否为只读事务和事务的隔离级别和传播规则等事务属性 TransactionStatus:封装了事务的具体运行状态.如是否是新开启事务,是否已经提交事务,设置当前事务为 rollback-only 等. 事务的传播规则spring支持7种传播行为 情况一:遵从当前事务 REQUIRED: 必须存在事务,如果当前存在一个事务,则加入该事务,如果当前没有事务,将新建一个事务 SUPPORTS: 支持当前事务,指如果当前存在事务,就加入到该事务,如果当前没有事务,就以非事务方式执行 MANDATORY: 使用当前事务执行,如果当前没有事务,则抛出异常IllegalTransactionStateException 情况二:不遵从当前事务 REQUIRES_NEW: 不管当前是否存在事务,每次都创建新的事务 NOT_SUPPORTRD: 以非事务方式执行,如果当前存在事务,就把当前事务暂停,以非事务方式执行 NEVER: 不支持事务,如果当前存在是事务,则抛出异常,IllegalTransactionStateException 情况三:寄生事务(外部事务和寄生事务) NESTED :寄生事务,如果当前存在事务,则在内部事务内执行.如果当前不存在事务,则创建一个新的事务(和 REQUIRED 相同). 嵌套事务使用数据库中的保存点(savepoint)来实现,即嵌套事务回滚不影响外部事务,但外部事务回滚将导致嵌套事务回滚.DataSourceTransactionManager 默认支持,而 HibernateTransactionManager 默认不支持, 需要手动开启. 事务方法属性配置 CRUD 通用事务配置1234567&lt;tx:advice id="crudAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;!-- service 中查询方法 --&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;tx:method name="list*" read-only="true"/&gt; &lt;tx:method name="query*" read-only="true"/&gt; &lt;!-- service 中其他方法 --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP]]></title>
    <url>%2F2019%2F05%2F13%2FAOP%2F</url>
    <content type="text"><![CDATA[增强增强(advice):就是在原方法的基础之上,通过插入一段代码从而来增强原方法的功能在 不同时机 插入一段额外代码环绕增强=前置增强+后置增强+异常增强+最终增强 没有AOP导致的问题1.责任不分离:业务方法只需要关系如何完成该业务功能,不用去关心事务管理/日志管理等2.代码结构重复 静态代理代理模式的定义:为其他对象提供一种代理以控制对这个对象的访问特点:1.代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系2.代理模式的职责:把不是真实对象该做的事情从真实对象上撇开——职责清晰 静态代理:在程序运行前就已经存在代理类的字节码文件,代理对象和真实对象的关系在运行之前就确定了. 缺点:该代理类不够通用 动态代理动态代理类是在程序运行期间由JVM通过反射等机制动态生成的,所以不存在代理类的字节码文件,代理对象和真实对象的关系是在程序运行时期才确定的 实现动态代理类:1.针对有接口:使用JDK动态代理2.针对无接口:使用CGLIB或javassist 字节码动态加载 JVM 通过字节码的二进制信息加载类的,如果我们在运行期系统中,遵循 Java 编译系统组织. class 文件的格式和结构,生成相应的二进制数据,然后再把这个二进制数据加载转换成对应的类. java.lang.reflect.Proxy 类:Java 动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法 来为一组接口动态地创建代理类及其对象 JDK 动态代理 主要方法: 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler hanlder) 原理图 通过 newProxyInstance 创建代理类对象,调用hanlder的invoke()方法,底层调用method.invoke()方法.代理类对象和真实类同时实现了实现类的接口. CGLIB 动态代理使用 JDK 的动态代理,只能针对于目标对象存在接口的情况,如果目标对象没有接口,此时可以考虑使用 CGLIB 的动态代理方式.Spring 已经自带了 cglib 库. CGLIB 是通过生成代理类,然后继承于目标类,再对目标类中可以继承的方法做覆盖,并在该方法中做功能增强的,因为多态的关系,通过代理对象调用方法,实则调用的是代理类中的方法 动态代理总结JDK 代理总结:1.JAVA 动态代理是使用 java.lang.reflect 包中的 Proxy 类与 InvocationHandler 接口这两个来完成的.2.要使用 JDK 动态代理,委托必须要定义接口.3.JDK 动态代理将会拦截所有 pubic 的方法(因为只能调用接口中定义的方法),这样即使在接口中增加 了新的方法,不用修改代码也会被拦截.4.动态代理的最小单位是类(所有类中的方法都会被处理),如果只想拦截一部分方法,可以在 invoke 方法 中对要执行的方法名进行判断. CGLIB 代理总结:1.CGLIB 可以生成委托类的子类,并重写父类非 final 修饰符的方法。2.要求类不能是 final 的,要拦截的方法要是非 final、非 static、非 private 的.3.动态代理的最小单位是类(所有类中的方法都会被处理). AOPAOP(Aspect Oritention Programming):把一个个的横切关注点放到某个模块中去,称之为切面.就是把多个业务方法共同调用的某种功能的代码封装到一个类中.切面的目的就是功能增强AOP 把多个业务方法需要调用的代码封装到不同的模块中去(责任分离思想).使用动态代理 机制来动态的增强业务功能,从而达到了代码的复用.也提高了维护性 AOP核心概念where:哪一些方法:一般使用方法的全限定名称来表示when:在方法体执行的什么时机:之前、之后、异常、最终、环绕what:做什么功能的增强:不同的增强功能使用不同的模块或类来封装 Joinpoint:连接点.程序执行过程中的某个特定位置,如类初始化之前/后,方法调用前/后,方法抛出异常后等.这些特定的位置就称之为连接点,通过在连接点插入代码,从而增强功能.相当于切面的增强时机:when.Spring 仅支持的五种连接点(五种增强时机). Pointcut:切入点.开发中,往往不需要对应用中所有的连接点都做增强,切点的作用就是缩小增强的范围,比如哪些包中的哪些类中的哪些方法.相当于切面的在何处增强:where. Advice:增强.拦截到连接点后具体做什么功能,相当于切面的增强什么:what. Aspect:切面.Pointcut+Advice,去哪些方法中+在方法执行的什么时机+做什么增强 Pointcot语法execution(&lt;修饰符&gt;? &lt;返回类型&gt; &lt;声明类型&gt;? &lt;方法名&gt;(&lt;参数&gt;) &lt;异常&gt;?) 切入点表达式中的通配符:*: 匹配任何部分,在包路径中只能表示一个包,不包括子包...: 可用于全限定名中和方法参数中,分别表示子包和 0 到 N 个参数. 应用场景: 增强方法参数配置1.在增强方法中获取异常信息XML 配置:1&lt;aop:after-throwing method="rollback" pointcut-ref="txPoint" throwing="ex" /&gt; 123public void rollback(Throwable ex) &#123; System.out.println("回滚事务" + ex); &#125; 2.获取被增强方法信息，并传递给增强方法Spring AOP 提供 org.aspectj.lang.JoinPoint 类,作为增强方法的第一个参数.1.JoinPoint:提供访问当前被增强方法的真实对象、代理对象、方法参数等数据.2.ProceedingJoinPoint:JinPoint子类,只用于环绕增强中,可以处理被增强方法. 使用 JoinPoint 类:12345678public void begin(JoinPoint jp) &#123; System.out.println("代理对象:"+jp.getThis().getClass()); System.out.println("目标对象:"+jp.getTarget().getClass()); System.out.println("被增强方法参数:"+Arrays.toString(jp.getArgs())); System.out.println("当前连接点签名:"+jp.getSignature()); System.out.println("当前连接点类型:"+jp.getKind()); System.out.println("开启事务");&#125; 使用 ProceedingJoinPoint 类:12345678910111213141516public Object around(ProceedingJoinPoint pjp) &#123; Object ret = null; System.out.println("开启事务"); try &#123; //执行目标方法 ret = pjp.proceed(); System.out.println("提交事务"); &#125; catch (Throwable ex) &#123; System.out.println("回滚事务"); &#125; finally &#123; System.out.println("释放资源"); &#125; return ret; &#125;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合]]></title>
    <url>%2F2019%2F05%2F11%2FSSM%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[集成思路和步骤0.创建项目,添加依赖和插件1.Spring 集成 MyBatis,通过单元测试,保证 CRUD 测试通过2.加入事务控制,通过单元测试,保证后台事务控制测试通过3.Spring 集成 Spring MVC,通过浏览器测试,保证前台 Web 版 CRUD 测试通过 Spring+MyBatis(Spring 配置)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 加载 db.properties 文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" system-properties-mode="NEVER"/&gt; &lt;!-- 创建 DataSource 对象 --&gt; &lt;bean id="myDataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;!-- 创建 SqlSessionFactory 对象 --&gt; &lt;bean id="mySqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--关联 dataSource 对象 --&gt; &lt;property name="dataSource" ref="myDataSource"/&gt; &lt;!--加载 MyBatis 全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:MyBatis-config.xml"/&gt; &lt;!--为哪些包下的类起别名 --&gt; &lt;property name="typeAliasesPackage" value="cn.wolfcode.ssm.domain"/&gt; &lt;!--加载Mapper映射配置文件 --&gt; &lt;property name="mapperLocations" value="classpath:mappers/*Mapper.xml"/&gt; &lt;/bean&gt; &lt;!-- 创建 Mapper 接口的代理对象 --&gt; &lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;!-- 关联 sqlSessionFactory --&gt; &lt;property name="sqlSessionFactory" ref="mySqlSessionFactory"/&gt; &lt;!-- 根据哪一个接口创建代理对象 --&gt; &lt;property name="mapperInterface" value="cn.wolfcode.ssm.mapper.UserMapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; 设置mybatis的配置信息123456789&lt;!--设置 MyBatis 配置信息 --&gt;&lt;property name="configurationProperties"&gt; &lt;value&gt; lazyLoadingEnabled=true aggressiveLazyLoading=false lazyLoadTriggerMethods=clone &lt;/value&gt;&lt;/property&gt;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架-IoC-DI]]></title>
    <url>%2F2019%2F05%2F11%2FSpring%E6%A1%86%E6%9E%B6-IoC-DI%2F</url>
    <content type="text"><![CDATA[Spring框架概述Spring 是一个轻量级的 DI/IoC 和 AOP 容器的开源框架,致力于构建轻量级的 JavaEE 应用. 容器容器还要管理对象的生命周期,如 Tomcat 就是 Servlet 和 JSP 的容器 架构 1.Core Container(核心容器)包含有 Beans、Core、Context 和 SpEL 模块。 2.Data Access/Integration 层包含有 JDBC、ORM、OXM、 3.JMS 和 Transactions 模块。 4.Web 层包含了 Web、Servlet、WebSocket、Porlet 模块。 5.AOP 模块提供了遵循 AOP 联盟标准的面向切面编程的实现。 6.Test 模块支持使用 JUnit 和 TestNG 对 Spring 组件进行测试。 IoC和DI思想IoC:Inversion of Control(反转控制)将原本在程序中手动创建对象的控制权,交由 Spring 框架的 IoC 容器来管理.调用者只管负责从 Spring 容器中获取需要使用的对象,不关心对象的创建过程,也不关心该对象依赖对象的创建以及依赖关系的组装,也就是把创建对象的控制权反转给了 Spring 框架. IoC_Demodomain:123456789101112public class HelloWorld &#123; private String name; private int age; public void setName(String name) &#123; this.name = name;&#125; public void setAge(int age) &#123; this.age = age;&#125; public void sayHello() &#123;System.out.println(name + "你好,年龄" + age); &#125;&#125; XML 配置:12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;bean id="helloWorld" class="...HelloWorld"&gt; &lt;property name="name" value="will"/&gt; 对应HelloWorld中的setName方法 &lt;property name="age" value="17" /&gt; 对应 HelloWorld 中的 setAge 方法&lt;/bean&gt;&lt;/beans&gt; 测试类:12345678HelloWorld world = null;//加载 Spring 配置文件 applicationContext.xmlResource resource = new ClassPathResource("applicationContext.xml"); //创建 Spring 容器对象BeanFactory factory = new XmlBeanFactory(resource);//从 Spring 容器中获取制定名为 helloWorld 的 beanworld = (HelloWorld) factory.getBean("helloWorld"); world.sayHello(); BeanFactorySpring IoC 容器——生产 bean 对象的工厂,负责配置,创建和管理 bean.被 Spring IoC 容器管理的对象称之为 bean Spring IoC 管理 bean 的原理: 1.通过 Resource 对象加载配置文件2.解析配置文件,得到指定名称的 bean3.解析 bean 元素,id 作为 bean 的名字,class 用于反射得到 bean 的实例:注意:此时，bean 类必须存在一个无参数构造器(反射创建:和访问权限无关);4.调用 getBean 方法的时候,从容器中返回对象实例; 就是把代码从 JAVA 文件中转移到了 XML 中12345678910111213141516171819HelloWorld wolrd = null;String className="...HelloWorld";//-----------------------------------------------------Class clz = Class.forName(className);Constructor con = clz.getDeclaredConstructor();con.setAccessible(true);wolrd = (HelloWorld)con.newInstance();BeanInfo beanInfo = Introspector.getBeanInfo(wolrd.getClass());PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor pd : pds) &#123; String propertyName = pd.getName(); Method setterMethod =pd.getWriteMethod(); if("name".equals(propertyName))&#123; setterMethod.invoke(wolrd, "Will"); &#125;else if("age".equals(propertyName)) &#123; setterMethod.invoke(wolrd, 17);&#125; &#125;//-----------------------------------------------------wolrd.sayHello(); getBean 方法签名方式一:按照 bean 的名字拿 bean，按照名字拿 bean 不太安全1world = (HelloWorld) factory.getBean("helloWorld"); 方式二:按照类型拿 bean，要求在 Spring 中只配置一个这种类型的实例1world = factory.getBea (HelloWorld.class); 方式三:按照名字+类型(推荐)1world = factory.getBean("helloWorld",HelloWorld.class); bean元素id,name和importid:可以使用字母、数字、连字符、下划线、句话、冒号,不能以“/”开头(spring3.1之前)name:使用 name 属性为 bean 元素起多个别名,多个别名之间使用逗号或空格隔开. import resource:将一个applicationContext.xml 文件分解成多个配置文件,然后在 applicationContext.xml 文件中包含其他配置文件1&lt;import resource="classpath:路径1/路径2/hello.xml"/&gt; Spring 测试框架基于 JUnit4 的测试:12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:springTest.xml") public class SpringTestTest &#123; @Autowired private HelloWorld world; @Test public void test1() throws Exception &#123; world.sayHello(); &#125;&#125; @ContextConfiguration默认去找的当前测试类名-context.xml 配置文件,如:SpringTestTest-context.xml IoC 容器BeanFactory:Spring 最底层的接口,只提供了的 IoC 功能，负责创建、组装、管理 bean,在应用中一般不使用 BeanFactoryApplicationContext:ApplicationContext 接口继承了BeanFactory,除此之外还提供 AOP 集成、国际化处理、事件传播、统 一资源价值等功能. bean实例化方式2.静态工厂方法实例化:解决系统遗留问题3.实例工厂方法实例化:解决系统遗留问题 必须保证 SomeBean1 必须有无参数构造器,和访问权限无关1.构造器实例化(无参数构造器),最标准,使用最多.12345public class SomeBean1 &#123; public SomeBean1() &#123; System.out.println("SomeBean1 构造器"); &#125;&#125;&lt;bean id="someBean1" class="...SomeBean1"/&gt; 4.实现 FactoryBean 接口实例化:实例工厂变种用于其他框架和 Spring 集成,如集成 MyBatis 使用:org.mybatis.spring.SqlSessionFactoryBean1234567891011public class SomeBean4 &#123;&#125;public class SomeBean4FactoryBean implements FactoryBean&lt;SomeBean4&gt;&#123; public SomeBean4 getObject() throws Exception &#123; //TODO return new SomeBean4(); &#125; public Class&lt;?&gt; getObjectType() &#123; return SomeBean4.class;&#125; &#125;&lt;bean id="someBean4" class="...SomeBean4FactoryBean"/&gt; Bean 作用域1&lt;bean id="" class="" scope="作用域"/&gt; singleton: 单例prototype: 多例,每次从容器中调用 Bean 时,都返回一个新的实例 Bean 初始化和销毁1.init-method:bean 生命周期初始化方法,bean 对象创建后就进行调用.2.destroy-method:容器被正常销毁的时候,如果 bean 被容器管理,会调用该方法. DI 核心1.所谓注入,可以简单理解为 IoC 容器创建对象的时候,设置相关的属性值.2.给对象设置数据:要么是在创建对象的时候通过构造器传入.要么就是先创建对象,再通过setter 方法再设置所以，注入方式主要有两种: 1.setter 方法注入 123456789101112131415161718//注入常量&lt;property name="name" value="蛤蛤"/&gt;//注入对象&lt;property name="instance" ref="instance"/&gt;//注入集合&lt;property name="prop"&gt; &lt;props&gt; &lt;prop key="pKey1"&gt;pVal1&lt;/prop&gt; &lt;prop key="pKey2"&gt;pVal2&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;//简写&lt;property name="prop"&gt; &lt;value&gt; pKey1=pValue1 pKey2=pValue2 &lt;/value&gt;&lt;/property&gt; 2.构造器注入: 构造器方式注入使用:1234567&lt;constructor-arg/&gt;元素//安装构造器的参数名字设置值&lt;constructor-arg name="name" value="will"/&gt;&lt;constructor-arg name="age" value="17" /&gt;&lt;constructor-arg name="other" ref="otherBean"/&gt;&lt;constructor-arg name="prop"&gt; 配置连接池12345678&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/springdemo"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="admin"/&gt; &lt;property name="initialSize" value="5"/&gt;&lt;/bean&gt; 抽取 db.properties 文件12345jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///springdemojdbc.username=rootjdbc.password=adminjdbc.initialSize=5]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis增强]]></title>
    <url>%2F2019%2F05%2F10%2FMyBatis%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[使用mapper接口1.这个接口的全限定类名===对应的Mapper文件的namespace;2.这个接口中的方法和Mapper文件中的SQL元素一一对应: XML文件1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- StudentMapper的全限定类名 --&gt;&lt;mapper namespace="me.cscar.many2many.mapper.StudentMapper"&gt; &lt;insert id="save" useGeneratedKeys="true" keyProperty="id" keyColumn="id"&gt; INSERT INTO student (name) VALUES (#&#123;name&#125; ) &lt;/insert&gt;&lt;/mapper&gt; 测试类文件1234SqlSession session = MybatisUtil.getSession();StudentMapper studentMapper = session.getMapper(StudentMapper.class);/* 通过传入StudentMapper.class获得全限定名,就是namespace返回StudentMapper对象,调用save方法 */ mapper接口12void save(Student stu);//方法名为id 动态SQLif set where switch在多个中选择一个 foreach trim #{}和${}的区别相同: #和$都可以从对象或者Map中获取参数值 不同:使用#设置参数时候,先将参数转为?占位符,然后再赋值:使用PreparedStatement 使用$设置参数时,直接将参数拼接到sql中,使用Statement使用$设置参数可能存在SQL注入隐患. 使用#设置参数,如果是字符串,会自动加上’’, 而$不会,它会原样输出 在一些情况下,比如排序,比如分组操作时候拼接参数时不应该拼接’’ 总结:一般设置参数使用#,如果要拼接sql比如 排序,分组等.使用 $ (因为他们是按照列名来排序和分组的) 使用@param设置多个参数MyBatis在#{}中参数流程:1.会去参数对象中,按照属性或者Map的key去查询;2.如果找不到,尝试直接把方法的实际参数作为查询参数值 如果一定要在Mapper接口上的一个方法中添加多个参数,就一定要在每个参数前使用@Param标签. 原理:Mybatis在处理这些Mapper方法的时候,会自动的把这些参数包装成一个Map对象,@Param中的value就会作为这个Map的key,对应的参数值,就会作为这个Key的value; 原理:mybatis自动把参数封装成map 对象关系1.依赖关系:如果A对象离开了B对象,A对象就不能正常编译,则A对象依赖B对象. 2.关联关系:A对象依赖B对象,并且把B对象作为A对象的一个属性,则A和B是关联关系.(特殊的依赖关系) 3.聚合关系:表示整体和部分的关系,整体和部分之间可以相互独立存在,一定是有两个模块来分别管理整体和部分. 4.组合关系:强聚合关系,但是整体和部分不能独立存在,一定是在一个模块中同时管理整体和部分,生命周期必须相同. 5.泛化关系:其实就是继承关系. 关联关系划分1.一对一:一个A对象属于一个B对象,一个B对象属于一个A对象.2.一对多:一个A对象包含多个B对象. (判断基准:谁占主导地位),通过谁找到谁3.多对一:多个A对象属于一个B对象,并且每个A对象只能属于一个B对象.4.多对多:一个A对象属于多个B对象,一个B对象属于多个A对象.(老师和学生) MyBatis一级缓存缓存的作用/原理: 缓存本质来说就是Map,缓存是存在内存中的,可以在查询的时候减少数据库的访问次数,加快查询速度. 1.当第一次查询的时候get(1L),先将这次的调用转出一个字符串的key =Employee:1L首先在缓存中查询是否有这个key对应的对象,如果没有,去数据库中查询.查询之后会把该对象放入到缓存中,在把数据返回给调用者. 2.第二次查询的时候get(1L),先将这次的调用转出一个字符串的key =Employee:1L,在缓存中查询是否有可以key对应的对象,直接从内存中的缓存获取到对应的对象,直接返回一级缓存默认是开启的.一级缓存生命周期==session的生命周期,在多个session中是无法进行数据共享. 在一次会话中,如果需要查询多次相同id的对象,此时后面几次的查询都会从的缓存中获取,加快了查询速度,减少了访问数据库的次数.一级缓存的作用有限,只提高了一点点的性能. sqlsession的缓存操作注意问题:1: 缓存在同一个sqlsession才有效 2: 一旦sqlsession执行DML/DDL操作, 会清空缓存 3: 如果不想使用缓存,想直接从数据库获取: 可以执行: session.clearCache(); 4:开发中, sqlsession缓存仅仅针对某一个session, 对于整个系统性能提升不是很高, 一般来说, 不使用. 一般会使用二级缓存.(对应SqlSessionFactory) 二级缓存1.二级缓存生命周期==sessionFactory的生命周期. 2.二级缓存可以在不同的session之间进行数据的共享. 3.二级缓存默认是关闭的,需要手动的去开启. 4.不是所有对象都适合放到二级缓存中,只有是读远远大于写的对象才适合放到二级缓存中. 5.只要对象发生DML操作,MyBatis中的二级缓存都会给清除. 6手动开启的二级缓存.在对应的mapper.xml文件中添加一行: 一添加上就报错. java.io.NotSerializableException: cn.wolfcode._1_crud.User要求缓存的对象需要实现序列化接口. 缓存有个策略,当内存中的对象已经达到设置的存储最大值.超出的对象如果需要也缓存起来.支持把缓存对象序列化到硬盘中.要获取的时候再反序列化回来.]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie & Session]]></title>
    <url>%2F2019%2F05%2F05%2FCookie-Session%2F</url>
    <content type="text"><![CDATA[会话跟踪技术: Cookie SessionHTTP是无状态协议,也就是没有记忆力,每个请求之间无法共享数据. CookieCookie是客户端技术,程序把每个用户的数据以cookie的形式写给用户各自的浏览器.当用户使用浏览器再去访问服务器中的 web资源时,就会带着各自的数据去.这样,web资源处理的就是用户各自的数据了. Cookie 的使用:1.Cookie 是谁来创建,怎么创建的? 服务器端程序来创建: Cookie cookie = new Cookie(String name,String value); 参数: name: 给共享的数据起一个唯一的标志 value: 要存入的用户的数据 Cookie c = new Cookie(“currentName”,”xiaoming”); 2.如何响应 Cookie 给 浏览器. response对象.addCookie(Cookie cookie); resp.addCookie(c); 3.如何获取 Cookie 中的数据. 浏览器带过来的数据理应在请求对象中. Cookie[] cookies = request对象.getCookies(); 遍历数组拼配一个name是currentName 的数据. cookie.getName() : 获取Cookie 中的唯一标志的名称 cookie.getValue(): 当前Cookie 的数据. 4.修改Cookie 方式一: 再创建一个同 name 值的Cookie 对象来做覆盖的操作: Cookie cookie = new Cookie(“currentName”,”小明”) 方式二: 直接重新给Cookie赋值 cookie.setValue(“新的数据”) 注意: 两种方式都需要重新响应给浏览器去覆盖之前的Cookie 5.Cookie的中文问题 URLEncoder : 把中文转为非中文的字符串 URLDecoder : 把非中文的字符串转回中文 6 Cookie的分类 : 会话Cookie: 浏览器关闭 Cookie 就失效. 持久Cookie: Cookie 可以保留一定的时间. cookie.setMaxAge(int value): 使用的秒为单位: 负数: -1 : 不保存Cookie (会话Coookie); 0: 删除Cookie 正数: 设置存活的时间(秒) SessionSession是服务器端技术,利用这个技术,服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象,由于session为用户浏览器独享.所以用户在访问服务器的web资源时,可以把各自的数据放在各自的session中,当用户再去访问服务器中的其它web资源时,其它web资源再从用户各自的session中取出数据为用户服务. Session的使用Session 的使用:1 创建或获取Session 对象 HttpSession request.getSession(true) : 获取HttpSession对象,如果存在直接返回,如果不存在,创建一个新的Session对象然后返回. HttpSession request.getSession(false) : 获取HttpSession对象,如果存在直接返回,如果不存在返回null HttpSession request.getSession() : 同 1 2 设置共享数据 session.setAttribute(String name,Object value); 参数: name : 共享的数据的唯一标志 value : 要设置的共享数据 3 获取共享数据 session.getAttribute(String name); 4 移除 Session 中的数据 1:删除Session中指定属性名的值. session.removeAttribute(String name); 2:销毁Session对象 session对象.invalidate(); 5 Session的超时管理. 默认的超时时间: 30分钟 : 在Tomcat/conf/web.xml session.setMaxInactiveInterval(int seconds) 6 URL重写:Session 是一个特殊的Cookic ,存在浏览器上,用户可选择不接受Cookie方式一: 使用参数形式 jsessionid 传递给下一个请求,使用 ; 来设置参数的值方式二: 调用方法来生成带有 jsessionid 的 urlString url = resp.encodeURL(“/session/content”);开发中不要拒收Cookie]]></content>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三层架构]]></title>
    <url>%2F2019%2F05%2F05%2F%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[三层构架 表示层:位于最上层,最接近用户,用于显示数据和接收用户输入的数据,为用户提供一种交互式操作的界面 业务逻辑层:表示层和 DAL(DAO)层之间的桥梁,实现业务逻辑.业务逻辑具体包含:验证,计算,业务规则等等 数据访问层:与数据库打交道.主要实现对数据的增、删、改、查.将存储在数据库中的数据提交给业务层,同时将业务层处理的数据保存到数据库(Dao) 逻辑图: 业务逻辑层(service)其实是一个组件(可以重复使用),包括:接口和接口的实现类 service 组件起名规范:以下使用 Xxx 都表示一个对象比如 Employee,Department.service 接口 : IEmployeeServiceservice 实现类: EmployeeServiceImplservice 测试类: EmployeeServiceTestservice 对象的名字: Employee,Department]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL增强]]></title>
    <url>%2F2019%2F05%2F03%2FMySQL%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[数据库数据库（DataBase）：是一个按数据结构来存储和管理数据的计算机软件系统. 简而言之:存储数据的仓库/存储数据的特殊文件. 1.数据定义语言:DDL数据库建立、修改、变更及扩充功能2.数据操纵语言:DML实现数据的插入,修改,删除,查询,统计等数据存取操作的功能称为数据操纵功能3.数据查询语言:DQL用以从表中获得数据,确定数据怎样在应用程序给出.保留字SELECT是DQL(也是所有SQL)用得最多的动词,其他DQL常用的保留字有WHERE,ORDER BY,GROUP BY和HAVING.这些DQL保留字常与其他类型的SQL语句一起使用 数据库基础关系型数据库和非关系型数据库关系型数据库：在关系模型中，数据的逻辑结构为满足一定条件的二维表，表具有固定的列数和任意的行数，在数学上称为”关系” 关系型数据库的三范式:第一范式(1NF):是对关系模式的基本要求,不满足第一范式就不是关系数据库.是指数据表的每一列都是不可分割的基本数据项,同一个列中不能有多个值. 第二范式(2NF):每个实例或行&apos;必须有主键&apos;,区分每一行数据(可以被打破) 第三范式(3NF):要求一个数据表中,不包含其它表中的非主键信息.(在设计表的时候,为了性能,有时会打破第3范式) 常见的数据库1.Oracle：大型企业数据库，支持数据量，速度较快，安全性非常好，提供完善的存储过程支持；新的版本提供了众多新功能； 2.DB2（IBM）：大型企业数据库，支持数据量，速度较快，安全性较好, 恢复性强； 3.SQL Server（MS）：大型企业数据库，支持数据量，速度较快，安全性较好； 4.MySQL（Oracle）：性能不错，使用方便，体积小，易扩展；是目前使用最广的关系型数据库； 查询多表查询-笛卡尔积没有连接条件的表关系返回结果,多表查询会产生笛卡尔积.解决方案: 在WHERE加入有效的连接条件—-&gt;等值连接隐藏内连接查询语法:1234SELECT &lt;select_list&gt;FROM 表名称 A, 表名称 BWHERE 查询条件 AND 消除笛卡尔积的连接条件[ORDER BY 排序字段 [ASC|DESC] [,排序字段 [ASC|DESC] ,…]]; 显示内连接查询语法:12SELECT &lt;select_list&gt;FROM A [INNER] JOIN B ON 消除笛卡尔积的连接条件 [JOIN ...] 内连接查询,两种查询的结果完全相同,区别在于是否能看到JOIN关键字 unionJOIN是用于把表横向连接，UNION/UNION ALL是用于把表纵向连接(一般用于做查询的临时表)UNION 操作符用于合并两个或多个 SELECT 语句的结果集.1234语法：SELECT column_name(s) FROM table_name1UNION|UNION ALLSELECT column_name(s) FROM table_name2 单行函数DAY(date):获取日期中的天数（DAYOFMONTH）HOUR(time):返回time 对应的小时数。对于日时值的返回值范围是从 0 到 23MINUTE(time):返回 time 对应的分钟数,范围是从 0 到 59MONTH(date):返回date 对应的月份，范围时从 1 到 12YEAR(date):返回date 对应的年份,范围是从1000到9999LAST_DAY(date):获取一个日期或日期时间值，返回该月最后一天对应的值DATE_FORMAT(data,format) 聚合分组函数AVG：计算平均值SUM：计算总和 COUNT ({ |[DISTINCT|ALL]expr})COUNT()返回表中所有符合条件的记录数COUNT(字段) 返回所有符合条件并且字段值非空的记录(右键设置某个字段为null,如果加了where条件后, 就以where 后面的列作为计数条件)COUNT(distinct(expr))返回不重复的，非空值的数量 MIN and MAX适用于任何数据类型MIN： 计算最小值MAX：计算最大值 分组查询分组查询的语法:SELECT [DISTINCT] *|分组字段1 [别名] [,分组字段2 [别名] ,…] | 统计函数/分组函数/聚合函数FROM 表名称 [别名], [表名称 [别名] ,…][WHERE 条件(s)][GROUP BY 分组字段1 [,分组字段2 ,…]][ORDER BY 排序字段 ASC | DESC [,排序字段 ASC | DESC]]; 注意: 1出现在SELECT列表中的字段,如果出现的位置不是在聚合函数中,那么必须出现在 GROUP BY 子句中 2.在GROUP BY 子句中出现的字段，可以不出现在SELECT列表中 3.如果没有GROUP BY子句, SELECT列表中的任何列或表达式不能和统计/分组/聚合函数同时使用： 错误操作: select ename, sal, count(empno) from emp; 如果现在要进行分组的话，则SELECT子句之后，只能出现分组的字段和统计函数，其他的字段不能出现 使用HAVING子句对分组的结果进行限制 1.不能在 WHERE 子句中 对分组之后的结果过滤. 2.使用group by语句后,如果需要过滤, 必须使用 HAVING 子句(分组后的过滤). 3.不能在 WHERE 子句中使用聚合函数. 其他123select -- from --- where --- group by ----having --- order by --- limit?,?sql 执行顺序~~~from -- where -- group by -- having -- select -- order by -- limit ?, ? 子查询子查询指的就是在一个查询之中嵌套了其他的若干查询.在where查询条件中的限制条件不是一个确定的值,而是来自于另一个查询结果. 子查询一般出现在FROM和WHERE子句中. 使用子查询的注意事项: 1.子查询要用括号括起来 2.将子查询放在比较运算符的右边(增强可读性) 3.对单行子查询使用单行运算符 4.对多行子查询使用多行运算符 语法:123SELECT &lt;select_list&gt;FROM 'table'WHERE 条件 操作符 (SELECT select_list FROM table); 子查询的分类:单行单列子查询,得到的是一个值,返回的结果只包含一行数据 多行单列子查询,得到的是一个集合,返回多行或零行 多行多列子查询,得到的是一个二维表,包含多个字段的返回(一张临时的表) 单行单列子查询:1.返回一行记录,好比一个值.2.使用单行记录比较运算符=;&gt;;&gt;=;&lt;;&lt;=!=(针对于一个值得运算符) 多行子查询返回多行单列1.返回多行,好比多个值2.使用多行比较运算符 IN:与列表中的任意一个值相等 =ANY:此时和IN操作符相同 &gt;ANY:大于子查询中最小数据 &lt;ANY:小于子查询中最大数据 &gt;ALL:大于子查询中最大的数据 &lt;ALL:小于子查询中最小的数据 多列子查询子查询返回的结果是多行多列/一行多列,只要是多列,就可以看成是一张表.一般会把多列子查询.返回的结果当成一个临时表,接着在临时表上继续查询或者询注意:多行多列的子查询返回的结果必须要设置一个临时表的名称. DML操作1.插入操作1INSERT INTO table [(column [, column...])] VALUES (value [, value...]),(value [, value...]),... 一条SQL的长度是有限的，可以通过调整max_allowed_packet参数(可以在my.ini文件中修改) 2.更新操作123UPDATE tableSET column = value [,column = value]…[WHERE condition]; UPDATE语句也可以使用表连接，子查询等多种方式执行3.删除操作12DELETE FROM table[WHERE condition]; 事务控制开启事务: begin提交事务: commit回滚事务: rollback 事务的ACID:原子性:Atomicity一致性:Consistency隔离性:Isolation持久性:Durability 控制事务的SQL语句(命令):commit 和 rollback可以显示的控制事务好处：1.保证数据一致性,修改过的数据在没有提交之前是不能被其他用户看到的2.在数据永久性生效前重新查看修改的数据3.将相关操作组织在一起,一个事务中相关的数据改变或者都成功,或者都失败 数据库的并发问题:MySQL使用的是repreatable read隔离级别 避免第二类丢失更新 方案1:悲观锁: 使用数据库自身的排它锁机制(写锁)(排斥其他锁).DML操作自动会加上排它锁 (排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁). DQL操作需要我们手动加上排他锁.1SELECT * FROM 表名 FOR UPDATE. 方案2:乐观锁: 在表中额外增加一个列,用来表示修改的版本(整数类型),修改一次就把版本增加1. 1:在表中新增一个列,用来表示修改的版本号,类型使用整数类型,初始值为0. 2:每次在修改数据之前,先发送SELECT语句去查询当前被修改数据的信息(包括版本号).1SELECT id,name,version FROM person WHERE id = 10; 查询出来的版本号为0. 3:发送UPDATE语句去更新数据:版本号修改递增1/判断条件中的版本号必须是刚刚查询出来的版本.1UPDATE person set name = 'Java' ,version = version + 1 WHERE id = 10 AND version = 刚刚查询出来的版本号(0). 4:判断update语句执行之后的受影响行数(rows),若rows&gt;0则提交事务,否则回滚事务. 数据库的权限权限相关命令:GRANT:MySQL中用于赋权限的命令是GRANT，语法为：完整语法：GRANT 权限 (columns)ON 数据库对象TO 用户 IDENTIFIED BY “密码”WITH GRANT OPTION 三种具体的语法: 给一个存在用户赋予权限:语法1:GRANT 权限 (columns) ON 数据库对象 TO 用户:赋予will账户:SELECT和INSERT权限.GRANT select,insert ON . TO will@localhost; 左边是数据库 . 右边是数据表. 表示全局权限 创建用户,设置密码,赋予权限:语法2:GRANT 权限 (columns) ON 数据库对象 TO 用户 IDENTIFIED BY “密码”创建lucy用户:GRANT ALL ON . TO lucy@localhost IDENTIFIED BY ‘1234’; 创建用户,设置密码,赋予权限,并且该用户可以继续授权给其他用户:语法3:GRANT 权限 (columns) ON 数据库对象 TO 用户 IDENTIFIED BY “密码” WITH GRANT OPTION]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web组件交互_el_jstl]]></title>
    <url>%2F2019%2F04%2F22%2Fweb%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92-el-jstl%2F</url>
    <content type="text"><![CDATA[web组件在web应用中,servlet/jsp就是web的组件 跳转:请求转发和重定向 共享数据:作用域对象 jsp页面取数据EL表达式 优雅的显示数据JSTL 请求转发1.请求转发:forward2.重定向:redirect3.请求包含:include常用api: 在HttpServletRequest对象中 RequestDispatcher getRequestDispatcher(String path):获取请求分发器. String path: 请求转发到的目标资源 void forward(ServletRequest request, ServletResponse response) :请求转发的动作. 12//获取到请求分发器,请求转发到WEB-INF/view/product/table.jsp资源上 req.getRequestDispatcher("WEB-INF/view/product/table.jsp").forward(req, resp); url重定向在HttpServletResponse对象中. void sendRedirect(java.lang.String location) : 重定向, String location: 重新定位的资源的地址.12//url重定向resp.sendRedirect("/pro?cmd=list"); 1.地址栏会发生变化.是s2. 2.只会有目标资源s2的响应,s1的响应不生效. 3.重定向会发送两次请求.在多个组件不能共享数据. 4.重定向,不能访问WEB-INF中的资源,相当于是把目标资源放在浏览器的地址栏敲回车. 5.重定向可以访问别人(域外)的资源. 请求转发和url重定向选择请求转发: 共享数据 请求到WEB-INF中的资源url重定向: 访问域外资源都能使用的情况,使用重定向 三大作用域对象 作用域 类型 描述 request HttpServletRequest 在一次请求中,多个组件都共享数据,需要使用请求.request在service方法中,tomcat在调用这个生命周期方法的时候,就会创建. session HttpSession HttpSession session = request.getSession(); 使用请求对象获取session对象 application ServletContext ServletContext application = getServletContext(); ServletContext application = request.getServletContext(); 共享数据的基本操作 1.新增数据: void setAttribute(java.lang.String name, java.lang.Object o): 保存数据,包含唯一的名字,和可重复值.2.删除数据: void removeAttribute(java.lang.String name):根据共享属性名.来删除共享数据3.修改数据: void setAttribute(java.lang.String name, java.lang.Object o):同新增4.查询数据: java.lang.Object getAttribute(java.lang.String name):通过共享数据(属性)的唯一名字,找到对应的值. 三大作用域范围1.请求作用域对象:1req.setAttribute("MSG_IN_REQUEST","request"); 只能在一次请求中共享数据,如果不是同一个请求,是多次请求,一定不能共享.如果想要在一次请求过程中的多个组件,要共享,需要使用请求转发. 2.会话作用域对象:1req.getSession().setAttribute("MSG_IN_SESSION","session"); 想在访问站点之后,多次请求都需要共享.可以使用session对象.从访问开始到浏览器关闭为止.3.应用作用域对象:1req.getServletContext().setAttribute("MSG_IN_APPLICATION","application"); 只要服务器开启,都可以共享. 上下文对象:环境.整个应用的生命周期.从服务器启动,到服务器关闭,只有一个. 对象的获取方式: 1.当前servlet中,可以调用getServletContext来获取. 2.request对象可以调用getServletContext获取. 3.session对象可以调用getServletContext来获取. 不管用什么对象来获取到的上下文对象,都是同一个对象. 常用的API: java.lang.String getRealPath(java.lang.String path) :传递一个地址,可以得到真正的磁盘地址. 负责把路径直接拼接到webapp根的后面,不负责去校验是否合法. String getContextPath();获取上下文路径. EL表达式:语法格式:${共享数据的属性名.属性名.属性名}.从page作用域开始,一直找到application为止,如果找到,直接返回,如果没找到,返回的是空字符串. JSTL使用JSTL标签库消除JSP中的java代码 条件判断1.if单条件判断123&lt;c:if test="$&#123;用EL表达式取出来的值&#125;" //如果test返回true,执行&lt;/c:if&gt; 2.choose多条件判断12345678&lt;c:choose&gt;&lt;c:when test="$&#123;用EL表达式取出来的值&#125;"&gt; //&lt;/c:when&gt;&lt;c:otherwise&gt; //TODO...&lt;/c:otherwise&gt;&lt;/c:choose&gt; 循环标签1234567&lt;c:forEach var="stu" items="$&#123;result.listData&#125;" varStatus="vs"&gt; &lt;tr&gt; &lt;td&gt;$&#123;vs.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; items代表源数据,需要使用EL表达式去取var代表每一个变量,该变量将会存储到PageContext作用域中varStatus代表迭代状态.vs.index:从0开始,vs.count:从1开始 时间格式化标签1&lt;fmt:formatDate value="$&#123;date&#125;" pattern="yyyy-MM-dd"/&gt;]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>网络编程</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis设计模式总结]]></title>
    <url>%2F2019%2F04%2F17%2FMyBatis%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MyBatis设计模式总结Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder； 工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory； 单例模式，例如ErrorContext和LogFactory； 代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；组合模式，例如SqlNode和各个子类ChooseSqlNode等；模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；迭代器模式，例如迭代器模式PropertyTokenizer； Builder模式在SqlSessionFactoryBuilder类中,重载了build方法这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决,对于builder的具体类，方法都大都用build*开头.即根据不同的输入参数来构建SqlSessionFactory这个工厂对象]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2019%2F04%2F17%2FMyBatis%2F</url>
    <content type="text"><![CDATA[ORM思想对象关系映射Object Relational MappingORM主要解决对象-关系的映射 对象 关系 类 表 对象 表的行(记录) 属性 表的列(字段) MyBatis:本是apache的一个开源项目iBatis,提供的持久层框架包括SQL Maps和DAO,允许开发人员直接编写SQL主配置文件,关联映射文件 XML映射配置文件 mybatis-config.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- properties配置文件 --&gt; &lt;properties resource="db.properties"&gt;&lt;/properties&gt; &lt;!-- domain的全限定名 --&gt; &lt;typeAliases&gt; &lt;package name="me.cscar.smis.domain.Student"/&gt; &lt;/typeAliases&gt; &lt;!-- 告知框架,链接数据库的四要素,以及事务的处理 --&gt; &lt;environments default="dev"&gt; &lt;!-- id属性是某一个环境的唯一标记 --&gt; &lt;environment id="dev"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 驱动名,键值对,对应properties --&gt; &lt;property name="driver" value="$&#123;driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 找到Sql的映射文件,包名开头(域名倒写)的路径 --&gt; &lt;mappers&gt; &lt;mapper resource="me/cscar/smis/mapper/StudentMapper.XML" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; StudentMapper.XML123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 命名空间mapper接口的全限定名 --&gt;&lt;mapper namespace="me.cscar.smis.mapper.StudentMapper"&gt; &lt;!-- id属性:当前的sql语句,在mapper的唯一标记 --&gt; &lt;insert id="save"&gt; &lt;!-- 占位符#&#123;&#125;,mybatis从对应的对象中,取出指定的属性值 --&gt; INSERT INTO student (name,age) VALUES (#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 如果是DML操作,直接告知sql.在执行的时候,传递参数,使用OGNL表达式来获取值. 如果是DQL(查询)操作,还必须告知框架,查询的结果的每一行封装成什么类型的对象. sql语句的执行流程: 首先,会将#{}更改成占位符?, 然后,通过传递过来的参数来设置给占位符. 如果列名和属性名匹配,可以使用resultType,也可以使用resultMap. 如果不匹配,要使用resultMap. Mybatis.java1234567891011121314151617181920212223242526package me.cscar.smis.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;public class MybatisUtil &#123; private static SqlSessionFactory factory = null; static &#123; try &#123; factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream("mybatis-config.xml")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession() &#123; return factory.openSession(); &#125;&#125; mybatis操作流程: 加载主配置文件,获取factory对象. factory = new SqlSessionFactoryBuilder().build(); 获取xml文件,等同于thread… Resources.getResourceAsStream(“mybatis-config.xml”) 通过factory对象获取session对象. 调用Mybatis的getSqlSession方法,返回openSession 通过session执行sql. … DML操作要手动提交事务. … 关闭资源]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2F04%2F15%2FServlet%2F</url>
    <content type="text"><![CDATA[Servlet概述Java Servlet(服务小程序),生成动态的web内容Servlet运行于支持Java的web应用服务器中 1.导入jar包.在/Library/Tomcat/lib/servlet-api.jar 2.创建一个类,实现servlet接口 3.配置web.xml web.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!-- 配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;me.cscar.network.servlet.HelloServlet&lt;/servlet-class&gt; &lt;!-- 初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 一个实现servlet接口的类1234567891011121314151617181920212223242526272829303132333435package me.cscar.network.servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.IOException;public class HelloServlet implements javax.servlet.Servlet&#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("success"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; servlet的生命周期1.创建对象 2.初始化 3.执行操作 4.销毁 整个生命周期的过程都是用Tomcat来管理调用123456789101112131415161718192021//初始化方法public void init(ServletConfig servletConfig) throws ServletException &#123;&#125;//获取当前servlet的配置信息public ServletConfig getServletConfig() &#123; return null;&#125;//执行操作的方法public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;&#125;//返回作者,版权信息,版本信息public String getServletInfo() &#123; return null;&#125;//销毁方法public void destroy() &#123;&#125; 注意:在servlet整个生命周期中,都是单例的.servlet的构造器必须是公共无参数构造器 servlet的请求流程1.在当前项目的根路径下的WEB-INF目录中,读取web.xml文件2.获取web.xml中所有的元素,判断是否存在标签里的资源名称,不存在返回404错误3.根据/资源名称获取对应的servlet的全限定名.4.根据获取到的全限定名,使用反射来调用构造器,创建对象1Object obj = Class.forName("全限定名").newInstance(); 5.使用创建的servlet对象,调用init(config)方法.或者,从Tomcat中的servlet实例缓冲池中取出”全限定名”对应的对象,Servlet obj = …6.创建ServletRequest对象,ServletResponse对象,再使用servlet对象调用service方法.1obj.service(req,resp) 7.在service方法中对客户端做响应操作 Servlet接口配置web.xml初始化参数12345&lt;!-- 初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; 通过servlet对象获取参数1String encoding = obj.getInitParameter("encoding") //utf-8 获取所有的初始化参数名称123456Enumeration&lt;String&gt; names = obj.getInitParameterNames(); //使用迭代器遍历while (names.hasMoreElements()) &#123; String name = names.nextElement(); String value = config.getInitParameter(name); System.out.println(name + ":" + value);&#125; 方法1234String getServletName() //获取当前Servlet 的&lt;servlet-name&gt;中的内容ServletContext getServletContext() //获取上下文对象,一个应用就只有一个上下文对象String getInitParameter(String name) //获取指定名称的初始化参数值Enumeration&lt;String&gt; getInitParameterNames() //获取所有的初始化参数的名称 Servlet的继承体系12345678910111213141516171819package me.cscar.network.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HttpServletDemo extends HttpServlet &#123; @Override public void init() throws ServletException &#123; System.out.println("自己的初始化代码"); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("执行操作"); &#125;&#125; HttpServletRequest常用方法 常用方法 返回 req.getMethod() 请求方式(post,get) req.getRequestURI 返回请求行中的资源名字部分 req.getRequestURL() 返回客户端请求的完整url req.getContextPath() 获取当前项目的上下文路径path的值 req.getRemoteAddr() 发出请求的客户机ip地址 req.getHeader(“User-Agent”) 指定名称的头字段的值 获取表单请求参数 方法 返回 req.getParameter(“value”) 获取表单请求参数 getParameterValues(“hobby”) 指定名字参数的多个参数值。(复选框) req.getParameterNames() 获取表单的所有参数名 req.getParameterMap() 把所有的表单数据保存在map中 getOutputStream() 获取字节输出流对象. ( 文件下载) getWriter() 获取字符输出流对象 response.setContentType(“text/html;charset=utf-8”) 设置输出的MIME类型和编码方式 123456789101112131415161718192021222324252627282930313233343536//req.getMethod():返回请求方式System.out.println(req.getMethod());//req.getRequestURI:返回请求行中的资源名字部分System.out.println(req.getRequestURI());//返回客户端请求的完整urlSystem.out.println(req.getRequestURL());//获取当前项目的上下文路径&lt;context&gt;path的值System.out.println("ContextPath" + req.getContextPath());//返回发出请求的客户机ip地址System.out.println(req.getRemoteAddr());//返回指定名称的头字段的值System.out.println(req.getHeader("User-Agent"));//设置编码req.setCharacterEncoding("UTF-8");System.out.println("name:" + req.getParameter("username"));System.out.println("password:" + req.getParameter("psw"));//获取表单中的多个数据String[] values = req.getParameterValues("hobby");System.out.println(Arrays.toString(values));//获取表单的所有参数名Enumeration&lt;String&gt; names = req.getParameterNames();while (names.hasMoreElements()) &#123; String name = names.nextElement(); System.out.println(name);&#125;//把所有的表单数据保存在map中Map&lt;String, String[]&gt; map = req.getParameterMap();Set&lt;Map.Entry&lt;String, String[]&gt;&gt; entrySet = map.entrySet();for (Map.Entry&lt;String, String[]&gt; entry : entrySet) &#123; String name = entry.getKey(); String[] value = entry.getValue(); System.out.println(name + ":" + Arrays.toString(value));&#125; JSP的原理流程:1.所有的jsp,jspx的访问都交给JspServlet来处理2.把jsp文件转化为java文件3.把所有java文件都转化为字节码文件4.把转化的文件存放在tomcat/work/…文件下 体系:HttpServlet &lt;- HttpJspBase &lt;- myDemo_jspjsp就是一个Servlet在java文件中123out.write("");...out.print(...); 存在字符输出流对象,输出了html jsp语法:123456789&lt;%!Java代码%&gt;&lt;%-- 注释,不会编译到servlet中 --%&gt;&lt;%= 表达式(调用out.print,输出到页面上) %&gt; JSP 三大指令 page include taglib page指令:作用：定义JSP页面的各种属性 属性：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748language:指示JSP页面中使用脚本语言。默认值java，目前只支持java。extends：指示JSP对应的Servlet类的父类。不要修改。*import：导入JSP中的Java脚本使用到的类或包。（如同Java中的import语句）JSP引擎自动导入以下包中的类： javax.servlet.* javax.servlet.http.* javax.servlet.jsp.*注意：一个import属性可以导入多个包，用逗号分隔。*sessioin:指示JSP页面是否创建HttpSession对象。默认值是true，创建*buffer：指示JSP用的输出流的缓存大小.默认值是8Kb。autoFlush：自动刷新输出流的缓存。isThreadSafe：指示页面是否是线程安全的（过时的）。默认是true。 true：不安全的。 false：安全的。指示JSP对应的Servlet实现SingleThreadModel接口。 *errorPage: 指示当前页面出错后转向（转发）的页面。 目标页面如果以"/"（当前应用）就是绝对路径。配置全局错误提示页面：web.xml&lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;&lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt;&lt;/error-page&gt;*isErrorPage:指示当前页面是否产生Exception对象。*contentType：指定当前页面的MIME类型。作用与Servlet中的response.setContentType()作用完全一致*pageEncoding：通知引擎读取JSP时采用的编码（因为要翻译） 还有contentType属性的作用。*isELIgnored:是否忽略EL表达式。$&#123;1+1&#125;。默认值是false。 page指令最简单的使用方式：&lt;%@ page pageEncoding="UTF-8"%&gt;2.include（静态包含,开发中能用静的不用动的） 作用：包含其他的组件。 语法：&lt;%@include file=""%&gt;file指定要包含的目标组件。路径如果以"/"（当前应用）就是绝对路径。 原理：把目标组件的内容加到源组件中，输出结果。 动态包含： 采用动作元素：&lt;jsp:include page=""/&gt;路径如果以"/"（当前应用）就是绝对路径。 3.taglib 作用：引入外部的标签 语法 &lt;%@ taglib uri="标签名称空间" prefix="前缀"%&gt; &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>网络编程</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F04%2F15%2FHttp%2F</url>
    <content type="text"><![CDATA[HTTP概述特点:无状态,,默认端口是80HTTP协议:浏览器(客户端)于web服务器之间一问一答的交互过程必须遵循一定的规则 UDP:面向数据报包,基于无连接,可能会丢包,速度快.广播.一堆人都可以听到,但是可能有部分人丢失数据.TCP:面向连接,传输可靠.性能低一些.相当于是一对一的教学,保证客户端和服务端一定能传输数据.基于浏览器的开发,都是TCP连接. HTTP1.1规范在一次TCP连接之间,多次请求,多次响应,响应完之后再关闭连接 GET和POST的区别GET:在请求某个服务器资源,如果没有指定请求方式,默认为GET可以通过GET的方式向服务器传递数据.方式:在URL路径加上?,多个参数用&amp;分割GET请求方式数据不安全(在URL显示),且URL有长度限制1Kget可以缓存,查询的时候可以使用getPOST:数据安全,且没有长度限制只有post才有请求实体.表单全部使用post提交]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>网络编程</tag>
        <tag>服务器</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接池]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[连接池在Java中,连接池使用javax.sql.DataSource接口来表示连接池.DataSource(数据源)和连接池(Connection Pool)是同一个. DBCP: Spring框架推荐的 druid: 阿里巴巴的连接池(号称Java语言中性能最好的连接池) DBCP连接池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package me.cscar.dbcp.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCutil &#123; private static Properties prs = new Properties(); private static BasicDataSource bds = null; //private static DataSource dsf = null; static &#123; try &#123; InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("db.properties"); prs.load(in); Class.forName(prs.getProperty("driverClassName")); //在静态代码块中初始化连接池对象,连接池只需一个即可 bds = BasicDataSourceFactory.createDataSource(prs); //druid连接池 //dsf = DruidDataSourceFactory.createDataSource(prs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; Connection conn = bds.getConnection(); //Connection conn = dsf.getConnection(); return conn; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(ResultSet rs, PreparedStatement ps, Connection conn) &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; druid连接池阿里巴巴研发出来的号称Java语言领域性能最高的连接池.wiki地址:https://github.com/alibaba/druid/wiki 使用起来,类似于DBCP连接池.方便检测性能/状态.支持:MySQL,Oracle,DB2,sql Server等.支持:对配置文件的密码加密.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package me.cscar.dbcp.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCutil &#123; private static Properties prs = new Properties(); //private static BasicDataSource bds = null; private static DataSource dsf = null; static &#123; try &#123; InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("db.properties"); prs.load(in); Class.forName(prs.getProperty("driverClassName")); //在静态代码块中初始化连接池对象,连接池只需一个即可 //bds = BasicDataSourceFactory.createDataSource(prs); //druid连接池 dsf = DruidDataSourceFactory.createDataSource(prs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; //Connection conn = bds.getConnection(); Connection conn = dsf.getConnection(); return conn; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(ResultSet rs, PreparedStatement ps, Connection conn) &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码重构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package me.cscar.dbcp.dao.impl;import me.cscar.dbcp.dao.IemployeeDAO;import me.cscar.dbcp.domain.Employee;import me.cscar.dbcp.util.JDBCutil;import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class EmployeeDAOimpl implements IemployeeDAO &#123; public static EmployeeDAOimpl instance = new EmployeeDAOimpl(); /** * dml操作 * * @param sql * @param obj */ @Override public void dml(String sql, Object... obj) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; obj.length; i++) &#123; ps.setObject(i + 1, obj[i]); &#125; ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(null, ps, conn); &#125; &#125; /** * 查 * * @param emp,args * @return */ @Override public List&lt;Employee&gt; get(String sql, Object emp, Object... args) &#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); Class&lt;?&gt; clz = emp.getClass(); while (rs.next()) &#123; BeanInfo info = Introspector.getBeanInfo(clz, Object.class); PropertyDescriptor[] pds = info.getPropertyDescriptors(); Object obj = clz.newInstance(); for (PropertyDescriptor ele : pds) &#123; //id,name,salary String cloumnName = ele.getName(); Object cloumnValue = rs.getObject(cloumnName); //getter,setter Method m = ele.getWriteMethod(); m.invoke(obj, cloumnValue); &#125; list.add((Employee) obj); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(rs, ps, conn); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>DataBase</category>
        <category>pool</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2019%2F04%2F10%2F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务事务(Transaction,简写为tx)1.当一个逻辑操作单元全部完成的时候,提交(commit)事务,这个操作就永久的保存到数据库中 2.如果回退(rollback),则放弃这个逻辑单元的所有操作 3.对于多个操作来说,作为一个整体(不可分割),所有操作成功(提交事务),数据库的数据才会改变 事务的ACID属性1.原子性(Atomicity) 2.一致性(Consistency) 3.隔离性(Isolation) 4.持久性(Durability) 事务的操作1.如果要控制事务,需要手动提交2.在MySQL中,只有InnoDB存储引擎支持事务123456789101112131415161718192021222324252627282930313233343536373839404142434445package me.cscar.account.test;import me.cscar.account.dao.impl.AccountDAOimpl;import me.cscar.account.util.JDBCutil;import org.junit.Test;import java.math.BigDecimal;import java.sql.Connection;import java.sql.SQLException;public class TXBalance &#123; @Test public void testTx() throws Exception &#123; BigDecimal money = new BigDecimal("1000"); AccountDAOimpl account = AccountDAOimpl.getInstance(); Connection conn = null; try &#123; if (account.getBalance("嘤嘤", money)) &#123; conn = JDBCutil.getConnection(); //设置手动处理事务 conn.setAutoCommit(false); account.addBalance("蛤蛤", money, conn); //假设出错 int i = 1 / 0; account.reduceBalance("嘤嘤", money, conn); //全部操作成功,提交事务 conn.commit(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); conn.rollback(); &#125; &#125;&#125; 获取自动生成的主键在数据库中保存数据的时候,要使用到自增id的时候就需要取出来. 1.如果要获取,需要设置一个标记. PreparedStatement prepareStatement(String sql, int autoGeneratedKeys):获取预编译语句对象的时候,可以设置标记,是否要获取自动生成的主键. autoGeneratedKeys: 是否要获取自动生成的主键. Statement.RETURN_GENERATED_KEYS 2.获取自动生成的主键. ResultSet getGeneratedKeys(): 获取自动生成的主键. 12345678910111213141516171819202122public class GetKey &#123; @Test public void testGetKey() throws Exception &#123; //插入一条数据到account表中获取自动生成的组件 String sql = "INSERT INTO account (name,balance) VALUES (?,?)"; Connection conn = JDBCutil.getConnection(); PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); ps.setObject(1, "包包"); ps.setObject(2, 10000); ps.executeUpdate(); //获取自动生产的组件 ResultSet rs = ps.getGeneratedKeys(); while (rs.next()) &#123; System.out.println(rs.getObject(1)); &#125; rs.close(); JDBCutil.close(ps, conn); &#125;&#125;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F04%2F06%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC概述可以为多种关系数据库提供统一访问,为开发者屏蔽了一些细节问题 获取数据库链接对象Connection -&gt; 数据库连接对象 导入驱动包 获取数据库连接对象 1.加载注册驱动: Driver驱动类:应该加载驱动包中实现Driver接口类的对象 public static void registerDriver(Driver driver):注册驱动 API中,建议使用Class.forName(“com.mysql.jdbc.Driver”);加载字节码对象的时候,会执行这个类的静态代码块. 调用Class.forName不是目的,目的是为了执行com.mysql.jdbc.Driver这个类的静态代码块. 而这个类的静态代码块就是在加载注册驱动 2.获取数据库连接对象 DriverManager驱动管理类: public static Connection getConnection(String url, String user, String password): 获取数据库连接对象. JDBC操作模板1.加载注册驱动 2.获取数据库连接对象 3.生成预编译语句对象 4.执行SQL命令 5.释放资源 相关操作executeQuery(String sql): 执行DQL操作,返回单个ResultSet对象.executeUpdate(String sql): 执行DDL和DML操作 DML操作123456789101112131415161718192021222324252627package me.cscar.dml;import me.cscar.util.JDBCUtil;import org.junit.Test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class InsertTable &#123; @Test public void testInsertTable() throws Exception &#123; String sql = "INSERT INTO student(name,age) VALUES('东方翠花',20)"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.链接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javaweb", "***", "***"); //3.创建语句对象 Statement st = conn.createStatement(); //4.执行SQL命令 st.executeUpdate(sql); //5.释放资源 JDBCUtil.close(conn, st); &#125;&#125; 抽象出JDBCUtil包,复用释放资源代码 1234567891011121314151617181920212223public class JDBCUtil &#123; public JDBCUtil() &#123; &#125; public static void close(Connection conn, Statement st) &#123; try &#123; if (st != null) &#123; st.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 预编译语句对象PreparedStatement对象:又叫做预编译语句对象,是一个包含占位符?的sql模板. 1.PreparedStatement ps= conn.prepareStatement(sql模板);// 传递的是sql模板,不能直接执行. 2.ps.setObject(int parameterIndex, Object x):给占位符?设置值,parameterIndex代表第N个?号,x是具体参数 3.执行sql语句:不能调用父类带参数的方法. 如果直接调用父类的带sql参数方法,会直接将带占位符?的sql模板拿过去执行 123456789101112131415161718192021222324public class Insert &#123; @Test public void TestInsert() throws Exception &#123; Student stu = new Student(null, "小茗同学", 20); //问号表示占位符 String sql = "INSERT INTO student(name,age) VALUES(?, ?)"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.链接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///javaweb", "root", "admin"); //3.获取预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //4.执行SQL语句,给占位符设置值 ps.setObject(1, stu.getName()); ps.setObject(2, stu.getAge()); ps.executeUpdate(); //释放资源 JDBCUtil.close(conn, ps); &#125;&#125; DQL操作ResultSet常用的API: Object getObject(int columnIndex): 根据数据的列的索引获取数据. columnIndex: 表示第几列的意思,从1开始. Object getObject(String columnLabel): 根据数据的列名来获取数据. columnLabel: 表示列名. boolean next(): 是否有下一行, 如果返回是true,表示已经移动到下一行了. 获取单条数据12345678910111213141516171819202122232425public class TestGet &#123; @Test public void testGet() throws Exception &#123; //?表示占位符 String sql = "SELECT * FROM student WHERE id=?"; //注册加载驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //获得数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javaweb", "root", "admin"); //获取预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //给SQL设置值 ps.setObject(1, 5L); ResultSet resultSet = ps.executeQuery(); if (resultSet.next()) &#123; Object obj = resultSet.getObject("name"); System.out.println(obj); &#125; JDBCUtil.close(conn, ps); &#125;&#125; 获取全部数据,用list装1234567891011121314151617181920212223242526272829303132public class TestListAll &#123; @Test public void testListAll() throws Exception &#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); String sql = "SELECT * FROM student"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.获得连接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///javaweb", "root", "admin"); //3.获得预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //执行查询 ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; Student stu = new Student(); long id = rs.getLong("id"); String name = rs.getString("name"); Integer age = rs.getInt("age"); stu.setId(id); stu.setName(name); stu.setAge(age); list.add(stu); &#125; System.out.println(list); JDBCUtil.close(conn, ps); &#125;&#125; DAO规范使用DAO规范对数据库的增删改查,避免重复代码,直接调用DAO方法 DAO的设计1.保存方法 void save(Object obj) 把要保存的信息,封装成一个对象,传递给方法. 用来描述数据库表结构的javabean, 是一个特殊的javabean. ---&gt; domain 2.删除方法 void delete(Long id) 根据主键id来删除数据 3.修改方法 void update(Object obj) 把传递过来的新的信息设置到指定的数据库的记录 4.查询单个 Student get(Long id) 把查询数据封装到domain中. 5.查询多个 List&lt;Student&gt; listAll(); 使用ArrayList装 DAO的规范DAO规范,只要有操作数据库的地方,都需要该规范.主要就是针对包以及类名进行规范. 1.DAO接口. me.cscar.smis.dao:IXxxDAO ====&gt; Xxx 就是domain 2.DAO接口的实现类. me.cscar.smis.dao.impl:StudentDAOImpl 3.domain类: me.cscar.smis.domain:Student 4. 测试类: me.cscar.smis.test:StudentDAOTest 5. 工具类: me.cscar.smis.util:StringUtil/JDBCUtil 开发流程1.创建数据库表 2.根据数据库表来创建domain包以及类.1234567891011121314151617package me.cscar.refactorpro.domain;import lombok.*;import java.math.BigDecimal;@Getter@Setter@AllArgsConstructor@NoArgsConstructor@ToStringpublic class Product &#123; private Long id; private String productName; private BigDecimal salePrice; private BigDecimal cutoff;&#125; 3.根据domain来创建DAO包以及接口.1234567891011121314151617181920212223242526272829303132333435363738394041424344package me.cscar.refactorpro.dao;import me.cscar.refactorpro.domain.Product;import java.util.List;public interface IProductDAO &#123; /** * 增加 * * @param pro */ void save(Product pro); /** * 删除 * * @param id */ void delete(Long id); /** * 修改 * * @param pro */ void update(Product pro); /** * 查询指定 * * @param id * @return */ Product get(Long id); /** * 查询全部 * * @return */ List getAll();&#125; 4.根据DAO接口来生成实现类.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190package me.cscar.refactorpro.dao.impl;import me.cscar.refactorpro.dao.IProductDAO;import me.cscar.refactorpro.domain.Product;import me.cscar.refactorpro.util.JDBCutil;import java.math.BigDecimal;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class ProductDAOImpl implements IProductDAO &#123; public static ProductDAOImpl getInstance() &#123; return new ProductDAOImpl(); &#125; /** * 增加 * * @param pro */ @Override public void save(Product pro) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "INSERT INTO t_product (productName,salePrice,cutoff) VALUES (?,?,?)"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, pro.getProductName()); ps.setObject(2, pro.getSalePrice()); ps.setObject(3, pro.getCutoff()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(conn, ps); &#125; &#125; /** * 删除 * * @param id */ @Override public void delete(Long id) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "DELETE FROM t_product WHERE id = ?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, id); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBCutil.close(conn, ps); &#125; /** * 修改 * * @param pro */ @Override public void update(Product pro) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "UPDATE t_product SET productName=?,salePrice=?,cutoff=? WHERE id=?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, pro.getProductName()); ps.setObject(2, pro.getSalePrice()); ps.setObject(3, pro.getCutoff()); ps.setObject(4, pro.getId()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(conn, ps); &#125; &#125; /** * 查询指定 * * @param id * @return */ @Override public Product get(Long id) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; String sql = "SELECT * FROM t_product WHERE id = ?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, id); rs = ps.executeQuery(); while (rs.next()) &#123; Product pro = new Product(); String productName = rs.getString("productName"); BigDecimal salePrice = rs.getBigDecimal("salePrice"); BigDecimal cutoff = rs.getBigDecimal("cutoff"); Long proid = rs.getLong("id"); pro.setId(proid); pro.setProductName(productName); pro.setSalePrice(salePrice); pro.setCutoff(cutoff); return pro; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBCutil.close(conn, ps); &#125; throw new RuntimeException("查询错误"); &#125; /** * 查询全部 * * @param pro * @return */ @Override public List getAll() &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; String sql = "SELECT * FROM t_product"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); rs = ps.executeQuery(); List&lt;Product&gt; list = new ArrayList&lt;&gt;(); while (rs.next()) &#123; Product pro = new Product(); String productName = rs.getString("productName"); BigDecimal salePrice = rs.getBigDecimal("salePrice"); BigDecimal cutoff = rs.getBigDecimal("cutoff"); Long proid = rs.getLong("id"); pro.setId(proid); pro.setProductName(productName); pro.setSalePrice(salePrice); pro.setCutoff(cutoff); list.add(pro); &#125; return list; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); JDBCutil.close(conn, ps); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; throw new RuntimeException("查询出错"); &#125;&#125; 5.根据测试先行,根据DAO接口生成测试类.完成测试类.12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.refactorpro.test;import me.cscar.refactorpro.dao.impl.ProductDAOImpl;import me.cscar.refactorpro.domain.Product;import me.cscar.refactorpro.util.JDBCutil;import org.junit.Test;import java.math.BigDecimal;import java.sql.Connection;import java.util.List;public class ProductDAOTest &#123; @Test public void save() &#123; Product pro = new Product(null, "mac", new BigDecimal("15000"), new BigDecimal("0.9")); ProductDAOImpl.getInstance().save(pro); &#125; @Test public void delete() &#123; ProductDAOImpl.getInstance().delete(6L); &#125; @Test public void update() &#123; Product newpro = new Product(5L, "suffer", new BigDecimal("14000"), new BigDecimal("0.99")); ProductDAOImpl.getInstance().update(newpro); &#125; @Test public void get() &#123; Product product = ProductDAOImpl.getInstance().get(4L); System.out.println(product); &#125; @Test public void getAll() &#123; List all = ProductDAOImpl.getInstance().getAll(); System.out.println(all); &#125;&#125; 抽取和完善JDBCutil新建配置文件,properties1234ClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql:///javawebuserName=xxxpassword=xxx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package me.cscar.refactorpro.util;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;import java.util.Properties;public class JDBCutil &#123; private static Properties pre = new Properties(); static &#123; InputStream is = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("prodb.properties"); try &#123; pre.load(is); Class.forName(pre.getProperty("ClassName")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; Connection conn = DriverManager.getConnection(pre.getProperty("url"), pre.getProperty("userName"), pre.getProperty("password")); return conn; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(Connection conn, PreparedStatement ps) &#123; try &#123; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 预编译语句对象原理避免了sql语句字符串拼接.有的数据库有DBMS有缓冲区,预编译语句对象可以提交效率. mysql不支持 DBMS1.安全检查2.语义分析检查语句在缓存中是否存在3.编译SQL4.执行SQL 有缓存区会存储编译好的sql模板,? 使用预编译语句对象可以防止SQL注入 其他问题jdbc驱动8.0以上版本时区,少一天连接数据库的url加上1serverTimezone=Asia/Shanghai]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pocketbook]]></title>
    <url>%2F2019%2F04%2F04%2Fpocketbook%2F</url>
    <content type="text"><![CDATA[pocketbook基于Swing和JDBC开发的桌面程序,JavaSE基础的综合.使用git进行版本管理,合作开发 github地址:https://github.com/Cscar2H/pocketbook 数据库和表1create database pocketbook 根据需求,设计了3个表 1.配置表信息 config 用于保存预算和用于备份还原的路径 2.消费分类表 category 用于保存消费分类 3.记录表 record 用于保存每一笔的消费记录,并且会用到消费分类 config表使用键值对保存了key_和value,例如key=”budget” value=”200”,表示预算是200元 category表name表示分类的类名 record表spend 表示单次花费cid 对应的消费分类表的中记录的idcomment 备注信息date 日期分类表和记录表之间的关系是一对多,record表中cid就是外键 功能开发主界面:在startup包下新建一个类Bootstrap,这个类专门负责启动程序,作为一个程序的启动入口,可以执行一些初始化操作. 使用了SwingUtilities.invokeAndWait的方式启动图形界面同时使用了调度线程,保证创建和显示界面的操作都在同一个线程中123456789SwingUtilities.invokeAndWait(new Runnable() &#123; @Override public void run() &#123; //是否显示主窗体 MainFrame.instance.setVisible(true); //在主界面中显示SpendPanel的界面 MainPanel.instance.workingPanel.show(SpendPanel.instance); &#125; &#125;); 使用监听器界面效果创建一个独立的监听器类ToolBarListener,实现接口ActionListener,重写了该接口中的actionPerformed方法。 在工具栏里的每一个按钮都使用一个这样的监听器. 通过ActionEvent.getSource()获取事件是哪个按钮发出来的.根据不同的按钮,发出切换不同的功能面板.1234567891011121314151617181920212223242526272829public class ToolBarListener implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; MainPanel p = MainPanel.instance; JButton b = (JButton) e.getSource(); if (b == p.bReport) &#123; p.workingPanel.show(ReportPanel.instance); &#125; if (b == p.bCategory) &#123; p.workingPanel.show(CategoryPanel.instance); &#125; if (b == p.bSpend) &#123; p.workingPanel.show(SpendPanel.instance); &#125; if (b == p.bRecord) &#123; p.workingPanel.show(RecordPanel.instance); &#125; if (b == p.bConfig) &#123; p.workingPanel.show(ConfigPanel.instance); &#125; if (b == p.bBackup) &#123; p.workingPanel.show(BackupPanel.instance); &#125; if (b == p.bRecover) &#123; p.workingPanel.show(RecoverPanel.instance); &#125; &#125;&#125; 实例化一个ToolBarListener监听器,给工具栏的按钮添加listener监听器对象.在MainPanel面板中使用监听器123456789101112private void addListener() &#123; ToolBarListener listener = new ToolBarListener(); bSpend.addActionListener(listener); bRecord.addActionListener(listener); bCategory.addActionListener(listener); bReport.addActionListener(listener); bConfig.addActionListener(listener); bBackup.addActionListener(listener); bRecover.addActionListener(listener);&#125; 初始化数据库配置效果 业务类ConfigService业务类,这个类是监听器直接调用的类,然后再通过ConfigService去调用ConfigDAO。 之前DAO是直接链接数据库,在操作数据库之前,需要对一些数据进行预处理,这些就可以放在业务类里进行. ConfigService 1.初始化 因为设置信息里有两个数据，一个是预算，一个是Mysql路径。 这两个信息，无论如何都应该是存在数据库中的。 所以会调用init把他们俩初始化。 2.init(String key, String value) 方法 首先根据key去查找，如果不存在，就使用value的值插入一条数据。 3.get(String key) 根据键获取相应的值 4.update(String key, String value) 更新键对应的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package me.cscar.service;import me.cscar.dao.ConfigDAO;import me.cscar.domain.Config;public class ConfigService &#123; public static final String BUDGET = "budget"; public static final String PATH = "mysqlPath"; public static final String DEFAULT_BUDGET = "500"; static ConfigDAO dao= new ConfigDAO(); static&#123; init(); &#125; public static void init()&#123; init(budget, default_budget); init(mysqlPath, ""); &#125; private static void init(String key, String value) &#123; Config config= dao.getByKey(key); if(config==null)&#123; Config c = new Config(); c.setKey(key); c.setValue(value); dao.add(c); &#125; &#125; public String get(String key) &#123; Config config= dao.getByKey(key); return config.getValue(); &#125; public void update(String key, String value)&#123; Config config= dao.getByKey(key); config.setValue(value); dao.update(config); &#125; public int getIntBudget() &#123; return Integer.parseInt(get(budget)); &#125; &#125; ConfigListener 监听器ConfigListener，这个监听器是用在更新按钮上的 1.判断输入的预算是否为整数 2.判断输入的MySQL 3.如果判断通过,就调用业务类ConfigService更新数据 12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.gui.listener; import me.cscar.gui.panel.ConfigPanel;import me.cscar.gui.util.GUIUtil;import me.cscar.service.ConfigService;import java.awt.event.ActionEvent; import java.awt.event.ActionListener;import java.io.File; import javax.swing.JOptionPane; public class ConfigListener implements ActionListener&#123; @Override public void actionPerformed(ActionEvent e) &#123; ConfigPanel p = ConfigPanel.instance; //判断 if(!GUIUtil.checkNumber(p.tfBudget, "预算")) &#123; return; &#125; String mysqlPath =p.tfMysqlPath.getText(); //判断MySQL路径是否正确 if(0!=mysqlPath.length())&#123; File commandFile = new File(mysqlPath,"bin/mysql"); if(!commandFile.exists())&#123; JOptionPane.showMessageDialog(p, "Mysql路径不正确"); p.tfMysqlPath.grabFocus(); return; &#125; &#125; ConfigService cs= new ConfigService(); cs.update(ConfigService.budget,p.tfBudget.getText()); cs.update(ConfigService.mysqlPath,mysqlPath); JOptionPane.showMessageDialog(p, "设置修改成功"); &#125; &#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>desktop</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F04%2F03%2FMySQL%2F</url>
    <content type="text"><![CDATA[SQLSQL：结构化查询语言(Structured Query Language)SQL包含6个部分 1.数据库查询语言(DQL) 2.数据操作语言(DML) 3.事务处理语言(TCL) 4.数据控制语言(DCL) 5.数据定义语言(DDL) MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。MyISAM：拥有较高的插入，查询速度，但不支持事务，不支持外键。InnoDB：支持事务，支持外键，支持行级锁定，性能较低。 InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但对比MyISAM，处理效率差，且会占用更多的磁盘空间以保留数据和索引。 ORM思想: 对象关系映射 –&gt; Java的对象和关系型数据库的映射 表 面向对象 表结构 类 表的列 属性 表的行 对象 MySQL命令行1.sudo mysql.server start : 启动数据库 2.sudo mysql.server stop : 关闭数据库 3.mysql -u root -p : 进入数据库(我的版本信息:Server version: 8.0.12 Homebrew) 4.use mysqlname; : 进入数据库 5.show tables; : 查看表 6.desc table_name; : 查看表结构 7.create table table_name : 创建表 8.drop table table_name : 删除表 MySQL列的常见类型 Java MySQL int INT long BIGINT BigDecimal DECIMAL boolean BIT java.util.Date DATE/DATETIME String VARCHAR 表约束 1.非空约束：NOT NULL(NK)，不允许某列的内容为空。 2.设置列的默认值：DEFAULT。 3.唯一约束：UNIQUE(UK)，在该表中，该列的内容必须唯一。 4.主键约束：PRIMARY KEY(PK)， 非空且唯一。 5.主键自增长：AUTO_INCREMENT，从1开始，步长为1。(MySQL特有) 6.外键约束：FOREIGN KEY(FK)，A表中的外键列的值必须参照于B表中的某一列(B表主键)。 数据操作(DML)保存操作 1INSERT INTO table_name(column1,column2,colum3...) VALUES (value1, value2, value3); 更新操作 1UPDATE table_name SET `columnName` = &apos;value&apos; WHERE (`condition` = &apos;num&apos;); 删除操作 1DELETE FROM table_name WHERE (`condition` = &apos;num&apos;); 数据查询操作(DQL)基本语法1SELECT * FROM table_name; 说明：SELECT 选择查询列表,列与列之间用逗号隔开FROM 提供数据源(表、视图或其他的数据源) 如果为 * 和创建表时的顺序一致。可以自己调整顺序，在select后边加上要查询的列名。 消除结果中重复的数据1SELECT DISTINCT 列名.. FROM table_name; 数学运算 数学运算:对NUMBER型数据可以使用算数操作符创建表达式（+ - * /） 对DATE型数据可以使用部分算数操作符创建表达式 （+ -） 运算符优先级： 1、乘法和除法的优先级高于加法和减法 2、同级运算的顺序是从左到右 3、表达式中使用&quot;括号&quot;可强行改变优先级的运算顺序 设置显示格式: 一旦遇到变量和常量拼接就必须使用CONCAT函数 把多个值以字符串拼接的形式拼在一起,可以使用函数concat(...) 设置列名的别名 1.改变表的名字； 2.用于表示计算结果的含义； 3.作为列的别名； 4.如果别名中使用特殊字符，或者是强制大小写敏感，或有空格时，都需加引号；别名以后都不加引号.加了引号的别名导致排序失效. 过滤查询 过滤查询比较运算符 运算符 含义 = 等于 &gt; 大于 &gt;= 大于或等于 &lt; 小于 &lt; 小于 &lt;= 小于或等于 !=(&lt;&gt;) 不等于 逻辑运算符 运算符 含义 AND(&amp;&amp;) 如果组合的条件都是TRUE,返回TRUE OR(&#124;&#124;) 如果组合的条件之一是TRUE,返回TRUE NOT(!) 如果下面的条件是FALSE,返回TRUE 范围查询 使用BETWEEN运算符显示某一值域范围的记录，这个操作符最常见的使用在数字类型数据的范围上，但对于字符类型数据和日期类型数据同样可用。 格式： SELECT &lt;columnList&gt; FROM table_name WHERE 列名 BETWEEN minvalue AND maxvalue：闭区间。 集合查询 使用IN运算符，判断列的值是否在指定的集合中。 格式： WHERE 列名 IN (值1，值2....); 空值查询 IS NULL:判断列的值是否为空。 空值是特指没有值的列 格式：WHERE 列名 IS NULL; 模糊查询 使用LIKE运算符执行通配查询，查询条件可包含文字字符或数字： %通配符：可表示任意个数的任意字符。 _通配符：可表示一个任意字符。 通配符：用来实现匹配部分值得特殊字符。 结果排序使用ORDER BY子句将记录排序ASC升序DESC降序ORDER BY 子句出现在SELECT语句的最后。格式：SELECT FROM table_nameWHERE 条件ORDER BY 列名1 [ASC/DESC],列名2 [ASC/DESC]…;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识XML]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%88%9D%E8%AF%86XML%2F</url>
    <content type="text"><![CDATA[XMLXML概述使用XML文件,可以保存复杂的数据,数据结构清晰(树状结构) 传输数据是一种通用的数据格式 传递数据,作为配置文件存在 XML语法 版本 &lt;?xml version=&quot;1.0&quot;?&gt; 用encoding属性说明文档所使用的字符编码，默认为UTF-8。保存在磁盘上的文件编码要与声明的编码一致。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 用standalone属性说明文档是否独立，即是否依赖其他文档。 &lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt; 标签的属性,描述该标签 &lt;linkman 属性名=&quot;属性值&quot;&gt; 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;contacts&gt; &lt;person id="1"&gt; &lt;name&gt;蔡徐坤&lt;/name&gt; &lt;address&gt;荷兰&lt;/address&gt; &lt;email&gt;kk@nmsl&lt;/email&gt; &lt;age&gt;17&lt;/age&gt; &lt;/person&gt; &lt;person id="2"&gt; &lt;name&gt;孙笑川&lt;/name&gt; &lt;address&gt;日本&lt;/address&gt; &lt;email&gt;cc@nmsl&lt;/email&gt; &lt;age&gt;18&lt;/age&gt; &lt;/person&gt;&lt;/contacts&gt; DOM解析(Document Object Model)文档对象模型,可以将xml的操作当做是操作对象 特点: 在加载XML文档的时候,会一次性把所有的信息加载到内存中(DOM树) 使用document这一对象来描述,剩下的操作都是操作内存中的对象 缺点: 如果XML文档内容比较多,文件比较大,一加载到内存中会导致,内存溢出 注意: 1.使用DOM解析,导入的类都是在org.w3c.dom包中.如果发现让你强转.意识到可能导错包了. 2.在XML中,一切皆节点 ####获取Document对象 三个类 Document DocumentBuilder DocumentBuilderFactory newDocumentBuilder:单例设计模式,需要通过自身的newInstance方法,获取一个新的实例 DocumentBuilder:需要通过newDocumentBuilder的实例中的newDocumentBuilder获取对象,该类重写了parse方法和newDocument方法 Document:接口,不能创建对象.抽象的parse方法和newDocument方法 12345678910111213141516171819202122232425262728package me.cscar.DOM.object;import org.junit.Test;import org.w3c.dom.Document;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.File;import java.io.InputStream;public class GetDOMObject &#123; @Test public void getObject() throws Exception &#123; File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.newDocument(); InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); Document doc1 = db.parse(is); //Document doc = db.parse(file); System.out.println(doc.equals(doc1)); &#125;&#125; ####常用API(增删改查)常用的API: Document对象: Element getDocumentElement(): 获取根节点. Element getElementById(String elementId) :根据唯一ID获取节点. Element对象: NodeList getElementsByTagName(String name):根据标签名获取到标签列表. String getAttribute(String name) :根据属性名,获取属性值 void setAttribute(String name, String value) :设置属性名和属性值. Node 对象: String getTextContent(): 返回当前节点的文本内容. void setTextContent(String value): 设置文本内容. ADD1234567891011121314151617181920212223242526272829303132333435363738394041424344package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;public class Add &#123; @Test public void useAdd() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //创建document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根节点 Element element = doc.getDocumentElement(); //创建节点 Element person = doc.createElement("person"); person.setAttribute("id", "4"); Element name = doc.createElement("name"); Element email = doc.createElement("email"); Element address = doc.createElement("address"); Element age = doc.createElement("age"); //创建层级关系 element.appendChild(person); person.appendChild(name); person.appendChild(email); person.appendChild(address); person.appendChild(age); //给节点设置数据 name.setTextContent("蛤蛤"); email.setTextContent("haha@china.com"); address.setTextContent("中国"); age.setTextContent("90"); SynchroFile.synchor(doc); &#125;&#125; REMOVE123456789101112131415161718192021222324252627282930313233343536373839package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 删除操作 */public class Remove &#123; @Test public void useRemove() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //获取document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根节点 Element de = doc.getDocumentElement(); //person标签 NodeList person = de.getElementsByTagName("person"); //获取第三个人的标签 Element p3 = (Element) person.item(2); System.out.println(p3.getAttribute("id")); p3.getParentNode().removeChild(p3); //同步操作,把修改的document对象写入 SynchroFile.synchor(doc); &#125;&#125; QUERY12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 查询操作 */public class Query &#123; @Test public void useQuery() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); Element de = doc.getDocumentElement(); //第1个人的信息节点 NodeList person = de.getElementsByTagName("person"); System.out.println("长度是"+person.getLength()); Element item = (Element) person.item(2); //获取ID编号 //System.out.println(item.getAttribute("id")); //找到第1个联系人的name节点 Element nameNode = (Element) item.getElementsByTagName("name").item(0); int re = item.getElementsByTagName("name").getLength(); //System.out.println(re); String name = nameNode.getTextContent(); System.out.println(name); //获取所有人的信息 for (int i = 0; i &lt; person.getLength(); i++) &#123; Element item1 = (Element) person.item(i); String name1 = item1.getElementsByTagName("name").item(0).getTextContent(); String email = item1.getElementsByTagName("email").item(0).getTextContent(); String address = item1.getElementsByTagName("address").item(0).getTextContent(); String age = item1.getElementsByTagName("age").item(0).getTextContent(); System.out.println(name1 + '\n' + email + '\n' + address + '\n' + age); System.out.println("-------------"); &#125; &#125;&#125; UPDATE12345678910111213141516171819202122232425262728293031323334353637package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 修改操作 */public class Update &#123; @Test public void useUpdate() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //获取document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根标签 Element element = doc.getDocumentElement(); //获取第3个人信息 Element person = (Element) element.getElementsByTagName("person").item(2); //获取name标签 Element name = (Element) person.getElementsByTagName("name").item(0); //修改name标签 name.setTextContent("包包"); //调用同步方法 SynchroFile.synchor(doc); &#125;&#125; 同步操作12345678910111213141516171819202122232425262728293031323334package me.cscar.DOM.frequently;import org.w3c.dom.Document;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.File;import java.io.InputStream;/** * 增删改的同步操作 * 把修改的document真正写入 */public class SynchroFile &#123; public static void synchor(Document doc) throws Exception &#123; File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); //获取工厂对象 TransformerFactory factory = TransformerFactory.newInstance(); //获取转换器 Transformer transformer = factory.newTransformer(); //调用转换器中的方法 Source src = new DOMSource(doc); Result target = new StreamResult(file); transformer.transform(src, target); &#125;&#125; 创建新的XML12345678910111213141516171819202122232425262728293031323334353637383940package me.cscar.DOM.create;import me.cscar.DOM.frequently.SynchroFile;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.File;public class Create &#123; @Test public void CreateDoc() throws Exception &#123; //File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); File newFile = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML_Copy.xml"); Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument(); //创建一个根节点 Element element = doc.createElement("contacts"); //添加根节点 doc.appendChild(element); TransformerFactory factory = TransformerFactory.newInstance(); Transformer tf = factory.newTransformer(); Source src = new DOMSource(doc); Result target = new StreamResult(newFile); tf.transform(src, target); &#125;&#125; ####XML约束(了解)]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>配置文件</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaUtility]]></title>
    <url>%2F2019%2F03%2F31%2FJavaUtility%2F</url>
    <content type="text"><![CDATA[LombokJavaBean规范代码生成工具]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>utility</tag>
        <tag>tool</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaBean]]></title>
    <url>%2F2019%2F03%2F30%2FJavaBean%2F</url>
    <content type="text"><![CDATA[JavaBean在Java中一个非常重要的组件,可重用.如果想要在多个模块中重用,必须遵循一定的规范. 1.必须使用public修饰 2.必须提供公共的无参数构造器 3.字段都是私有化的 4.提供get和set方法 JavaBean中重要成员方法 事件 属性:property,不是字段,而是通过get/set方法推导出来的 12345678910111213141516171819class HelloWorld &#123; private String name; /** * 标准的get方法 * get之后首字母小写,称之为属性 * */ public String getName() &#123; return name; &#125; /** * 标准的set方法 * set之后首字母大写,称之为属性 * */ public void setName(String name) &#123; this.name = name; &#125;&#125; 内省操作内省机制 核心类:Introspector 专门用来操作JavaBean的属性 核心方法 BeanInfo getBeanInfo(class&lt;?&gt; beanclass) 常用API java.beans.Introspector类常用API: static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass) : 获取字节码对象对应的JavaBean信息 static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass, Class&lt;?&gt; stopClass) java.beans.BeanInfo接口常用API: PropertyDescriptor[] getPropertyDescriptors() : 获取所有的属性描述器 java.beans.PropertyDescriptor类常用API: String getName() : 获得属性的名称 Class&lt;?&gt; getPropertyType() : 获得属性的类型 Method getReadMethod() : 获得用于读取属性值的方法 Method getWriteMethod() : 获得用于设置属性值的方法 JavaBean和Map的转换从浏览器传递过来的数据,服务器获取数据后.需要将数据放到一个对象中,传递的数据类似于key=value的形式.所以需要将map转换成JavaBean 都具有相似的结构 转换操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package me.cscar.con.conversion;import org.junit.Test;import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class JavaBeanMap &#123; @Test public void test() throws Exception &#123; //Person p = new Person("蛤蛤", 90); Class&lt;Person&gt; clz = Person.class; Constructor&lt;Person&gt; con = clz.getConstructor(String.class, Integer.class); Person p = con.newInstance("蛤蛤", 90); Map&lt;String, Object&gt; map = bean2map(p); System.out.println(map); System.out.println(map2bean(map, clz)); &#125; /** * JavaBean对象转换成map * 把JavaBean对象中的属性值,获取出来,放在map中 */ public static Map&lt;String, Object&gt; bean2map(Object obj) throws Exception &#123; BeanInfo beanInfo = Introspector.getBeanInfo(obj.getClass(), Object.class); //创建map对象 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Method m = ele.getReadMethod(); Object value = m.invoke(obj); map.put(key, value); &#125; return map; &#125; /** * map转换成JavaBean对象 * 把map的数据取出来,放到JavaBean对应的属性上 */ public static Object map2bean(Map&lt;String, Object&gt; map, Class clz) throws Exception &#123; //使用字节码对象创建对象 Object obj = clz.newInstance(); //获取字节码对象对应JavaBean信息 BeanInfo beanInfo = Introspector.getBeanInfo(clz, Object.class); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); //遍历 for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Object value = map.get(key); Method m = ele.getWriteMethod(); m.invoke(obj, value); &#125; return obj; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>JavaBean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Annotation注解]]></title>
    <url>%2F2019%2F03%2F30%2FAnnotation%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解(标签)注解的概述解决xml臃肿的问题 在Java5之后,开始对元数据的支持,就是Annotation(注解) 可以用来描述其他数据的一种数据,可以赋予其他数据一些功能 常用注解: @Override 限定覆写父类方法 @Deprecated 标记已过时,不推荐使用.在JDK1.5之前,使用文档注释来标记过时 @SuppressWarings 抑制编译器发出的警告,@SuppressWarings(value=&quot;all&quot;) @SafeVarargs 抑制堆污染警告(Java7开始出现的) @Functionallnterface 标记该接口是一个函数接口(Java8开始出现的) 注解的定义:123public @interface Test&#123; //抽象方法 属性&#125; 注解的使用语法: @注解名(属性名1=属性值1,属性名2=属性值2,...) 注解想要具有某一些功能,最重要的是需要三方程序的参与,必须使用反射来给注解赋予功能 元注解注解是用来约束其他程序元素的(字段,方法,),元注解是用来约束注解的 @Target: 表示注解可以贴在哪些位置(类,方法上,构造器上等等) @Retention: 表示注解可以保存在哪一个时期,存活时间 @Documented: 使用@Documented标注的标签会保存到API文档中 @Inherited: @Inherited标注的标签可以被子类所继承. 自定义注解语法格式 1. 可以为属性设置默认值, 使用default. 2. 如果必须要写的属性(可以有多个,其他的都有默认值),并且这个属性的名字叫value, 可以省略属性名,直接写值. 3. 属性的类型只能是基本类型,String,Class,注解,枚举,以及其数组类型. 4. 抽象方法不能有参数 使用注解是一种硬编码方式**]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Annotation</tag>
        <tag>注解</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置文件]]></title>
    <url>%2F2019%2F03%2F30%2F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[配置文件使用配置文件经常修改,从源文件的编写到部署的过程,都需要重新修改. 解决方案: 把配置保存在一个文件中, Java代码可以通过流(stream)动态的读取 真正解决的问题: 代码中的硬编码,写死到Java代码中,而且是经常改动的值 常用的配置文件1.properties文件. 文件后缀名.properties,用来保存一些简单的数据.保存格式:key=value 重复的key表示更新操作,不能存多个用户信息 2.xml文件 文件后缀名.xml,用来保存一些复杂的数据,按照清晰的格式保存(结构化) properties文件的基本使用常见的操作 创建properties文件,并存储数据 1.文件存放在resource文件夹中. 2.在该配置文件中,所有数据到Java后,都是String类型 3.等号不需要空格 123#这是注释,保存格式:key=valueusername=rootpassword=admin 使用jdk提供好的工具类来加载和获取 void load(InputStream inStream):通过输入流把数据加载到properties对象中 String getProperty(String key):通过指定的key获取value值 使用相对路径12//默认去bin中找Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;user.properties&quot;); 123456789101112131415161718public class PropertiesTest &#123; @Test public void loadProperties() throws Exception &#123; //创建properties对象 Properties pt = new Properties(); //获取相对路径 InputStream in = Thread.currentThread(). getContextClassLoader(). getResourceAsStream("user.properties"); //加载 pt.load(in); //获取 String username = pt.getProperty("username"); System.out.println(username); String password = pt.getProperty("password"); System.out.println(password); &#125;&#125; 反射的优势反射的应用场景 更多的是使用一个全限定名来创建对象(反射) 为了解决硬编码,为了降低代码的耦合性,一般将具体的实现类配置到配置文件中 1234567891011121314151617181920212223package me.cscar.con.reflect;import org.junit.Test;import java.io.InputStream;import java.util.Properties;public class Math implements IMath &#123; @Test public void testMath() throws Exception &#123; Properties ps = new Properties(); InputStream is = Thread. currentThread(). getContextClassLoader(). getResourceAsStream("math.properties"); ps.load(is); //forName获取properties文件中的全限定名称,并且创建对象 IMath math = (IMath) Class.forName(ps.getProperty("clssName")) .newInstance(); //getClass获取math的全限定名 System.out.println(math.getClass()); &#125;&#125; 优点: 1.反射提高了程序的灵活性和扩展性。 2.降低耦合性，提高自适应能力。 3.它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 1.性能问题：使用发射基本上是一种在运行期间解析字节码操作，效率较低，一般程序不建议使用，对灵活性和拓展性要求较高的工具或框架上使用较多。 2.代码复杂性：反射发生在运行期，程序员无法在源代码中看到程序的逻辑，反射代码比相应的直接的代码更复杂，因而会带来维护的问题 框架中大量使用反射,用来提高框架的扩展性和灵活性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JunitTest]]></title>
    <url>%2F2019%2F03%2F29%2FJunitTest%2F</url>
    <content type="text"><![CDATA[Junit回归测试框架的基本使用测试先行的思想 单元测试Junit属于白盒测试 定义一个测试方法:1.测试方法,必须是公共的无参数无返回的方法.建议使用test开头. 2.想要测试哪个方法,需要在该方法上贴一个注解@Test 12345678import org.junit.Test;public class HelloTest &#123; @Test public void addTest() &#123; System.out.println("添加用户信息"); &#125;&#125; Junit细节:更多是针对接进行测试,要测试一个接口中的方法,必须按照规范流程 定义一个接口:1234567891011121314151617181920212223242526package me.cscar.Junit;/** * 接口规范:文档注释 * 数学运算的加减乘除方法 * * @author cscar * @date 2019/3/29 */public interface IMath &#123; /** * 计算两个数相加 * @param a * @param b * @return 和 */ int add(int a, int b); /** * 计算两个数相除 * @param a * @param b * @return 商 */ int div(int a, int b);&#125; 根据接口生成实现类:1234567891011121314151617package me.cscar.Junit;/** * 实现IMath接口 */public class Math implements IMath &#123; @Override public int add(int a, int b) &#123; return a + b; &#125; @Override public int div(int a, int b) &#123; return a / b; &#125;&#125; 根据接口生成实现类:1234567891011121314151617181920212223242526package me.cscar.Junit;import org.junit.Test;import static org.junit.Assert.*;//测试数学运算public class MathTest &#123; /** * 面向接口,创建数学类对象 */ private IMath math = new Math(); @Test public void add() &#123; int result = math.add(3, 4); System.out.println(result); &#125; @Test public void div() &#123; int result = math.div(10, 0); System.out.println(result); &#125;&#125; 断言:猜测一个程序结果是否是期望结果 1.:Assert.assertEquals(message, expected, actual):比较的值 三个参数: message: 断言失败的提示信息,断言成功不会显示. expected: 期望值 actual: 真实值 2.:Assert.assertSame(message, expected, actual):比较地址,是同一个对象 Assert.assertNotSame(message, expected, actual):断言不是同一个对象 3.:Assert.assertTrue(message, condition):断言condition应该为TRUE. Assert.assertFalse(message, condition):断言condition应该为FALSE. 4.:Assert.assertNull(message, object):断言对象object为null. Assert.assertNotNull(message, object):断言对象object不为null. 5.:@Test(expected=ArithmeticException.class) 期望该方法报错ArithmeticException. 6.:@Test(timeout=400) 期望该方法在400毫秒之内执行完成. 123456789101112@Testpublic void add() &#123; int result = math.add(3, 4); //System.out.println(result); Assert.assertEquals(&quot;3+4我都能算错?&quot;, 8, result);&#125;@Test(expected = ArithmeticException.class)public void div() &#123; int result = math.div(10, 0); System.out.println(result);&#125; Junit自动化操作自动初始化自动销毁 1.@Test:需要测试的方法,必须贴Test注解.并且测试方法必须是公共无参数无返回的方法. 2.@Before:在所有的测试方法之前,都会执行的代码 3.@After:在所有的测试方法之后,都会执行的代码 4.@BeforeClass:在所有操作之前执行,只执行一次. 5.@AfterClass:在所有操作之前执行,只执行一次. 1234567891011121314151617181920212223242526272829303132333435package me.cscar.junit.work;import org.junit.*;public class WorkTest &#123; @Test public void query() &#123; System.out.println("查询用户信息"); &#125; @Test public void delete() &#123; System.out.println("删除用户信息"); &#125; @Before public void init() &#123; System.out.println("登录"); &#125; @After public void story() &#123; System.out.println("注销"); &#125; @BeforeClass public static void BeforeClass() &#123; System.out.println("所有操作之前"); &#125; @AfterClass public static void AfterClass() &#123; System.out.println("所有操作之后"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Junit</tag>
        <tag>测试类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect反射]]></title>
    <url>%2F2019%2F03%2F29%2FReflect%2F</url>
    <content type="text"><![CDATA[反射为什么要使用反射1234567891011121314151617181920//定义一个类class Person&#123; public Object work()&#123; //假设看不到源码,无法获取真实类型 return new Date(); &#125; //调用work方法 @Test public void testWork()&#123; Person p = new Person(); Object obj = new Person(); //返回值是一个对象,可以继续调用该对象的方法. Date d = (Date)obj; //打印本地的时间风格,但是却不知道应该用什么来接收(不知道返回的是date) String str = d.toLocalString(); System.out.println(str); &#125;&#125; Person类是别人提供好的字节码文件.看不到源码是不能直接强转的. 不爽:我都已经获取到真正的对象了,居然不能知道他的真实类型. 什么是反射:通过字节码(Class)对象,动态的获取该字节码中的成员(构造器,方法,字段,父类,包…) 字节码对象(Class):将多个Class类抽象出来,形成一个字节码的结构(everything is object) 当JVM加载完字节码后.会使用一个对象,来描述该字节码文件的结构.该对象包含操作字节码中成员的方法. 字节码对象,是JVM加载字节码文件的时候,给我们创建的一个对象,一份字节码,只会创建一个字节码对象. 获取字节码对象的三种方法:1.通过Class类的forName来获取. public static Class&lt;?&gt; forName(String className):根据全限定名来获取字节码对象. 全限定名:包名.类名.指定到唯一的一个类上. 2.所有的对象,都有一个公共的方法.getClass. public final Class&lt;?&gt; getClass(): 通过对象返回字节码对象. 3.任何类型都有一个class属性. int.class / Person.class/ 1234567891011121314151617181920212223242526272829303132package me.cscar.reflect.getClassObject;import org.junit.Test;public class GetClassTest &#123; @Test public void getClassObject() throws Exception &#123; //1.通过forName静态方法获取,抛出异常 Class clz = Class.forName("me.cscar.reflect.getClassObject.Person"); //2.通过对象.getClass()方法获取 Object obj = new Person(); Class clz1 = obj.getClass(); //3.任何类型都有一个class属性 Class clz2 = Person.class; //class me.cscar.reflect.getClassObject.Person System.out.println(clz); //true System.out.println(clz == clz1); //true System.out.println(clz == clz2); //int类型的class属性不等于integer的class属性,结果为false System.out.println(int.class == Integer.class); //integer的包装类型是int,结果为true System.out.println(int.class == Integer.TYPE); //class [Ljava.lang.String; System.out.println(String[].class); &#125;&#125; 构造器的操作获取构造器获取单个构造器 parameterTypes:参数类型 想要定位到一个构造器,必须要指明构造器的参数列表. 1.获取单个构造器: public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes):获取public的指定的构造器 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) :获取不管权限的构造器 2.获取所有构造器: Constructor&lt;?&gt;[] getConstructors() :获取所有public 的构造器 Constructor&lt;?&gt;[] getDeclaredConstructors() :获取所有构造器,不管权限. 123456789101112131415161718192021222324252627282930313233343536package me.cscar.reflect.getConstructor;import org.junit.Test;import java.lang.reflect.Constructor;public class GetConstructor &#123; @Test public void testGetConstructor() throws Exception &#123; //创建字节码对象 Class clz = Class.forName("me.cscar.reflect.getConstructor.Person"); //1.获取所有的public构造器 Constructor[] cons = clz.getConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //2.获取所有的构造器 cons = clz.getDeclaredConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //3.获取无参数构造器 Constructor con = clz.getConstructor(); //System.out.println(con); //4.获取带参数的public构造器 Constructor conagsP = clz.getDeclaredConstructor(Long.class, String.class, int.class); //System.out.println(conagsP); //5.获取带参数的构造器(暴力反射) Constructor conage = clz.getDeclaredConstructor(String.class, int.class); System.out.println(conage); &#125;&#125; 通过构造器创建对象 public T newInstance(Object... initargs):通过构造器,创建对象. initargs:实际参数. 如果想要调用私有的成员.必须要先设置可以访问. public void setAccessible(boolean flag): 设置为true. 12345678910111213141516171819202122232425262728293031323334package me.cscar.reflect.createObject;import org.junit.Test;import java.lang.reflect.Constructor;public class CreateObject &#123; @Test public void createObj() throws Exception &#123; Class&lt;Person&gt; clz = Person.class; //1)调用空参构造 Constructor&lt;Person&gt; con = clz.getConstructor(); Person p = con.newInstance(); System.out.println(p); //调用空参构造器方式二,字节码对象需要加泛型,直接使用字节码对象调用 p = clz.newInstance(); System.out.println(p); //2)获取带参数构造并创建对象 Constructor&lt;Person&gt; conargs = clz.getConstructor(Long.class, String.class, int.class); Person p1 = conargs.newInstance(9527L, "蛤蛤", 70); System.out.println(p1); //3)获取私有构造并创建对象 Constructor&lt;Person&gt; constructor = clz.getDeclaredConstructor(String.class, int.class); //设置非public的成员访问许可 constructor.setAccessible(true); Person p2 = constructor.newInstance("包包", 51); System.out.println(p2); &#125;&#125; 操作方法获取方法 name:方法名 parameterTypes:参数列表的类型 想要定位到一个方法,必须要指定方法签名(方法名+参数列表) 1.获取多个方法 Method[] getMethods() :获取到所有的public方法,包括继承的. Method[] getDeclaredMethods() :获取所有的方法,不包括继承的. 2.获取单个方法 Method getMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的public方法 Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的方法,不管权限. 12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.reflect.getMethod;import org.junit.Test;import java.lang.reflect.Method;public class GetMethod &#123; @Test public void getMethod() throws Exception &#123; //使用反射创建对象 Class&lt;Person&gt; clz = Person.class; Person p = clz.newInstance(); //1)执行无参无返回的方法 Method m = clz.getMethod("method1"); Object ret = m.invoke(p); System.out.println(ret); //2)执行有参无返回的方法 Method m1 = clz.getMethod("method2", String.class); Object ret1 = m1.invoke(p, "蛤蛤"); System.out.println(ret1); //3)执行无参有返回的方法 Method m2 = clz.getMethod("method3"); Object ret2 = m2.invoke(p); System.out.println(ret2); //4)执行有参有返回的方法 Method m3 = clz.getMethod("method4", String.class); Object ret3 = m3.invoke(p, "蛤蛤蛤"); System.out.println(ret3); //5)执行私有方法 Method m4 = clz.getDeclaredMethod("method5"); //设置可以访问 m4.setAccessible(true); Object ret4 = m4.invoke(p); System.out.println(ret4); &#125;&#125; 反射的其他API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package me.cscar.reflect.staticmethod;import org.junit.Test;import java.lang.reflect.Method;public class MethodTest &#123; /** * 调用静态方法 */ @Test public void testInvokeStaticMethod() throws Exception &#123; //找到静态方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method6", String.class); //调用方法.由于是static修饰,执行静态方法,不需要对象,第一个参数传递为null m.invoke(null, "蛤蛤蛤"); &#125; /** * 调用参数是基本类型数组的方法 */ @Test public void testInvokeIntArray() throws Exception &#123; //找到基本类型数组方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method7", int[].class); int[] arr = new int[]&#123;1, 2, 3&#125;; //person有公共的无参数构造器,可以直接通过,字节码对象去调用 m.invoke(clz.newInstance(), new Object[]&#123;arr&#125;); &#125; /** * 调用参数是引用类型数组的方法 * 在Invoke方法中,第二个参数实际上要的是一个Object数组 * 底层将所有的实际参数放在一个Object类型的数组中 */ @Test public void testInvokeString() throws Exception &#123; Class&lt;? extends Person&gt; clz = new Person().getClass(); Method m = clz.getMethod("method8", String[].class); String[] str = new String[]&#123;"A", "B"&#125;; //wrong number of arguments:参数个数错误 /* 如果显式的传递到Invoke方法中,已经是一个Object数组了.那么会解包 解开之后是-&gt;String[].class 如果传递的是散数据-&gt;1,2,3,会装成一个Object数组,装包之后,invoke再解包 解开之后是-&gt;int.class,int.class 基本类型数组,不是Object类型的数组,所以会装包,也会拆包. 把int类型数组装进Object数组,再拆成int类型数组 引用类型数组,已经是Object类型数组,不会装包,直接拆-&gt; String.class,String.class不匹配方法参数的String[]数组 */ m.invoke(clz.newInstance(), new Object[]&#123;str&#125;); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>reflect</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL初识]]></title>
    <url>%2F2019%2F03%2F28%2FGraphQL%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[GraphQL是一个用于API的查询语言.一个GraphQL服务是通过定义类型和类型上的字段来创建,然后给每个类型上的每个字段提供解析函数.基本用法:12345678type Query &#123; me: User &#125;type User &#123; id: ID name: String&#125; 每个类型上字段的解析函数1234567function Query_me(request) &#123; return request.auth.user;&#125;function User_name(user) &#123; return user.getName();&#125; 一个GraphQL服务运行起来(通常在web服务的一个URL上),它就能接收GraphQL查询,并验证和执行.查询会检查确保只会引用已经定义的类型和字段,然后运行指定的解析函数来生成结果12345&#123; me&#123; name &#125;&#125; 会返回一个JSON结果12345&#123; "me": &#123; "name": "hhh" &#125;&#125; 字段也能指代对象类型(Object).对这个对象的字段进行次级选择(Sub-selection).遍历相关对象及其字段,使得客户端可以一次请求查询大量相关数据.12345678910&#123; hero&#123; name # 这是注释 # 这里friens指代一个对象类型 friends &#123; name &#125; &#125;&#125; 返回结果:123456789101112131415161718&#123; "data": &#123; "hero": &#123; "name": "R2-D2", "friends": [ &#123; "name": "Luke Skywalker" &#125;, &#123; "name": "Han Solo" &#125;, &#123; "name": "Leia Organa" &#125; ] &#125; &#125;&#125; friens返回了一个数组的项目,GraphQL查询会同等看成单个项目或者一个列表项目 传递参数:1234567&#123; human(id: "1000")&#123; id name height &#125;&#125; 返回结果:123456789&#123; "data": &#123; "human": &#123; "id": "1000", "name": "Luke Skywalker", "height": 1.72 &#125; &#125;&#125; 每一个字段和嵌套对象都能有自己的一组参数,从而使得GraphQL可以替代多次API请求.可以给标量(scalar)字段传递参数,用于实现服务端的一次转换1234567&#123; human(id: "1000")&#123; name #传入参数把单位转换为英尺 height(unit: FOOT) &#125;&#125; 12345678&#123; "data": &#123; "human": &#123; "name": "Luke Skywalker", "height": 5.6430448 &#125; &#125;&#125; 别名:通过设置别名可以通过不同参数查询相同字段12345678&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125; 12345678910&#123; "data": &#123; "empireHero": &#123; "name": "Luke Skywalker" &#125;, "jediHero": &#123; "name": "R2-D2" &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>PHP</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
</search>
