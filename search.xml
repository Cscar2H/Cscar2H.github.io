<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[连接池]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[连接池在Java中,连接池使用javax.sql.DataSource接口来表示连接池.DataSource(数据源)和连接池(Connection Pool)是同一个. DBCP: Spring框架推荐的 druid: 阿里巴巴的连接池(号称Java语言中性能最好的连接池) DBCP连接池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package me.cscar.dbcp.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCutil &#123; private static Properties prs = new Properties(); private static BasicDataSource bds = null; //private static DataSource dsf = null; static &#123; try &#123; InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("db.properties"); prs.load(in); Class.forName(prs.getProperty("driverClassName")); //在静态代码块中初始化连接池对象,连接池只需一个即可 bds = BasicDataSourceFactory.createDataSource(prs); //druid连接池 //dsf = DruidDataSourceFactory.createDataSource(prs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; Connection conn = bds.getConnection(); //Connection conn = dsf.getConnection(); return conn; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(ResultSet rs, PreparedStatement ps, Connection conn) &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; druid连接池阿里巴巴研发出来的号称Java语言领域性能最高的连接池.wiki地址:https://github.com/alibaba/druid/wiki 使用起来,类似于DBCP连接池.方便检测性能/状态.支持:MySQL,Oracle,DB2,sql Server等.支持:对配置文件的密码加密.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package me.cscar.dbcp.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCutil &#123; private static Properties prs = new Properties(); //private static BasicDataSource bds = null; private static DataSource dsf = null; static &#123; try &#123; InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("db.properties"); prs.load(in); Class.forName(prs.getProperty("driverClassName")); //在静态代码块中初始化连接池对象,连接池只需一个即可 //bds = BasicDataSourceFactory.createDataSource(prs); //druid连接池 dsf = DruidDataSourceFactory.createDataSource(prs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; //Connection conn = bds.getConnection(); Connection conn = dsf.getConnection(); return conn; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(ResultSet rs, PreparedStatement ps, Connection conn) &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码重构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package me.cscar.dbcp.dao.impl;import me.cscar.dbcp.dao.IemployeeDAO;import me.cscar.dbcp.domain.Employee;import me.cscar.dbcp.util.JDBCutil;import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class EmployeeDAOimpl implements IemployeeDAO &#123; public static EmployeeDAOimpl instance = new EmployeeDAOimpl(); /** * dml操作 * * @param sql * @param obj */ @Override public void dml(String sql, Object... obj) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; obj.length; i++) &#123; ps.setObject(i + 1, obj[i]); &#125; ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(null, ps, conn); &#125; &#125; /** * 查 * * @param emp,args * @return */ @Override public List&lt;Employee&gt; get(String sql, Object emp, Object... args) &#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); Class&lt;?&gt; clz = emp.getClass(); while (rs.next()) &#123; BeanInfo info = Introspector.getBeanInfo(clz, Object.class); PropertyDescriptor[] pds = info.getPropertyDescriptors(); Object obj = clz.newInstance(); for (PropertyDescriptor ele : pds) &#123; //id,name,salary String cloumnName = ele.getName(); Object cloumnValue = rs.getObject(cloumnName); //getter,setter Method m = ele.getWriteMethod(); m.invoke(obj, cloumnValue); &#125; list.add((Employee) obj); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(rs, ps, conn); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>DataBase</category>
        <category>pool</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>MySQL</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2019%2F04%2F10%2F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务事务(Transaction,简写为tx)1.当一个逻辑操作单元全部完成的时候,提交(commit)事务,这个操作就永久的保存到数据库中 2.如果回退(rollback),则放弃这个逻辑单元的所有操作 3.对于多个操作来说,作为一个整体(不可分割),所有操作成功(提交事务),数据库的数据才会改变 事务的ACID属性1.原子性(Atomicity) 2.一致性(Consistency) 3.隔离性(Isolation) 4.持久性(Durability) 事务的操作1.如果要控制事务,需要手动提交2.在MySQL中,只有InnoDB存储引擎支持事务123456789101112131415161718192021222324252627282930313233343536373839404142434445package me.cscar.account.test;import me.cscar.account.dao.impl.AccountDAOimpl;import me.cscar.account.util.JDBCutil;import org.junit.Test;import java.math.BigDecimal;import java.sql.Connection;import java.sql.SQLException;public class TXBalance &#123; @Test public void testTx() throws Exception &#123; BigDecimal money = new BigDecimal("1000"); AccountDAOimpl account = AccountDAOimpl.getInstance(); Connection conn = null; try &#123; if (account.getBalance("嘤嘤", money)) &#123; conn = JDBCutil.getConnection(); //设置手动处理事务 conn.setAutoCommit(false); account.addBalance("蛤蛤", money, conn); //假设出错 int i = 1 / 0; account.reduceBalance("嘤嘤", money, conn); //全部操作成功,提交事务 conn.commit(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); conn.rollback(); &#125; &#125;&#125; 获取自动生成的主键在数据库中保存数据的时候,要使用到自增id的时候就需要取出来. 1.如果要获取,需要设置一个标记. PreparedStatement prepareStatement(String sql, int autoGeneratedKeys):获取预编译语句对象的时候,可以设置标记,是否要获取自动生成的主键. autoGeneratedKeys: 是否要获取自动生成的主键. Statement.RETURN_GENERATED_KEYS 2.获取自动生成的主键. ResultSet getGeneratedKeys(): 获取自动生成的主键. 12345678910111213141516171819202122public class GetKey &#123; @Test public void testGetKey() throws Exception &#123; //插入一条数据到account表中获取自动生成的组件 String sql = "INSERT INTO account (name,balance) VALUES (?,?)"; Connection conn = JDBCutil.getConnection(); PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); ps.setObject(1, "包包"); ps.setObject(2, 10000); ps.executeUpdate(); //获取自动生产的组件 ResultSet rs = ps.getGeneratedKeys(); while (rs.next()) &#123; System.out.println(rs.getObject(1)); &#125; rs.close(); JDBCutil.close(ps, conn); &#125;&#125;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>MySQL</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F04%2F06%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC概述可以为多种关系数据库提供统一访问,为开发者屏蔽了一些细节问题 获取数据库链接对象Connection -&gt; 数据库连接对象 导入驱动包 获取数据库连接对象 1.加载注册驱动: Driver驱动类:应该加载驱动包中实现Driver接口类的对象 public static void registerDriver(Driver driver):注册驱动 API中,建议使用Class.forName(“com.mysql.jdbc.Driver”);加载字节码对象的时候,会执行这个类的静态代码块. 调用Class.forName不是目的,目的是为了执行com.mysql.jdbc.Driver这个类的静态代码块. 而这个类的静态代码块就是在加载注册驱动 2.获取数据库连接对象 DriverManager驱动管理类: public static Connection getConnection(String url, String user, String password): 获取数据库连接对象. JDBC操作模板1.加载注册驱动 2.获取数据库连接对象 3.生成预编译语句对象 4.执行SQL命令 5.释放资源 相关操作executeQuery(String sql): 执行DQL操作,返回单个ResultSet对象.executeUpdate(String sql): 执行DDL和DML操作 DML操作123456789101112131415161718192021222324252627package me.cscar.dml;import me.cscar.util.JDBCUtil;import org.junit.Test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class InsertTable &#123; @Test public void testInsertTable() throws Exception &#123; String sql = "INSERT INTO student(name,age) VALUES('东方翠花',20)"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.链接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javaweb", "***", "***"); //3.创建语句对象 Statement st = conn.createStatement(); //4.执行SQL命令 st.executeUpdate(sql); //5.释放资源 JDBCUtil.close(conn, st); &#125;&#125; 抽象出JDBCUtil包,复用释放资源代码 1234567891011121314151617181920212223public class JDBCUtil &#123; public JDBCUtil() &#123; &#125; public static void close(Connection conn, Statement st) &#123; try &#123; if (st != null) &#123; st.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 预编译语句对象PreparedStatement对象:又叫做预编译语句对象,是一个包含占位符?的sql模板. 1.PreparedStatement ps= conn.prepareStatement(sql模板);// 传递的是sql模板,不能直接执行. 2.ps.setObject(int parameterIndex, Object x):给占位符?设置值,parameterIndex代表第N个?号,x是具体参数 3.执行sql语句:不能调用父类带参数的方法. 如果直接调用父类的带sql参数方法,会直接将带占位符?的sql模板拿过去执行 123456789101112131415161718192021222324public class Insert &#123; @Test public void TestInsert() throws Exception &#123; Student stu = new Student(null, "小茗同学", 20); //问号表示占位符 String sql = "INSERT INTO student(name,age) VALUES(?, ?)"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.链接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///javaweb", "root", "admin"); //3.获取预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //4.执行SQL语句,给占位符设置值 ps.setObject(1, stu.getName()); ps.setObject(2, stu.getAge()); ps.executeUpdate(); //释放资源 JDBCUtil.close(conn, ps); &#125;&#125; DQL操作ResultSet常用的API: Object getObject(int columnIndex): 根据数据的列的索引获取数据. columnIndex: 表示第几列的意思,从1开始. Object getObject(String columnLabel): 根据数据的列名来获取数据. columnLabel: 表示列名. boolean next(): 是否有下一行, 如果返回是true,表示已经移动到下一行了. 获取单条数据12345678910111213141516171819202122232425public class TestGet &#123; @Test public void testGet() throws Exception &#123; //?表示占位符 String sql = "SELECT * FROM student WHERE id=?"; //注册加载驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //获得数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javaweb", "root", "admin"); //获取预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //给SQL设置值 ps.setObject(1, 5L); ResultSet resultSet = ps.executeQuery(); if (resultSet.next()) &#123; Object obj = resultSet.getObject("name"); System.out.println(obj); &#125; JDBCUtil.close(conn, ps); &#125;&#125; 获取全部数据,用list装1234567891011121314151617181920212223242526272829303132public class TestListAll &#123; @Test public void testListAll() throws Exception &#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); String sql = "SELECT * FROM student"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.获得连接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///javaweb", "root", "admin"); //3.获得预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //执行查询 ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; Student stu = new Student(); long id = rs.getLong("id"); String name = rs.getString("name"); Integer age = rs.getInt("age"); stu.setId(id); stu.setName(name); stu.setAge(age); list.add(stu); &#125; System.out.println(list); JDBCUtil.close(conn, ps); &#125;&#125; DAO规范使用DAO规范对数据库的增删改查,避免重复代码,直接调用DAO方法 DAO的设计1.保存方法 void save(Object obj) 把要保存的信息,封装成一个对象,传递给方法. 用来描述数据库表结构的javabean, 是一个特殊的javabean. ---&gt; domain 2.删除方法 void delete(Long id) 根据主键id来删除数据 3.修改方法 void update(Object obj) 把传递过来的新的信息设置到指定的数据库的记录 4.查询单个 Student get(Long id) 把查询数据封装到domain中. 5.查询多个 List&lt;Student&gt; listAll(); 使用ArrayList装 DAO的规范DAO规范,只要有操作数据库的地方,都需要该规范.主要就是针对包以及类名进行规范. 1.DAO接口. me.cscar.smis.dao:IXxxDAO ====&gt; Xxx 就是domain 2.DAO接口的实现类. me.cscar.smis.dao.impl:StudentDAOImpl 3.domain类: me.cscar.smis.domain:Student 4. 测试类: me.cscar.smis.test:StudentDAOTest 5. 工具类: me.cscar.smis.util:StringUtil/JDBCUtil 开发流程1.创建数据库表 2.根据数据库表来创建domain包以及类.1234567891011121314151617package me.cscar.refactorpro.domain;import lombok.*;import java.math.BigDecimal;@Getter@Setter@AllArgsConstructor@NoArgsConstructor@ToStringpublic class Product &#123; private Long id; private String productName; private BigDecimal salePrice; private BigDecimal cutoff;&#125; 3.根据domain来创建DAO包以及接口.1234567891011121314151617181920212223242526272829303132333435363738394041424344package me.cscar.refactorpro.dao;import me.cscar.refactorpro.domain.Product;import java.util.List;public interface IProductDAO &#123; /** * 增加 * * @param pro */ void save(Product pro); /** * 删除 * * @param id */ void delete(Long id); /** * 修改 * * @param pro */ void update(Product pro); /** * 查询指定 * * @param id * @return */ Product get(Long id); /** * 查询全部 * * @return */ List getAll();&#125; 4.根据DAO接口来生成实现类.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190package me.cscar.refactorpro.dao.impl;import me.cscar.refactorpro.dao.IProductDAO;import me.cscar.refactorpro.domain.Product;import me.cscar.refactorpro.util.JDBCutil;import java.math.BigDecimal;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class ProductDAOImpl implements IProductDAO &#123; public static ProductDAOImpl getInstance() &#123; return new ProductDAOImpl(); &#125; /** * 增加 * * @param pro */ @Override public void save(Product pro) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "INSERT INTO t_product (productName,salePrice,cutoff) VALUES (?,?,?)"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, pro.getProductName()); ps.setObject(2, pro.getSalePrice()); ps.setObject(3, pro.getCutoff()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(conn, ps); &#125; &#125; /** * 删除 * * @param id */ @Override public void delete(Long id) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "DELETE FROM t_product WHERE id = ?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, id); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBCutil.close(conn, ps); &#125; /** * 修改 * * @param pro */ @Override public void update(Product pro) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "UPDATE t_product SET productName=?,salePrice=?,cutoff=? WHERE id=?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, pro.getProductName()); ps.setObject(2, pro.getSalePrice()); ps.setObject(3, pro.getCutoff()); ps.setObject(4, pro.getId()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(conn, ps); &#125; &#125; /** * 查询指定 * * @param id * @return */ @Override public Product get(Long id) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; String sql = "SELECT * FROM t_product WHERE id = ?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, id); rs = ps.executeQuery(); while (rs.next()) &#123; Product pro = new Product(); String productName = rs.getString("productName"); BigDecimal salePrice = rs.getBigDecimal("salePrice"); BigDecimal cutoff = rs.getBigDecimal("cutoff"); Long proid = rs.getLong("id"); pro.setId(proid); pro.setProductName(productName); pro.setSalePrice(salePrice); pro.setCutoff(cutoff); return pro; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBCutil.close(conn, ps); &#125; throw new RuntimeException("查询错误"); &#125; /** * 查询全部 * * @param pro * @return */ @Override public List getAll() &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; String sql = "SELECT * FROM t_product"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); rs = ps.executeQuery(); List&lt;Product&gt; list = new ArrayList&lt;&gt;(); while (rs.next()) &#123; Product pro = new Product(); String productName = rs.getString("productName"); BigDecimal salePrice = rs.getBigDecimal("salePrice"); BigDecimal cutoff = rs.getBigDecimal("cutoff"); Long proid = rs.getLong("id"); pro.setId(proid); pro.setProductName(productName); pro.setSalePrice(salePrice); pro.setCutoff(cutoff); list.add(pro); &#125; return list; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); JDBCutil.close(conn, ps); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; throw new RuntimeException("查询出错"); &#125;&#125; 5.根据测试先行,根据DAO接口生成测试类.完成测试类.12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.refactorpro.test;import me.cscar.refactorpro.dao.impl.ProductDAOImpl;import me.cscar.refactorpro.domain.Product;import me.cscar.refactorpro.util.JDBCutil;import org.junit.Test;import java.math.BigDecimal;import java.sql.Connection;import java.util.List;public class ProductDAOTest &#123; @Test public void save() &#123; Product pro = new Product(null, "mac", new BigDecimal("15000"), new BigDecimal("0.9")); ProductDAOImpl.getInstance().save(pro); &#125; @Test public void delete() &#123; ProductDAOImpl.getInstance().delete(6L); &#125; @Test public void update() &#123; Product newpro = new Product(5L, "suffer", new BigDecimal("14000"), new BigDecimal("0.99")); ProductDAOImpl.getInstance().update(newpro); &#125; @Test public void get() &#123; Product product = ProductDAOImpl.getInstance().get(4L); System.out.println(product); &#125; @Test public void getAll() &#123; List all = ProductDAOImpl.getInstance().getAll(); System.out.println(all); &#125;&#125; 抽取和完善JDBCutil新建配置文件,properties1234ClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql:///javawebuserName=xxxpassword=xxx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package me.cscar.refactorpro.util;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;import java.util.Properties;public class JDBCutil &#123; private static Properties pre = new Properties(); static &#123; InputStream is = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("prodb.properties"); try &#123; pre.load(is); Class.forName(pre.getProperty("ClassName")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; Connection conn = DriverManager.getConnection(pre.getProperty("url"), pre.getProperty("userName"), pre.getProperty("password")); return conn; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(Connection conn, PreparedStatement ps) &#123; try &#123; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 预编译语句对象原理避免了sql语句字符串拼接.有的数据库有DBMS有缓冲区,预编译语句对象可以提交效率. mysql不支持 DBMS1.安全检查2.语义分析检查语句在缓存中是否存在3.编译SQL4.执行SQL 有缓存区会存储编译好的sql模板,? 使用预编译语句对象可以防止SQL注入]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>MySQL</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pocketbook]]></title>
    <url>%2F2019%2F04%2F04%2Fpocketbook%2F</url>
    <content type="text"><![CDATA[pocketbook基于Swing和JDBC开发的桌面程序,JavaSE基础的综合.使用git进行版本管理,合作开发 github地址:https://github.com/Cscar2H/pocketbook]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>desktop</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F04%2F03%2FMySQL%2F</url>
    <content type="text"><![CDATA[SQLSQL：结构化查询语言(Structured Query Language)SQL包含6个部分 1.数据库查询语言(DQL) 2.数据操作语言(DML) 3.事务处理语言(TCL) 4.数据控制语言(DCL) 5.数据定义语言(DDL) MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。MyISAM：拥有较高的插入，查询速度，但不支持事务，不支持外键。InnoDB：支持事务，支持外键，支持行级锁定，性能较低。 InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但对比MyISAM，处理效率差，且会占用更多的磁盘空间以保留数据和索引。 ORM思想: 对象关系映射 –&gt; Java的对象和关系型数据库的映射 表 面向对象 表结构 类 表的列 属性 表的行 对象 MySQL命令行1.sudo mysql.server start : 启动数据库 2.sudo mysql.server stop : 关闭数据库 3.mysql -u root -p : 进入数据库(我的版本信息:Server version: 8.0.12 Homebrew) 4.use mysqlname; : 进入数据库 5.show tables; : 查看表 6.desc table_name; : 查看表结构 7.create table table_name : 创建表 8.drop table table_name : 删除表 MySQL列的常见类型 Java MySQL int INT long BIGINT BigDecimal DECIMAL boolean BIT java.util.Date DATE/DATETIME String VARCHAR 表约束 1.非空约束：NOT NULL(NK)，不允许某列的内容为空。 2.设置列的默认值：DEFAULT。 3.唯一约束：UNIQUE(UK)，在该表中，该列的内容必须唯一。 4.主键约束：PRIMARY KEY(PK)， 非空且唯一。 5.主键自增长：AUTO_INCREMENT，从1开始，步长为1。(MySQL特有) 6.外键约束：FOREIGN KEY(FK)，A表中的外键列的值必须参照于B表中的某一列(B表主键)。 数据操作(DML)保存操作 1INSERT INTO table_name(column1,column2,colum3...) VALUES (value1, value2, value3); 更新操作 1UPDATE table_name SET `columnName` = &apos;value&apos; WHERE (`condition` = &apos;num&apos;); 删除操作 1DELETE FROM table_name WHERE (`condition` = &apos;num&apos;); 数据查询操作(DQL)基本语法1SELECT * FROM table_name; 说明：SELECT 选择查询列表,列与列之间用逗号隔开FROM 提供数据源(表、视图或其他的数据源) 如果为 * 和创建表时的顺序一致。可以自己调整顺序，在select后边加上要查询的列名。 消除结果中重复的数据1SELECT DISTINCT 列名.. FROM table_name; 数学运算 数学运算:对NUMBER型数据可以使用算数操作符创建表达式（+ - * /） 对DATE型数据可以使用部分算数操作符创建表达式 （+ -） 运算符优先级： 1、乘法和除法的优先级高于加法和减法 2、同级运算的顺序是从左到右 3、表达式中使用&quot;括号&quot;可强行改变优先级的运算顺序 设置显示格式: 一旦遇到变量和常量拼接就必须使用CONCAT函数 把多个值以字符串拼接的形式拼在一起,可以使用函数concat(...) 设置列名的别名 1.改变表的名字； 2.用于表示计算结果的含义； 3.作为列的别名； 4.如果别名中使用特殊字符，或者是强制大小写敏感，或有空格时，都需加引号；别名以后都不加引号.加了引号的别名导致排序失效. 过滤查询 过滤查询比较运算符 运算符 含义 = 等于 &gt; 大于 &gt;= 大于或等于 &lt; 小于 &lt; 小于 &lt;= 小于或等于 !=(&lt;&gt;) 不等于 逻辑运算符 运算符 含义 AND(&amp;&amp;) 如果组合的条件都是TRUE,返回TRUE OR(&#124;&#124;) 如果组合的条件之一是TRUE,返回TRUE NOT(!) 如果下面的条件是FALSE,返回TRUE 范围查询 使用BETWEEN运算符显示某一值域范围的记录，这个操作符最常见的使用在数字类型数据的范围上，但对于字符类型数据和日期类型数据同样可用。 格式： SELECT &lt;columnList&gt; FROM table_name WHERE 列名 BETWEEN minvalue AND maxvalue：闭区间。 集合查询 使用IN运算符，判断列的值是否在指定的集合中。 格式： WHERE 列名 IN (值1，值2....); 空值查询 IS NULL:判断列的值是否为空。 空值是特指没有值的列 格式：WHERE 列名 IS NULL; 模糊查询 使用LIKE运算符执行通配查询，查询条件可包含文字字符或数字： %通配符：可表示任意个数的任意字符。 _通配符：可表示一个任意字符。 通配符：用来实现匹配部分值得特殊字符。 结果排序使用ORDER BY子句将记录排序ASC升序DESC降序ORDER BY 子句出现在SELECT语句的最后。格式：SELECT FROM table_nameWHERE 条件ORDER BY 列名1 [ASC/DESC],列名2 [ASC/DESC]…;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识XML]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%88%9D%E8%AF%86XML%2F</url>
    <content type="text"><![CDATA[XMLXML概述使用XML文件,可以保存复杂的数据,数据结构清晰(树状结构) 传输数据是一种通用的数据格式 传递数据,作为配置文件存在 XML语法 版本 &lt;?xml version=&quot;1.0&quot;?&gt; 用encoding属性说明文档所使用的字符编码，默认为UTF-8。保存在磁盘上的文件编码要与声明的编码一致。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 用standalone属性说明文档是否独立，即是否依赖其他文档。 &lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt; 标签的属性,描述该标签 &lt;linkman 属性名=&quot;属性值&quot;&gt; 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;contacts&gt; &lt;person id="1"&gt; &lt;name&gt;蔡徐坤&lt;/name&gt; &lt;address&gt;荷兰&lt;/address&gt; &lt;email&gt;kk@nmsl&lt;/email&gt; &lt;age&gt;17&lt;/age&gt; &lt;/person&gt; &lt;person id="2"&gt; &lt;name&gt;孙笑川&lt;/name&gt; &lt;address&gt;日本&lt;/address&gt; &lt;email&gt;cc@nmsl&lt;/email&gt; &lt;age&gt;18&lt;/age&gt; &lt;/person&gt;&lt;/contacts&gt; DOM解析(Document Object Model)文档对象模型,可以将xml的操作当做是操作对象 特点: 在加载XML文档的时候,会一次性把所有的信息加载到内存中(DOM树) 使用document这一对象来描述,剩下的操作都是操作内存中的对象 缺点: 如果XML文档内容比较多,文件比较大,一加载到内存中会导致,内存溢出 注意: 1.使用DOM解析,导入的类都是在org.w3c.dom包中.如果发现让你强转.意识到可能导错包了. 2.在XML中,一切皆节点 ####获取Document对象 三个类 Document DocumentBuilder DocumentBuilderFactory newDocumentBuilder:单例设计模式,需要通过自身的newInstance方法,获取一个新的实例 DocumentBuilder:需要通过newDocumentBuilder的实例中的newDocumentBuilder获取对象,该类重写了parse方法和newDocument方法 Document:接口,不能创建对象.抽象的parse方法和newDocument方法 12345678910111213141516171819202122232425262728package me.cscar.DOM.object;import org.junit.Test;import org.w3c.dom.Document;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.File;import java.io.InputStream;public class GetDOMObject &#123; @Test public void getObject() throws Exception &#123; File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.newDocument(); InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); Document doc1 = db.parse(is); //Document doc = db.parse(file); System.out.println(doc.equals(doc1)); &#125;&#125; ####常用API(增删改查)常用的API: Document对象: Element getDocumentElement(): 获取根节点. Element getElementById(String elementId) :根据唯一ID获取节点. Element对象: NodeList getElementsByTagName(String name):根据标签名获取到标签列表. String getAttribute(String name) :根据属性名,获取属性值 void setAttribute(String name, String value) :设置属性名和属性值. Node 对象: String getTextContent(): 返回当前节点的文本内容. void setTextContent(String value): 设置文本内容. ADD1234567891011121314151617181920212223242526272829303132333435363738394041424344package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;public class Add &#123; @Test public void useAdd() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //创建document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根节点 Element element = doc.getDocumentElement(); //创建节点 Element person = doc.createElement("person"); person.setAttribute("id", "4"); Element name = doc.createElement("name"); Element email = doc.createElement("email"); Element address = doc.createElement("address"); Element age = doc.createElement("age"); //创建层级关系 element.appendChild(person); person.appendChild(name); person.appendChild(email); person.appendChild(address); person.appendChild(age); //给节点设置数据 name.setTextContent("蛤蛤"); email.setTextContent("haha@china.com"); address.setTextContent("中国"); age.setTextContent("90"); SynchroFile.synchor(doc); &#125;&#125; REMOVE123456789101112131415161718192021222324252627282930313233343536373839package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 删除操作 */public class Remove &#123; @Test public void useRemove() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //获取document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根节点 Element de = doc.getDocumentElement(); //person标签 NodeList person = de.getElementsByTagName("person"); //获取第三个人的标签 Element p3 = (Element) person.item(2); System.out.println(p3.getAttribute("id")); p3.getParentNode().removeChild(p3); //同步操作,把修改的document对象写入 SynchroFile.synchor(doc); &#125;&#125; QUERY12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 查询操作 */public class Query &#123; @Test public void useQuery() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); Element de = doc.getDocumentElement(); //第1个人的信息节点 NodeList person = de.getElementsByTagName("person"); System.out.println("长度是"+person.getLength()); Element item = (Element) person.item(2); //获取ID编号 //System.out.println(item.getAttribute("id")); //找到第1个联系人的name节点 Element nameNode = (Element) item.getElementsByTagName("name").item(0); int re = item.getElementsByTagName("name").getLength(); //System.out.println(re); String name = nameNode.getTextContent(); System.out.println(name); //获取所有人的信息 for (int i = 0; i &lt; person.getLength(); i++) &#123; Element item1 = (Element) person.item(i); String name1 = item1.getElementsByTagName("name").item(0).getTextContent(); String email = item1.getElementsByTagName("email").item(0).getTextContent(); String address = item1.getElementsByTagName("address").item(0).getTextContent(); String age = item1.getElementsByTagName("age").item(0).getTextContent(); System.out.println(name1 + '\n' + email + '\n' + address + '\n' + age); System.out.println("-------------"); &#125; &#125;&#125; UPDATE12345678910111213141516171819202122232425262728293031323334353637package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 修改操作 */public class Update &#123; @Test public void useUpdate() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //获取document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根标签 Element element = doc.getDocumentElement(); //获取第3个人信息 Element person = (Element) element.getElementsByTagName("person").item(2); //获取name标签 Element name = (Element) person.getElementsByTagName("name").item(0); //修改name标签 name.setTextContent("包包"); //调用同步方法 SynchroFile.synchor(doc); &#125;&#125; 同步操作12345678910111213141516171819202122232425262728293031323334package me.cscar.DOM.frequently;import org.w3c.dom.Document;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.File;import java.io.InputStream;/** * 增删改的同步操作 * 把修改的document真正写入 */public class SynchroFile &#123; public static void synchor(Document doc) throws Exception &#123; File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); //获取工厂对象 TransformerFactory factory = TransformerFactory.newInstance(); //获取转换器 Transformer transformer = factory.newTransformer(); //调用转换器中的方法 Source src = new DOMSource(doc); Result target = new StreamResult(file); transformer.transform(src, target); &#125;&#125; 创建新的XML12345678910111213141516171819202122232425262728293031323334353637383940package me.cscar.DOM.create;import me.cscar.DOM.frequently.SynchroFile;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.File;public class Create &#123; @Test public void CreateDoc() throws Exception &#123; //File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); File newFile = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML_Copy.xml"); Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument(); //创建一个根节点 Element element = doc.createElement("contacts"); //添加根节点 doc.appendChild(element); TransformerFactory factory = TransformerFactory.newInstance(); Transformer tf = factory.newTransformer(); Source src = new DOMSource(doc); Result target = new StreamResult(newFile); tf.transform(src, target); &#125;&#125; ####XML约束(了解)]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>配置文件</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaUtility]]></title>
    <url>%2F2019%2F03%2F31%2FJavaUtility%2F</url>
    <content type="text"><![CDATA[LombokJavaBean规范代码生成工具]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>utility</tag>
        <tag>tool</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaBean]]></title>
    <url>%2F2019%2F03%2F30%2FJavaBean%2F</url>
    <content type="text"><![CDATA[JavaBean在Java中一个非常重要的组件,可重用.如果想要在多个模块中重用,必须遵循一定的规范. 1.必须使用public修饰 2.必须提供公共的无参数构造器 3.字段都是私有化的 4.提供get和set方法 JavaBean中重要成员方法 事件 属性:property,不是字段,而是通过get/set方法推导出来的 12345678910111213141516171819class HelloWorld &#123; private String name; /** * 标准的get方法 * get之后首字母小写,称之为属性 * */ public String getName() &#123; return name; &#125; /** * 标准的set方法 * set之后首字母大写,称之为属性 * */ public void setName(String name) &#123; this.name = name; &#125;&#125; 内省操作内省机制 核心类:Introspector 专门用来操作JavaBean的属性 核心方法 BeanInfo getBeanInfo(class&lt;?&gt; beanclass) 常用API java.beans.Introspector类常用API: static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass) : 获取字节码对象对应的JavaBean信息 static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass, Class&lt;?&gt; stopClass) java.beans.BeanInfo接口常用API: PropertyDescriptor[] getPropertyDescriptors() : 获取所有的属性描述器 java.beans.PropertyDescriptor类常用API: String getName() : 获得属性的名称 Class&lt;?&gt; getPropertyType() : 获得属性的类型 Method getReadMethod() : 获得用于读取属性值的方法 Method getWriteMethod() : 获得用于设置属性值的方法 JavaBean和Map的转换从浏览器传递过来的数据,服务器获取数据后.需要将数据放到一个对象中,传递的数据类似于key=value的形式.所以需要将map转换成JavaBean 都具有相似的结构 转换操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package me.cscar.con.conversion;import org.junit.Test;import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class JavaBeanMap &#123; @Test public void test() throws Exception &#123; //Person p = new Person("蛤蛤", 90); Class&lt;Person&gt; clz = Person.class; Constructor&lt;Person&gt; con = clz.getConstructor(String.class, Integer.class); Person p = con.newInstance("蛤蛤", 90); Map&lt;String, Object&gt; map = bean2map(p); System.out.println(map); System.out.println(map2bean(map, clz)); &#125; /** * JavaBean对象转换成map * 把JavaBean对象中的属性值,获取出来,放在map中 */ public static Map&lt;String, Object&gt; bean2map(Object obj) throws Exception &#123; BeanInfo beanInfo = Introspector.getBeanInfo(obj.getClass(), Object.class); //创建map对象 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Method m = ele.getReadMethod(); Object value = m.invoke(obj); map.put(key, value); &#125; return map; &#125; /** * map转换成JavaBean对象 * 把map的数据取出来,放到JavaBean对应的属性上 */ public static Object map2bean(Map&lt;String, Object&gt; map, Class clz) throws Exception &#123; //使用字节码对象创建对象 Object obj = clz.newInstance(); //获取字节码对象对应JavaBean信息 BeanInfo beanInfo = Introspector.getBeanInfo(clz, Object.class); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); //遍历 for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Object value = map.get(key); Method m = ele.getWriteMethod(); m.invoke(obj, value); &#125; return obj; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>JavaBean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Annotation注解]]></title>
    <url>%2F2019%2F03%2F30%2FAnnotation%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解(标签)注解的概述解决xml臃肿的问题 在Java5之后,开始对元数据的支持,就是Annotation(注解) 可以用来描述其他数据的一种数据,可以赋予其他数据一些功能 常用注解: @Override 限定覆写父类方法 @Deprecated 标记已过时,不推荐使用.在JDK1.5之前,使用文档注释来标记过时 @SuppressWarings 抑制编译器发出的警告,@SuppressWarings(value=&quot;all&quot;) @SafeVarargs 抑制堆污染警告(Java7开始出现的) @Functionallnterface 标记该接口是一个函数接口(Java8开始出现的) 注解的定义:123public @interface Test&#123; //抽象方法 属性&#125; 注解的使用语法: @注解名(属性名1=属性值1,属性名2=属性值2,...) 注解想要具有某一些功能,最重要的是需要三方程序的参与,必须使用反射来给注解赋予功能 元注解注解是用来约束其他程序元素的(字段,方法,),元注解是用来约束注解的 @Target: 表示注解可以贴在哪些位置(类,方法上,构造器上等等) @Retention: 表示注解可以保存在哪一个时期,存活时间 @Documented: 使用@Documented标注的标签会保存到API文档中 @Inherited: @Inherited标注的标签可以被子类所继承. 自定义注解语法格式 1. 可以为属性设置默认值, 使用default. 2. 如果必须要写的属性(可以有多个,其他的都有默认值),并且这个属性的名字叫value, 可以省略属性名,直接写值. 3. 属性的类型只能是基本类型,String,Class,注解,枚举,以及其数组类型. 4. 抽象方法不能有参数 使用注解是一种硬编码方式**]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Annotation</tag>
        <tag>注解</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置文件]]></title>
    <url>%2F2019%2F03%2F30%2F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[配置文件使用配置文件经常修改,从源文件的编写到部署的过程,都需要重新修改. 解决方案: 把配置保存在一个文件中, Java代码可以通过流(stream)动态的读取 真正解决的问题: 代码中的硬编码,写死到Java代码中,而且是经常改动的值 常用的配置文件1.properties文件. 文件后缀名.properties,用来保存一些简单的数据.保存格式:key=value 重复的key表示更新操作,不能存多个用户信息 2.xml文件 文件后缀名.xml,用来保存一些复杂的数据,按照清晰的格式保存(结构化) properties文件的基本使用常见的操作 创建properties文件,并存储数据 1.文件存放在resource文件夹中. 2.在该配置文件中,所有数据到Java后,都是String类型 3.等号不需要空格 123#这是注释,保存格式:key=valueusername=rootpassword=admin 使用jdk提供好的工具类来加载和获取 void load(InputStream inStream):通过输入流把数据加载到properties对象中 String getProperty(String key):通过指定的key获取value值 使用相对路径12//默认去bin中找Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;user.properties&quot;); 123456789101112131415161718public class PropertiesTest &#123; @Test public void loadProperties() throws Exception &#123; //创建properties对象 Properties pt = new Properties(); //获取相对路径 InputStream in = Thread.currentThread(). getContextClassLoader(). getResourceAsStream("user.properties"); //加载 pt.load(in); //获取 String username = pt.getProperty("username"); System.out.println(username); String password = pt.getProperty("password"); System.out.println(password); &#125;&#125; 反射的优势反射的应用场景 更多的是使用一个全限定名来创建对象(反射) 为了解决硬编码,为了降低代码的耦合性,一般将具体的实现类配置到配置文件中 1234567891011121314151617181920212223package me.cscar.con.reflect;import org.junit.Test;import java.io.InputStream;import java.util.Properties;public class Math implements IMath &#123; @Test public void testMath() throws Exception &#123; Properties ps = new Properties(); InputStream is = Thread. currentThread(). getContextClassLoader(). getResourceAsStream("math.properties"); ps.load(is); //forName获取properties文件中的全限定名称,并且创建对象 IMath math = (IMath) Class.forName(ps.getProperty("clssName")) .newInstance(); //getClass获取math的全限定名 System.out.println(math.getClass()); &#125;&#125; 优点: 1.反射提高了程序的灵活性和扩展性。 2.降低耦合性，提高自适应能力。 3.它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 1.性能问题：使用发射基本上是一种在运行期间解析字节码操作，效率较低，一般程序不建议使用，对灵活性和拓展性要求较高的工具或框架上使用较多。 2.代码复杂性：反射发生在运行期，程序员无法在源代码中看到程序的逻辑，反射代码比相应的直接的代码更复杂，因而会带来维护的问题 框架中大量使用反射,用来提高框架的扩展性和灵活性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JunitTest]]></title>
    <url>%2F2019%2F03%2F29%2FJunitTest%2F</url>
    <content type="text"><![CDATA[Junit回归测试框架的基本使用测试先行的思想 单元测试Junit属于白盒测试 定义一个测试方法:1.测试方法,必须是公共的无参数无返回的方法.建议使用test开头. 2.想要测试哪个方法,需要在该方法上贴一个注解@Test 12345678import org.junit.Test;public class HelloTest &#123; @Test public void addTest() &#123; System.out.println("添加用户信息"); &#125;&#125; Junit细节:更多是针对接进行测试,要测试一个接口中的方法,必须按照规范流程 定义一个接口:1234567891011121314151617181920212223242526package me.cscar.Junit;/** * 接口规范:文档注释 * 数学运算的加减乘除方法 * * @author cscar * @date 2019/3/29 */public interface IMath &#123; /** * 计算两个数相加 * @param a * @param b * @return 和 */ int add(int a, int b); /** * 计算两个数相除 * @param a * @param b * @return 商 */ int div(int a, int b);&#125; 根据接口生成实现类:1234567891011121314151617package me.cscar.Junit;/** * 实现IMath接口 */public class Math implements IMath &#123; @Override public int add(int a, int b) &#123; return a + b; &#125; @Override public int div(int a, int b) &#123; return a / b; &#125;&#125; 根据接口生成实现类:1234567891011121314151617181920212223242526package me.cscar.Junit;import org.junit.Test;import static org.junit.Assert.*;//测试数学运算public class MathTest &#123; /** * 面向接口,创建数学类对象 */ private IMath math = new Math(); @Test public void add() &#123; int result = math.add(3, 4); System.out.println(result); &#125; @Test public void div() &#123; int result = math.div(10, 0); System.out.println(result); &#125;&#125; 断言:猜测一个程序结果是否是期望结果 1.:Assert.assertEquals(message, expected, actual):比较的值 三个参数: message: 断言失败的提示信息,断言成功不会显示. expected: 期望值 actual: 真实值 2.:Assert.assertSame(message, expected, actual):比较地址,是同一个对象 Assert.assertNotSame(message, expected, actual):断言不是同一个对象 3.:Assert.assertTrue(message, condition):断言condition应该为TRUE. Assert.assertFalse(message, condition):断言condition应该为FALSE. 4.:Assert.assertNull(message, object):断言对象object为null. Assert.assertNotNull(message, object):断言对象object不为null. 5.:@Test(expected=ArithmeticException.class) 期望该方法报错ArithmeticException. 6.:@Test(timeout=400) 期望该方法在400毫秒之内执行完成. 123456789101112@Testpublic void add() &#123; int result = math.add(3, 4); //System.out.println(result); Assert.assertEquals(&quot;3+4我都能算错?&quot;, 8, result);&#125;@Test(expected = ArithmeticException.class)public void div() &#123; int result = math.div(10, 0); System.out.println(result);&#125; Junit自动化操作自动初始化自动销毁 1.@Test:需要测试的方法,必须贴Test注解.并且测试方法必须是公共无参数无返回的方法. 2.@Before:在所有的测试方法之前,都会执行的代码 3.@After:在所有的测试方法之后,都会执行的代码 4.@BeforeClass:在所有操作之前执行,只执行一次. 5.@AfterClass:在所有操作之前执行,只执行一次. 1234567891011121314151617181920212223242526272829303132333435package me.cscar.junit.work;import org.junit.*;public class WorkTest &#123; @Test public void query() &#123; System.out.println("查询用户信息"); &#125; @Test public void delete() &#123; System.out.println("删除用户信息"); &#125; @Before public void init() &#123; System.out.println("登录"); &#125; @After public void story() &#123; System.out.println("注销"); &#125; @BeforeClass public static void BeforeClass() &#123; System.out.println("所有操作之前"); &#125; @AfterClass public static void AfterClass() &#123; System.out.println("所有操作之后"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Junit</tag>
        <tag>测试类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect反射]]></title>
    <url>%2F2019%2F03%2F29%2FReflect%2F</url>
    <content type="text"><![CDATA[反射为什么要使用反射1234567891011121314151617181920//定义一个类class Person&#123; public Object work()&#123; //假设看不到源码,无法获取真实类型 return new Date(); &#125; //调用work方法 @Test public void testWork()&#123; Person p = new Person(); Object obj = new Person(); //返回值是一个对象,可以继续调用该对象的方法. Date d = (Date)obj; //打印本地的时间风格,但是却不知道应该用什么来接收(不知道返回的是date) String str = d.toLocalString(); System.out.println(str); &#125;&#125; Person类是别人提供好的字节码文件.看不到源码是不能直接强转的. 不爽:我都已经获取到真正的对象了,居然不能知道他的真实类型. 什么是反射:通过字节码(Class)对象,动态的获取该字节码中的成员(构造器,方法,字段,父类,包…) 字节码对象(Class):将多个Class类抽象出来,形成一个字节码的结构(everything is object) 当JVM加载完字节码后.会使用一个对象,来描述该字节码文件的结构.该对象包含操作字节码中成员的方法. 字节码对象,是JVM加载字节码文件的时候,给我们创建的一个对象,一份字节码,只会创建一个字节码对象. 获取字节码对象的三种方法:1.通过Class类的forName来获取. public static Class&lt;?&gt; forName(String className):根据全限定名来获取字节码对象. 全限定名:包名.类名.指定到唯一的一个类上. 2.所有的对象,都有一个公共的方法.getClass. public final Class&lt;?&gt; getClass(): 通过对象返回字节码对象. 3.任何类型都有一个class属性. int.class / Person.class/ 1234567891011121314151617181920212223242526272829303132package me.cscar.reflect.getClassObject;import org.junit.Test;public class GetClassTest &#123; @Test public void getClassObject() throws Exception &#123; //1.通过forName静态方法获取,抛出异常 Class clz = Class.forName("me.cscar.reflect.getClassObject.Person"); //2.通过对象.getClass()方法获取 Object obj = new Person(); Class clz1 = obj.getClass(); //3.任何类型都有一个class属性 Class clz2 = Person.class; //class me.cscar.reflect.getClassObject.Person System.out.println(clz); //true System.out.println(clz == clz1); //true System.out.println(clz == clz2); //int类型的class属性不等于integer的class属性,结果为false System.out.println(int.class == Integer.class); //integer的包装类型是int,结果为true System.out.println(int.class == Integer.TYPE); //class [Ljava.lang.String; System.out.println(String[].class); &#125;&#125; 构造器的操作获取构造器获取单个构造器 parameterTypes:参数类型 想要定位到一个构造器,必须要指明构造器的参数列表. 1.获取单个构造器: public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes):获取public的指定的构造器 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) :获取不管权限的构造器 2.获取所有构造器: Constructor&lt;?&gt;[] getConstructors() :获取所有public 的构造器 Constructor&lt;?&gt;[] getDeclaredConstructors() :获取所有构造器,不管权限. 123456789101112131415161718192021222324252627282930313233343536package me.cscar.reflect.getConstructor;import org.junit.Test;import java.lang.reflect.Constructor;public class GetConstructor &#123; @Test public void testGetConstructor() throws Exception &#123; //创建字节码对象 Class clz = Class.forName("me.cscar.reflect.getConstructor.Person"); //1.获取所有的public构造器 Constructor[] cons = clz.getConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //2.获取所有的构造器 cons = clz.getDeclaredConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //3.获取无参数构造器 Constructor con = clz.getConstructor(); //System.out.println(con); //4.获取带参数的public构造器 Constructor conagsP = clz.getDeclaredConstructor(Long.class, String.class, int.class); //System.out.println(conagsP); //5.获取带参数的构造器(暴力反射) Constructor conage = clz.getDeclaredConstructor(String.class, int.class); System.out.println(conage); &#125;&#125; 通过构造器创建对象 public T newInstance(Object... initargs):通过构造器,创建对象. initargs:实际参数. 如果想要调用私有的成员.必须要先设置可以访问. public void setAccessible(boolean flag): 设置为true. 12345678910111213141516171819202122232425262728293031323334package me.cscar.reflect.createObject;import org.junit.Test;import java.lang.reflect.Constructor;public class CreateObject &#123; @Test public void createObj() throws Exception &#123; Class&lt;Person&gt; clz = Person.class; //1)调用空参构造 Constructor&lt;Person&gt; con = clz.getConstructor(); Person p = con.newInstance(); System.out.println(p); //调用空参构造器方式二,字节码对象需要加泛型,直接使用字节码对象调用 p = clz.newInstance(); System.out.println(p); //2)获取带参数构造并创建对象 Constructor&lt;Person&gt; conargs = clz.getConstructor(Long.class, String.class, int.class); Person p1 = conargs.newInstance(9527L, "蛤蛤", 70); System.out.println(p1); //3)获取私有构造并创建对象 Constructor&lt;Person&gt; constructor = clz.getDeclaredConstructor(String.class, int.class); //设置非public的成员访问许可 constructor.setAccessible(true); Person p2 = constructor.newInstance("包包", 51); System.out.println(p2); &#125;&#125; 操作方法获取方法 name:方法名 parameterTypes:参数列表的类型 想要定位到一个方法,必须要指定方法签名(方法名+参数列表) 1.获取多个方法 Method[] getMethods() :获取到所有的public方法,包括继承的. Method[] getDeclaredMethods() :获取所有的方法,不包括继承的. 2.获取单个方法 Method getMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的public方法 Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的方法,不管权限. 12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.reflect.getMethod;import org.junit.Test;import java.lang.reflect.Method;public class GetMethod &#123; @Test public void getMethod() throws Exception &#123; //使用反射创建对象 Class&lt;Person&gt; clz = Person.class; Person p = clz.newInstance(); //1)执行无参无返回的方法 Method m = clz.getMethod("method1"); Object ret = m.invoke(p); System.out.println(ret); //2)执行有参无返回的方法 Method m1 = clz.getMethod("method2", String.class); Object ret1 = m1.invoke(p, "蛤蛤"); System.out.println(ret1); //3)执行无参有返回的方法 Method m2 = clz.getMethod("method3"); Object ret2 = m2.invoke(p); System.out.println(ret2); //4)执行有参有返回的方法 Method m3 = clz.getMethod("method4", String.class); Object ret3 = m3.invoke(p, "蛤蛤蛤"); System.out.println(ret3); //5)执行私有方法 Method m4 = clz.getDeclaredMethod("method5"); //设置可以访问 m4.setAccessible(true); Object ret4 = m4.invoke(p); System.out.println(ret4); &#125;&#125; 反射的其他API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package me.cscar.reflect.staticmethod;import org.junit.Test;import java.lang.reflect.Method;public class MethodTest &#123; /** * 调用静态方法 */ @Test public void testInvokeStaticMethod() throws Exception &#123; //找到静态方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method6", String.class); //调用方法.由于是static修饰,执行静态方法,不需要对象,第一个参数传递为null m.invoke(null, "蛤蛤蛤"); &#125; /** * 调用参数是基本类型数组的方法 */ @Test public void testInvokeIntArray() throws Exception &#123; //找到基本类型数组方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method7", int[].class); int[] arr = new int[]&#123;1, 2, 3&#125;; //person有公共的无参数构造器,可以直接通过,字节码对象去调用 m.invoke(clz.newInstance(), new Object[]&#123;arr&#125;); &#125; /** * 调用参数是引用类型数组的方法 * 在Invoke方法中,第二个参数实际上要的是一个Object数组 * 底层将所有的实际参数放在一个Object类型的数组中 */ @Test public void testInvokeString() throws Exception &#123; Class&lt;? extends Person&gt; clz = new Person().getClass(); Method m = clz.getMethod("method8", String[].class); String[] str = new String[]&#123;"A", "B"&#125;; //wrong number of arguments:参数个数错误 /* 如果显式的传递到Invoke方法中,已经是一个Object数组了.那么会解包 解开之后是-&gt;String[].class 如果传递的是散数据-&gt;1,2,3,会装成一个Object数组,装包之后,invoke再解包 解开之后是-&gt;int.class,int.class 基本类型数组,不是Object类型的数组,所以会装包,也会拆包. 把int类型数组装进Object数组,再拆成int类型数组 引用类型数组,已经是Object类型数组,不会装包,直接拆-&gt; String.class,String.class不匹配方法参数的String[]数组 */ m.invoke(clz.newInstance(), new Object[]&#123;str&#125;); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>reflect</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL初识]]></title>
    <url>%2F2019%2F03%2F28%2FGraphQL%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[GraphQL是一个用于API的查询语言.一个GraphQL服务是通过定义类型和类型上的字段来创建,然后给每个类型上的每个字段提供解析函数.基本用法:12345678type Query &#123; me: User &#125;type User &#123; id: ID name: String&#125; 每个类型上字段的解析函数1234567function Query_me(request) &#123; return request.auth.user;&#125;function User_name(user) &#123; return user.getName();&#125; 一个GraphQL服务运行起来(通常在web服务的一个URL上),它就能接收GraphQL查询,并验证和执行.查询会检查确保只会引用已经定义的类型和字段,然后运行指定的解析函数来生成结果12345&#123; me&#123; name &#125;&#125; 会返回一个JSON结果12345&#123; "me": &#123; "name": "hhh" &#125;&#125; 字段也能指代对象类型(Object).对这个对象的字段进行次级选择(Sub-selection).遍历相关对象及其字段,使得客户端可以一次请求查询大量相关数据.12345678910&#123; hero&#123; name # 这是注释 # 这里friens指代一个对象类型 friends &#123; name &#125; &#125;&#125; 返回结果:123456789101112131415161718&#123; "data": &#123; "hero": &#123; "name": "R2-D2", "friends": [ &#123; "name": "Luke Skywalker" &#125;, &#123; "name": "Han Solo" &#125;, &#123; "name": "Leia Organa" &#125; ] &#125; &#125;&#125; friens返回了一个数组的项目,GraphQL查询会同等看成单个项目或者一个列表项目 传递参数:1234567&#123; human(id: "1000")&#123; id name height &#125;&#125; 返回结果:123456789&#123; "data": &#123; "human": &#123; "id": "1000", "name": "Luke Skywalker", "height": 1.72 &#125; &#125;&#125; 每一个字段和嵌套对象都能有自己的一组参数,从而使得GraphQL可以替代多次API请求.可以给标量(scalar)字段传递参数,用于实现服务端的一次转换1234567&#123; human(id: "1000")&#123; name #传入参数把单位转换为英尺 height(unit: FOOT) &#125;&#125; 12345678&#123; "data": &#123; "human": &#123; "name": "Luke Skywalker", "height": 5.6430448 &#125; &#125;&#125; 别名:通过设置别名可以通过不同参数查询相同字段12345678&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125; 12345678910&#123; "data": &#123; "empireHero": &#123; "name": "Luke Skywalker" &#125;, "jediHero": &#123; "name": "R2-D2" &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>PHP</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
</search>
