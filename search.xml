<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2020%2F12%2F26%2FDocker%2F</url>
    <content type="text"><![CDATA[Dockerdocker概述发布一个项目.(jar + (redis + MySQL + jdk + …) ),带上环境一起打包. 在服务器配置一个应用环境,配置麻烦,不能够跨平台.Windows -&gt; Linux 开发打包部署上线,一套流程做完. docker解决以上问题. JRE — 多个应用(端口冲突) —原来都是交叉 隔离机制: Docker核心思想. 容器化技术不是模拟一个完整的操作系统 传统虚拟机,虚拟出一堆硬件,运行一个完整的操作系统,然后在这个系统上安装和运行文件. 容器内的应用直接运行在 宿主机的内容,容器是没有自己的内核的.也没有虚拟硬件,所以轻便. 每个容器互相隔离,每个容器内都有属于自己的一个文件系统,互不影响. DveOps(开发、运维)应用更快速地交付和部署. 传统: 一堆帮助文档,安装运行. Docker: 打包镜像发布测试,一键运行. 更便捷地升级和扩容 项目打包为一个镜像,扩展 服务器A 服务器B 更简单的系统运维 容器化后,开发和测试环境高度一致. 更高效的计算资源利用 Docker 是内核级别的 虚拟化,可以在物理的机器上运行很多容器实例,把服务器性能压榨到极致. docker的基本组成 镜像(image): docker就好比一个模板,可以通过这个模板来创建容器服务,Tomcat镜像 =&gt; run =&gt; Tomcat01容器 (提供服务器) 通过这个镜像可以创建多个容器(最终服务运行或者项目运行就是在容器中的) 容器(container): docker利用容器技术,独立运行一个或者一组应用,通过容器来创建的. 启动、停止、删除,基本命令! 容器就是一个简易的Linux系统. 仓库(repository): 仓库就是存放镜像的地方. 仓库分为共有仓库和私有仓库. 容器服务器: dockerhub 阿里云…配置镜像加速. docker安装环境查看123#系统内核 3.10 以上[root@VM-0-17-centos ~]# uname -r3.10.0-1062.18.1.el7.x86_64 1234567891011121314151617#系统版本[root@VM-0-17-centos ~]# cat /etc/os-releaseNAME="CentOS Linux"VERSION="7 (Core)"ID="centos"ID_LIKE="rhel fedora"VERSION_ID="7"PRETTY_NAME="CentOS Linux 7 (Core)"ANSI_COLOR="0;31"CPE_NAME="cpe:/o:centos:centos:7"HOME_URL="https://www.centos.org/"BUG_REPORT_URL="https://bugs.centos.org/"CENTOS_MANTISBT_PROJECT="CentOS-7"CENTOS_MANTISBT_PROJECT_VERSION="7"REDHAT_SUPPORT_PRODUCT="centos"REDHAT_SUPPORT_PRODUCT_VERSION="7" 安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#安装包sudo yum install -y yum-utils#使用阿里云镜像安装sudo yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#更新yum软件包索引yum makecache fast #安装docker docker-ce -&gt; 社区版 ee-&gt;企业版sudo yum install docker-ce docker-ce-cli containerd.io#启动dockersystemctl start docker#查看当前dockerdocker versionClient: Docker Engine - Community Version: 20.10.1 API version: 1.41 Go version: go1.13.15 Git commit: 831ebea Built: Tue Dec 15 04:37:17 2020 OS/Arch: linux/amd64 Context: default Experimental: trueServer: Docker Engine - Community Engine: Version: 20.10.1 API version: 1.41 (minimum version 1.12) Go version: go1.13.15 Git commit: f001486 Built: Tue Dec 15 04:35:42 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.4.3 GitCommit: 269548fa27e0089a8b8278fc4fc781d7f65a939b runc: Version: 1.0.0-rc92 GitCommit: ff819c7e9184c13b7c2607fe6c30ae19403a7aff docker-init: Version: 0.19.0 GitCommit: de40ad0 Hello world1234567891011121314151617181920212223242526272829303132333435#docker Hello world#运行docker hello-world 镜像docker run hello-world#本地没有找到hello-worldUnable to find image 'hello-world:latest' locally#线上代码库拉取latest: Pulling from library/hello-world#签名信息0e03bdcc26d7: Pull completeDigest: sha256:1a523af650137b8accdaed439c17d684df61ee4d74feac151b5b337bd29e7eecStatus: Downloaded newer image for hello-world:latest#启动成功~Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 查看镜像12#查看本地镜像docker images 卸载docker12345678#卸载依赖yum remove docker-ce docker-ce-cli containerd.io#删除资源rm -rf /var/lib/docker#docker的默认工作路径/var/lib/docker 腾讯云镜像加速1234567891011121314#创建docker目录mkdir -p /etc/docker#配置腾讯云镜像加速地址tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://mirror.ccs.tencentyun.com"]&#125;EOF#重载配置systemctl daemon-reload#重启dockersystemctl restart docker 底层原理docker镜像流程运行分析 底层原理 docker工作分析 docker 是一个 client - server 结构的系统,docker 的守护进程运行在主机上. 通过 socket 从客户端访问. dockerServer 接收到 dockerClient 的指令,就会执行这个命令. docker为什么比vm快 docker有比虚拟机更少的抽象层 docker 利用的是宿主机的内核,vm 需要的是 Guest OS 新建一个容器的时候,docker不需要像虚拟机一样重新加载一个操作系统的内核,避免引导. 虚拟机加载 Guest OS docker直接利用 宿主机 的操作系统 docker常用命令帮助命令 123docker version #显示版本信息docker info #显示docker信息,包括镜像和容器数量docker xxx --help #帮助命令 帮助文档:https://docs.docker.com/engine/reference/commandline/docker/ 镜像命令 docker images 查看所有本地主机镜像 12345678910111213141516# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 12 months ago 13.3kBREPOSITORY 镜像仓库源TAG 标签IMAGE ID 镜像idCREATED 创建时间SIZE 镜像大小#可选项 -a, --all #列出所有镜像 -q, --quiet #只显示镜像id docker images -aqbf756fb1ae65 docker search 搜索镜像 1234567891011121314docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10326 [OK]mariadb MariaDB is a community-developed fork of MyS… 3825 [OK]mysql/mysql-server Optimized MySQL Server Docker images. Create… 754 [OK]percona Percona Server is a fork of the MySQL relati… 518 [OK]#可选项 -f, --filter=STARS=3000 #搜索STARS大于3000的镜像 docker search mysql --filter=STARS=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10326 [OK]mariadb MariaDB is a community-developed fork of MyS… 3825 [OK] docker pull 下载镜像 123456789101112131415161718192021222324252627282930313233343536373839404142434445#下载镜像 docker pull 镜像名[:tag]docker pull mysqldocker pull mysqlUsing default tag: latest #如果不写 tag. 默认就是 latest(最新latest: Pulling from library/mysql6ec7b7d162b2: Pull complete #分层下载,docker image 核心 联合文件系统fedd960d3481: Pull complete7ab947313861: Pull complete64f92f19e638: Pull complete3e80b17bff96: Pull complete014e976799f9: Pull complete59ae84fee1b3: Pull completeffe10de703ea: Pull complete657af6d90c83: Pull complete98bfb480322c: Pull complete6aa3859c4789: Pull complete1ed875d851ef: Pull completeDigest: sha256:78800e6d3f1b230e35275145e657b82c3fb02a27b2d8e76aac2f5e90c1c30873 #签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest #真实地址#两个命令相同docker pull mysqldocker pull docker.io/library/mysql:latest#下载指定版本docker pull mysql:5.7docker pull mysql:5.75.7: Pulling from library/mysql6ec7b7d162b2: Already exists #联合文件系统,不同版本共享.fedd960d3481: Already exists7ab947313861: Already exists64f92f19e638: Already exists3e80b17bff96: Already exists014e976799f9: Already exists59ae84fee1b3: Already exists7d1da2a18e2e: Pull complete301a28b700b9: Pull complete529dc8dbeaf3: Pull completebc9d021dc13f: Pull completeDigest: sha256:c3a567d3e3ad8b05dfce401ed08f0f6bf3f3b64cc17694979d5f2e5d78e10173Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像 123456#删除指定镜像docker rmi -f 镜像id#删除多个镜像docker rmi -f 镜像id1 镜像id2#递归删除全部镜像docker rmi -f $(docker images -aq) 容器命令 有了镜像才可以创建容器. 1docker pull centos 新建容器并启动 1234567891011121314151617181920docker run [可选参数] image#参数说明--name="Name" 容器名字 Tomcat01 Tomcat02 区分容器-d 后台方式运行-it 使用交互方式运行,进入容器查看内容-p 指定容器端口 -p 8080:8080 -p 主机端口:容器端口 -p ip:主机端口:容器端口 -p 容器端口 容器端口-P 随机指定端口#测试 启动并进入容器[root@VM-0-17-centos ~]# docker run -it centos /bin/bash#查看容器内的 centos[root@4bd02727fa42 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var#从容器中退回主机[root@4bd02727fa42 /]# exit 查看当前正在运行中的容器 123456789101112#docker ps 命令 #列出当前正在运行的容器-a #列出当前正在运行的容器和历史运行过的容器-n=? #显示最近创建过的容器-q #只显示容器编号[root@VM-0-17-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-17-centos ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4bd02727fa42 centos "/bin/bash" 3 minutes ago Exited (0) About a minute ago gallant_mcclintock2a474202357b bf756fb1ae65 "/hello" 42 hours ago Exited (0) 42 hours ago vibrant_dijkstra 退出容器 12exit #停止容器并退出control + p + q #快捷键 容器不停止退出 删除容器 123docker rm 容器id #删除指定容器,不能删除正在运行的容器 rm -f 强制删除docker rm -f $(docker ps -aq) #删除所有容器docker ps -a -q|xargs docker rm #删除所有容器 启动和停止容器 1234docker start 容器id #启动容器docker restart 容器id #重启容器docker stop 容器id #停止容器docker kill 容器id #强制停止 run是创建并启动容器(run操作的是镜像),start启动已经停止的容器(操作的是容器id) 常用的其他命令 后台启动容器 12345678# 命令 docker run -d 镜像名[root@VM-0-17-centos ~]# docker run -d centos# docker ps 发现 centos 停止了# 常见的坑 docker 容器 使用后台运行,就必须要有一个前台进程.docker 一旦发现没有应用,就会停止.# nginx 容器启动后,发现自己没有提供服务,就会立刻停止,就是没有程序了. 查看日志 12345#查看日志# -t 时间戳# -f 动态显示# --tail num 显示日志条数docker logs -tf --tail 10 容器id 进程信息 12345#docker top 容器id# 查看容器信息docker inspect 容器id 进入当前正在运行容器 1234567891011#进入后台已经启动的容器#方式一docker exec -it 容器id /bin/bash#方式二docker attach 容器id#区别#docker exec -&gt; 进入容器后开启一个新的终端,可以在容器里操作.#docker attach -&gt; 进入容器正在执行的终端.不会启动新的进程. 从容器内拷贝文件到主机上 12345678docker cp 容器id:容器内路径 目标主机路径[root@VM-0-17-centos ~]# docker cp 61d98e6376ff:/home/xixi.java home[root@VM-0-17-centos ~]# lshome[root@VM-0-17-centos ~]# cd home[root@VM-0-17-centos home]# lsxixi.java Docker 安装 nginx 12345#docker 拉取 nginx[root@VM-0-17-centos ~]# docker pull nginx# -d 后台运行 --name 容器命名 -p 宿主机端口:容器内部端口[root@VM-0-17-centos ~]# docker run -d --name nginx01 -p 3344:80 nginx 端口转发 docker安装Tomcat 123456789101112131415#官方的使用docker run -it --rm tomcat:9.0#之前都是后台启动,停止容器后还是能查到 docker run -it --rm 一般用来测试.用完就删除docker pull tomcat:9.0#进入容器[root@VM-0-17-centos ~]# docker exec -it tomcat01 /bin/bash#阉割过的版本root@269815ce7ea6:/usr/local/tomcat# cd webappsroot@269815ce7ea6:/usr/local/tomcat/webapps# ls#拷贝webapps.dist文件夹里的目录到webapps.再次访问tomcatroot@269815ce7ea6:/usr/local/tomcat# cp -r webapps.dist/* webapps docker安装 es + kibana 1234567891011121314#es 暴露的端口很多#es 十分耗内存#es 数据一般需要放置到安全目录 挂载#--net somenetwork 网络配置#启动es#启动失败...es默认1.2g我的服务器LIMIT只有991.1MiBdocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2#查看状态docker stats#增加内存限制,修改配置文件 -e 配置环境修改docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xms=128m" elasticsearch:7.6.2 可视化 portainer 图形化界面管理工具 1docker pull portainer/portainer-ce Rancher(CI/CD) docker镜像理解镜像是什么 镜像是一种可执行、轻量级的独立软件包,用来打包软件运行环境和基于运行环境开发的软件,它包含运行某个软件所需的所有内容,包括代码、运行时、库、环境变量和配置文件. 所有应用,打包docker镜像,就可以直接跑起来. 如何得到镜像? 远程仓库下载直接拷贝 自己制作一个镜像DockerFile docker镜像加载原理 UnionFS(联合文件系统) Union文件系统是一种分层、轻量级且高性能的文件系统.它支持对文件系统的修改作为一次提交来一层层叠加.同时可以将不同目录挂载到同一个虚拟文件系统下.Union文件系统是docker镜像的基础.镜像可以通过分层来进行继承,基于基础镜像(没有父镜像),可以制作各种具体的应用镜像. 特性:一次同时加载多个文件系统,但从外面看来,只能看到一个文件系统,联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录. docker镜像加载原理 docker镜像实际上是由一层一层的文件系统组成的,这种层级的文件系统UnionFS boot file system 主要包含了bootloader 和 kernel,bootloader主要引导加载kernel. linux刚启动时会加载 bootfs文件系统,在docker镜像的最底层是bootfs.这一层和典型的linux/Unix系统是一样的.包含boot加载器和内核.当boot加载完成之后整个内核就在内存中了,此时内存的使用权已由bootfs转交给内核.此时文件系统也会卸载bootfs. rootfs,在bootfs之上.包含的就是典型的linux系统中的/dev,/proc,/bin,/etc等标准目录和文件.rootfs就是各种不同的操作系统发行版.比如Ubuntu、centos等等… 平时安装的centos好几G.docker才200m 对于一个精简的os.rootfs可以很小,只需要包含最基本的命令、工具和程序库就可以了.因为底层用的是host的kernel,自己只需要提供rootfs就可以了.由此可见对于不同的linux发行部,bootfs基本是一致的.rootfs会有差别,因此不同的发行版可以公用bootfs. 分层镜像 docker镜同时像采取这种分层结构.最大的好处,莫过于资源共享.比如有多个镜像都从相同的base镜像构建而来.那么宿主机只需要在磁盘上保留一份base镜像,同时内存中也只需要加载一份base镜像,这样就可以为所有容器服务了,而且镜像的每一层都可以被共享. 查看镜像分层的方式可以通过docker image inspect 命令! 理解: docker镜像都是只读.当容器启动时,一个新的可写层被加载到镜像顶部. 这一层就是通常说的容器层,容器之下都叫镜像层.]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React笔记]]></title>
    <url>%2F2020%2F10%2F08%2FReact%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[React笔记元素定义元素 const element = &lt;h1&gt;哈哈哈&lt;/h1&gt;; react中的元素类似Java的对象.react DOM 可以确保浏览器 DOM 的数据内容与 React 元素保持一致. 元素渲染定义一个div块,id对应const的变量,这个div块的所有内容都由react来管理,称为’根’DOM节点. &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; 使用react开发只会定义一个根节点. ReactDOM.render使用ReactDOM.render()方法.将react元素渲染到根节点的DOM中. 12345678910//定义块元素&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;//根据元素id,渲染页面&lt;script type=&quot;text/babel&quot;&gt;const element =&lt;h1&gt;Hello, world!&lt;/h1&gt;;ReactDOM.render( element, document.getElementById(&apos;example&apos;));&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;example&apos;) );&#125; //通过setInterval方法,每秒钟调用一次tick方法重新渲染,达到页面更新的目的setInterval(tick, 1000);&lt;/script&gt;&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById(&apos;example&apos;) );&#125;setInterval(tick, 1000);&lt;/script&gt;//创建一个 React.Component 的 ES6 类class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; //this.props 替换 props //使用 ES6 类写法,用 this.props.属性名 来取值 &lt;h2&gt;现在是 &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById(&apos;example&apos;) );&#125; setInterval(tick, 1000); JSXJSX 就是用来声明 React 当中的元素. React元素是普通的对象.React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致. 12345678910111213141516&lt;style&gt;.foo&#123; color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; //JSX语法 const element = &lt;h1 className=&quot;foo&quot;&gt;Hello, world&lt;/h1&gt;; //div定义一个React DOM根节点,通过id选择器. //通过render把元素element渲染到页面. ReactDOM.render(element, document.getElementById(&apos;root&apos;)); &lt;/script&gt;&lt;/body&gt; 12//添加自定义属性需要使用 data- 前缀&lt;p data-myattribute = &quot;somevalue&quot;&gt;这是一个很不错的 JavaScript 库!&lt;/p&gt; 在JSX中使用js表达式.使用花括号{}定义表达式 1&lt;h1&gt;&#123;1+1&#125;&lt;h1&gt; JSX不能使用if else语句 12//使用三元运算符代替&lt;h1&gt;&#123;i == 1 ? &apos;True!&apos; : &apos;False&apos;&#125;&lt;/h1&gt; 我们知道在 React 组件render() 返回的是 JSX，而 JSX 将会被 babel 转换。JSX 将被转换为 React.createElement(type, config, children)的形式。 12345678910111213141516// App.js// 转换前Class App extends Component &#123; render() &#123; return &lt;h1 id='title'&gt;Hello World&lt;h1&gt; &#125;&#125;// 转换后var App = React.createClass(&#123; render() &#123; return React.createElement('h1', &#123; id: 'title' &#125;, 'hello world') &#125;&#125;) React.createElement() 的实现位于 /src/isomorphic/classic/element/ReactElement.js 这里的 React.createElement()是用来生成虚拟 DOM 元素，该函数对组件的属性，事件，子组件等进行了处理，并返回值为一个 ReactElement 对象（单纯的 JavaScript 对象，仅包括 type, props, key, ref 等属性）。 这恰好说明了 JSX 中的 &lt;h1 id=&#39;title&#39;&gt;hello world&lt;/h1&gt;实际上是 JavaScript 对象，而不是我们通常写的 HTML 标签。 样式12345678910//定义内联样式var myStyle = &#123; fontSize: 100, color: &apos;#FF0000&apos;&#125;;//渲染样式ReactDOM.render( &lt;h1 style = &#123;myStyle&#125;&gt;哈哈哈&lt;/h1&gt;, document.getElementById(&apos;example&apos;)); 注释1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;哈哈哈&lt;/h1&gt; &#123;/*注释...*/&#125; &lt;/div&gt;, document.getElementById(&apos;example&apos;)); 数组12345678var arr = [ &lt;h1&gt;哈哈哈&lt;/h1&gt;, &lt;h2&gt;呵呵呵&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById(&apos;example&apos;)); 组件原生HTML 元素名以小写字母开头,而自定义的React类名以大写字母开头. 1234567891011function HelloMessage(props) &#123; return &lt;h1&gt;Hello World!&lt;/h1&gt;;&#125; //为用户自定义的组件const element = &lt;HelloMessage /&gt;; ReactDOM.render( element, document.getElementById(&apos;example&apos;)); 1234567891011//使用函数定义组件function HelloMessage(props) &#123; return &lt;h1&gt;Hello World!&lt;/h1&gt;;&#125;//使用ES6 class定义组件class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;; &#125;&#125; 1234567891011121314&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;function HelloMessage(props) &#123; //使用props.属性取数据. return &lt;h1&gt;Hello &#123;props.name&#125;!&lt;/h1&gt;;&#125;const element = &lt;HelloMessage name=&quot;哈哈&quot;/&gt;;ReactDOM.render( element, document.getElementById(&apos;example&apos;));&lt;/script&gt; 复合组件1234567891011121314151617181920212223function Name(props) &#123; return &lt;h1&gt;姓名：&#123;props.name&#125;&lt;/h1&gt;;&#125;function Url(props) &#123; return &lt;h1&gt;地址：&#123;props.url&#125;&lt;/h1&gt;;&#125;function Nickname(props) &#123; return &lt;h1&gt;昵称：&#123;props.nickname&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Name name=&quot;哈哈哈&quot; /&gt; &lt;Url url=&quot;c@cscar.me&quot; /&gt; &lt;Nickname nickname=&quot;芜湖起飞&quot; /&gt; &lt;/div&gt; );&#125; ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;example&apos;)); 渲染到页面渲染到页面单单声明了组件而没有渲染到页面上我们是看不见的（废话），所以我们需要使用 ReactDOM.render()将其渲染到页面指定位置上。 123456789101112131415// index.html&lt;html&gt; // ... &lt;body&gt; &lt;div id='root'&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;// index.jsimport React from 'react'import ReactDOM from 'react-dom'import App from './App.js'ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) ReactDOM.render() 的实现位于 /src/renderers/dom/client/ReactMount.js ReactDOM.render() 函数将会根据 ReactElement 的类型生成相对应的ReactComponent 实例，并调用其 mountComponent()函数进行组件加载（返回 HTML片段），递归加载所有组件后，通过 setInnerHTML 将 HTML 渲染到页面上。 判断需要生成那种 ReactComponent实例根据 ReactElement 对象的 type 属性来决定。对应 HTML 标签的 type 一般为字符串，而自定义的组件则是大写字母开头的组件函数（自定义组件需要 import，而 HTML 标签不需要）。 生成 ReactComponentReact 中生成对应的 ReactComponent实例由 instantiateReactComponent()完成，其实现位于 /src/renderers/shared/stack/reconciler/instantiateReactComponent.js ReactComponent 分为 3 种： ReactEmptyComponent: 空组件（ReactElement 的 type 属性为 null 或 false 的组件），在浏览器中返回 ReactDOMEmptyComponent。 ReactHostComponent: 原生组件（ReactElement 为string，number 或 ReactElement 的 type 属性为 string 的组件）。 createInternalComponent()：该函数用于创建原生组件，在浏览器中返回 ReactDOMComponent。 createInstanceForText() : 该函数用于创建纯文本组件，在浏览器中返回 ReactDOMTextComponent。 ReactCompositeComponent: 自定义组件（ReactElement 的 type 属性为 function） 可以发现 React 与平台解耦，使用 ReactEmptyComponent 与 ReactHostComponent。而这两种组件会根据平台的不同生成不同的组件对象，在浏览器中则为 ReactDOMEmptyComponent、ReactDOMComponent 与 ReactDOMTextComponent。 它们通过 /src/renderers/dom/stack/client/ReactDOMStackInjection.js 进行注入。 （ /src/renderers 路径下包含各个平台上不同的 ReactComponent 实现，包括 react-art/react-dom/react-native。） State123456789101112131415161718192021222324//&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;example&apos;));&lt;/script&gt; 从零开始：实现初始化渲染设置 babel首先我们需要了解 babel 如何转换 JSX：React JSX transform。 babel 可以通过transform-react-jsx插件来设置解析 JSX 之后调用的函数，默认解析为调用 React.createElement()。所以这就是为什么虽然在 JSX 代码中没有使用到 React，却仍然需要导入它。 通过配置 transform-react-jsx插件的 pragma选项可以修改解析后调用的函数。 12345678// 修改解析为调用 dom() 函数&#123; "plugins": [ ["transform-react-jsx", &#123; "pragma": "dom" // 默认 pragma 为 React.createElement &#125;] ]&#125; babel 将会把 JSX 中的标签名作为第一个参数，把 JSX 中的标签属性作为第二个参数，将标签内容作为剩余的参数。传递这些参数给 pragma 选项设置的函数。 PS: 为了方便起见，我们使用默认的解析为 React.createElement() 实现 createElementcreateElement()接受至少 2 个参数：元素类型 type（字符串表示原生元素，函数表示自定义元素），元素设置 config。其他参数视为元素的子元素 children。并且该函数返回的是一个 ReactElement 对象，属性包括 type, props, key, ref。 1234567891011121314// element.jsclass ReactElement &#123; constructor(type, props, key, ref) &#123; this.type = type this.props = props this.key = key this.ref = ref &#125;&#125;export function createElement(type, config, ...children)｛ // ... return new ReactElement(type, props, key, ref)｝ 然后需要导出 createElement，才能够通过 React.createElement() 的方式调用。 12345678// index.jsimport &#123; createElement &#125; from './element'const React = &#123; createElement,&#125;export default React ReactElement需要 props, key 与 ref 参数，这三个参数将通过处理 config 与 children 得到。 我们将从 config 中获取 key 与 ref（若它们存在的话），并且根据 config 得到 props (去除一些不必要的属性)，同时将 children 添加到 props 当中。 1234567891011121314151617181920212223242526export function createElement(type, config, ...children) &#123; let props = &#123;&#125; let key = null let ref = null if (config != null) &#123; ref = config.ref === undefined ? null : config.ref // 当 key 为数字时，将 key 转换为字符串 key = config.key === undefined ? null : '' + config.key for (let propsName in config) &#123; // 剔除一些不需要的属性（key, ref, __self, __source） if (RESERVED_PROPS.hasOwnProperty(propsName)) &#123; continue &#125; if (config.hasOwnProperty(propsName)) &#123; props[propsName] = config[propsName] &#125; &#125; props.children = children &#125; return new ReactElement(type, props, key, ref)&#125; 除此之外，添加对 defaultProps 的支持。defaultProps 的使用方式如下： 1234567// App.jsclass App extends Component &#123;&#125;App.defaultProps = &#123; name: "ahonn"&#125; 当传入 App 组件的 props 中不包含 name 时，设置默认的 name 为 “ahonn”。具体实现：当 ReactElement 的 type 属性为组件函数且包含 defaultProps 时遍历 props，若 props 中不包含 defaultProps 中的属性时，设置默认的 props。 1234567891011export function createElement(type, config, ...children) &#123; // ... if (type &amp;&amp; type.defaultProps) &#123; let defaultProps = type.defaultProps for (let propsName in defaultProps) &#123; if (props[propsName] === undefined) &#123; props[propsName] = defaultProps[propsName] &#125; &#125; &#125;&#125; 目前为止完成了将 JSX 解析为函数调用（这部分由 babel 完成），调用 React.createElement() 生成 ReactElement 对象。 接下来将实现 instantiateReactComponent()，通过 ReactELemnt 生成相对应的 ReactComponent 实例。 实现工厂方法 instantiateReactComponentinstantiateReactComponent(element)接受一个参数 element，该参数可以是 ReactElement 对象，string，number，false 或者 null。 我们将只考虑 Web 端，而不像 React 一样使用适配器模式进行解耦。 ReactElement 生成相应 ReactComponent 实例的规则： element 为 null 或 false 时，生成 ReactDOMEmptyComponent 对象实例 element 为 string 或者 number 时，生成 ReactDOMTextComponent 对象实例 element 为 object element.type 为 string 时，生成 ReactDOMComponent 对象实例 element.type 为 function（组件函数）时，生成 ReactCompositeComponent 对象实例 123456789101112131415161718192021// virtual-dom.jsexport function instantiateReactComponent(element) &#123; let instance = null if (element === null || element === false) &#123; instance = new ReactDOMEmptyComponent() &#125; if (typeof element === 'string' || typeof element === 'number') &#123; instance = new ReactDOMTextComponent(element) &#125; if (typeof element === 'object') &#123; let type = element.type if (typeof type === 'string') &#123; instance = new ReactDomComponent(element) &#125; else if (typeof type === 'function')&#123; instance = new ReactCompositeComponent(element) &#125; &#125; return instance&#125; 实现 ReactComponent现在，我们需要有不同的 ReactComponent 类以供 instantiateReactComponent()使用。同时需要实现每个类的 mountComponent() 方法来返回对应的 HTML 片段。 ReactDOMEmptyComponent ReactDOMEmptyComponent 表示空组件， mountComponent() 方法返回空字符串。 123456789class ReactDOMEmptyComponent &#123; constructor() &#123; this._element = null &#125; mountComponent() &#123; return '' &#125;&#125; ReactDOMTextComponent ReactDOMTextComponent 表示 DOM 文本组件，mountComponent()方法返回对应的字符串。 123456789101112class ReactDOMTextComponent &#123; constructor(text) &#123; this._element = text this._stringText = '' + text this._rootID = 0 &#125; mountComponent(rootID) &#123; this._rootID = rootID return this._stringText &#125;&#125; ReactDOMComponent ReactDOMComponent 表示原生组件，即浏览器支持的标签（div, p, h1, etc.）。mountConponent() 方法返回对应的 HTML 字符串。 1234567891011121314151617181920212223242526272829303132333435class ReactDomComponent &#123; constructor(element) &#123; let tag = element.type this._element = element this._tag = tag.toLowerCase() this._rootID = 0 &#125; mountComponent(rootID) &#123; this._rootID = rootID if (typeof this._element.type !== 'string') &#123; throw new Error('DOMComponent\'s Element.type must be string') &#125; let ret = `&lt;$&#123;this._tag&#125; ` let props = this._element.props for (var propsName in props) &#123; if (propsName === 'children') &#123; continue &#125; let propsValue = props[propsName] ret += `$&#123;propsName&#125;=$&#123;propsValue&#125;` &#125; ret += '&gt;' let tagContent = '' if (props.children) &#123; tagContent = this._mountChildren(props.children) &#125; ret += tagContent ret += `&lt;/$&#123;this._tag&#125;&gt;` return ret &#125;&#125; ReactDOMComponent 的 mountComponent()方法会相对复杂一点。具体实现思路是，通过 ReactElement 的 type 与 props 属性拼接对应的 HTML 标签。处理 props 的时候需要跳过 children 属性，因为需要将子组件放在当前组件中。 当存在子组件（children）时，调用 _mountChildren(children)将组件转换为对应的 HTML 片段。具体过程是遍历 children，转换为 ReactComponent 并调用其 mountComponent() 方法。 123456789_mountChildren(children) &#123; let result = '' for (let index in children) &#123; const child = children[index] const childrenComponent = instantiateReactComponent(child) result += childrenComponent.mountComponent(index) &#125; return result&#125; ReactCompositeComponent ReactCompositeComponent 表示自定义的组件，mountComponent()方法将根据提供的组件函数（element.type）实例化，并调用该组件的 render()方法返回 ReactElement 对象。再通过instantiateReactComponent() 生成对应的 ReactComponent，最后执行该 ReactComponent 的mountComponent()方法。 12345678910111213141516171819202122class ReactCompositeComponent &#123; constructor(element) &#123; this._element = element this._rootId = 0 &#125; mountComponent(rootID) &#123; this._rootId = rootID if (typeof this._element.type !== 'function') &#123; throw new Error('CompositeComponent\'s Element.type must be function') &#125; const Component = this._element.type const props = this._element.props const instance = new Component(props) const renderedElement = instance.render() const renderedComponent = instantiateReactComponent(renderedElement) const renderedResult = renderedComponent.mountComponent(rootID) return renderedResult &#125;&#125; 通过 ReactCompositeComponent 将之前的 ReactComponent 联系起来，并递归调用 mountComponent方法得到一段 HTML。最后 render()通过 node.innerHTML 将 HTML 字符串填到页面上对应的容器中 实现 render最后将之前的实现串起来，利用 innerHTML 将组件渲染到页面上。 1234567export function render(element, container) &#123; const rootID = 0 const mainComponent = instantiateReactComponent(element) const containerContent = mainComponent.mountComponent(rootID) container.innerHTML = containerContent&#125; 到这里就基本上简单的实现了 React 中将组件渲染到页面上的部分。可以通过一个简单的例子验证一下。 12345678910111213141516171819202122// index.jsimport React from './tiny-react'import ReactDOM from './tiny-react'import App from './App'ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))// App.jsimport React, &#123; Component &#125; from './tiny-react'class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;Hello Work!&lt;/span&gt; &lt;/div&gt; ) &#125;&#125;export default App 页面上将显示Hello Work!]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式_结构型模式]]></title>
    <url>%2F2019%2F12%2F02%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述设计模式总结,结构型设计模式篇. 结构型设计模式结构型设计模式,主要是改变代码的结构来达到解耦的目的.使得代码更加容易维护和扩展. 代理模式用一个代理对象来隐藏具体实现类的实现细节,通常用于在真实的实现逻辑中做增强操作(AOP). 代理指的是,对客户端隐藏真实的实现,由代理对象来负责接收客户端的所有请求.代理类只是代理,并不会完成实际业务的逻辑. 12345678910111213141516171819202122232425262728293031323334353637383940414243//真实的接口public interface PhoneService &#123; Phone makeIphone(); Phone makeP30();&#125;//真实的实现类public class PhoneServiceImpl implements PhoneService &#123; public Phone makeIphone() &#123; Phone ip = new Iphone(); ip.setSoC("A12"); return ip; &#125; public Phone makeP30() &#123; Phone p30 = new P30(); p30.setSoC("kylin980"); return p30; &#125;&#125;//代理类,必须实现真实的接口.public class PhoneServiceProxy implements PhoneService &#123; //在代理类内部创建一个真实的实现类对象,并且私有化起来. private PhoneService phoneService = new PhoneServiceImpl(); //实现接口的方法 public Phone makeIphone() &#123; System.out.println("开始生产"); //核心的实现,通过调用真实实现类对象中的方法. Phone iPhone = phoneService.makeIphone(); //增强操作 iPhone.addEarbuds("EarPods"); System.out.println("结束生产"); return iPhone; &#125; public Phone makeP30() &#123; System.out.println("开始生产"); Phone p30 = phoneService.makeP30(); System.out.println("结束生产"); return p30; &#125;&#125; 调用,通过多态的方式创建代理对象 1234//创建代理对象PhoneService phoneService = new PhoneServiceProxy();//通过代理对象调用方法phoneService.makeIphone(); 通过代理模式,可以将具体的实现方式隐藏起来,并且可以在代理类中实现切面编程的操作. AOP其实就是动态代理的过程.在Spring中,我们自己不定义代理类,Spring会帮我们动态定义代理,然后帮我们把贴上@Before,@After,@Around注解的代码动态的添加到代理类中. Spring动态代理JDK动态代理.只能对实现了接口的类生成代理,而不能针对类.JDK动态代理是利用反射机制生成一个实现代理接口的匿名类,在调用具体方法前调用InvokeHandler来处理. CGLIB动态代理.如果没有定义接口,Spring 会采用 CGLIB 进行动态代理,可以使用是针对类实现代理,主要是对指定的类生成一个子类,覆盖其中的方法.CGLIB动态代理是利用asm开源包,对代理对象类的class文件加载进来,通过修改其字节码生成子类来处理. 目标对象实现了接口 目标对象没有实现接口 默认情况下会采用JDK的动态代理实现AOP 必须采用CGLIB库,spring会自动在JDK动态代理和CGLIB之间转换 可以强制使用CGLIB实现AOP 设配器模式将一个类的接口转换成客户希望的另外一个接口.适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作.《设计模式:可复用面向对象软件的基础》 设配器模式一般分为三种.一种是默认适配器模式,对象适配器模式,类适配器模式. 默认适配器模式(Default Adapter)Apache的commons-io包作为默认适配器模式的例子. 此接口定义了很多方法,用于对文件或文件夹进行监控,一旦发生了对应的操作,就会触发相应的方法. 1234567891011public interface FileAlterationListener &#123; //对文件,文件夹的相关操作方法. void onStart(final FileAlterationObserver observer); void onDirectoryCreate(final File directory); void onDirectoryChange(final File directory); void onDirectoryDelete(final File directory); void onFileCreate(final File file); void onFileChange(final File file); void onFileDelete(final File file); void onStop(final FileAlterationObserver observer);&#125; 这个接口的问题是抽象方法太多.假如要使用这个接口就必须实现这个接口里的所有方法,但是假如只需要这个接口中的一两个方法,还是得实现这个接口的所有方法. 因此需要一个适配器,先实现这个接口的.但是所有的实现方法都是空的. 123456789101112131415161718192021222324252627//创建一个适配器类来实现这个接口public class FileAlterationListenerAdaptor implements FileAlterationListener &#123; //所有的方法都是空的 public void onStart(final FileAlterationObserver observer) &#123; &#125; public void onDirectoryCreate(final File directory) &#123; &#125; public void onDirectoryChange(final File directory) &#123; &#125; public void onDirectoryDelete(final File directory) &#123; &#125; public void onFileCreate(final File file) &#123; &#125; public void onFileChange(final File file) &#123; &#125; public void onFileDelete(final File file) &#123; &#125; public void onStop(final FileAlterationObserver observer) &#123; &#125;&#125; 调用的话,只需要自定义的类继承这个适配器就行了 123456789101112//只需要继承该适配器类,然后实现想要的方法.public class FileMonitor extends FileAlterationListenerAdaptor &#123; public void onFileCreate(final File file) &#123; // 文件创建 doSomething(); &#125; public void onFileDelete(final File file) &#123; // 文件删除 doSomething(); &#125;&#125; 对象适配器模式将一个对象当成另一个类的对象来使用. 将”鸡”当成”鸭”来使用,把”鸡”适配成”鸭”.因为现在”鸭”这个接口没有适合的实现类可以使用,所以需要适配器. 1234567891011121314151617181920212223public interface Duck &#123; //鸭子嘎嘎叫 public void quack(); //飞 public void fly();&#125;public interface Cock &#123; //鸡的咯咯叫 public void gobble(); //飞 public void fly();&#125;//一个实现类鸡的类public class WildCock implements Cock &#123; public void gobble() &#123; System.out.println("咯咯叫"); &#125; public void fly() &#123; System.out.println("鸡也会飞哦"); &#125;&#125; 要把”鸡”当成”鸭”来用.”鸭”接口有现成的fly();方法,但是没有quack();方法.这个时候就需要适配器进行适配. 12345678910111213141516171819202122//创建一个"鸡"适配器,要当成"鸭"来用,必须先实现"鸭"的接口.public class CockAdapter implements Duck &#123; //定义一个"鸡"的变量 Cock cock; //构造方法中需要一个鸡的实例,此类就是将这只"鸡"适配成"鸭"来用 public CockAdapter(Cock cock) &#123; this.cock = cock; &#125; //实现"鸭"嘎嘎叫的方法 @Override public void quack() &#123; //内部其实是一只鸡的咯咯叫 cock.gobble(); &#125; //实现"鸭"的fly()方法 @Override public void fly() &#123; cock.fly(); &#125;&#125; 调用方式 1234567public static void main(String[] args) &#123; //有一只野鸡 Cock wildCock = new WildCock(); //成功将野鸡适配成鸭 Duck duck = new CockAdapter(wildCock);&#125; 适配器模式,解决的痛点.当我们需要一只”鸭”对象,但是我们只有一只”鸡”对象.此时就需要定义一个适配器.由这个适配器作为”鸭”的类,内部的实现方式还是通过”鸡”对象来实现的. 类适配器模式123456789101112131415161718192021222324public interface Target &#123; void method1(); void method2(); void method3();&#125;public class SomeThing &#123; //大部分实现方法 public void method1() &#123; ... &#125; public void method2() &#123; ... &#125;&#125;//通过继承SomeThing的方式,SomeAdapter已经获得了大部分实现方法.public class SomeAdapter extends SomeThing implements Target &#123; void method3() &#123; //需要自己实现的方法3 ... &#125;&#125; 调用方式 123456public static void main(String[] args) &#123; target t = new SomeAdapter(); t.method1(); t.method2(); t.method3();&#125; 因为SomeAdapter已经通过继承的方式获得了SomeThing的大部分方法.所有可以直接调用. 类适配 对象适配 继承 组合 静态实现 动态实现,需要多实例化一个对象. 使用较少 使用较多 适配器模式 代理模式 将A包装成B,把A当成B来使用.A和B之间原本没有继承关系 增强原方法 桥梁模式桥梁模式,主要是代码的抽象和解耦. 首先需要一个桥梁.定义一个接口,提供接口方法. 1234//桥梁public interface DrawAPI &#123; public void draw(int radius, int x, int y);&#125; 通过实现类实现接口 1234567891011121314151617181920public class RedPen implements DrawAPI &#123; @Override public void draw(int radius, int x, int y) &#123; System.out.println("用红色笔画图，radius:" + radius + ", x:" + x + ", y:" + y); &#125;&#125;public class GreenPen implements DrawAPI &#123; @Override public void draw(int radius, int x, int y) &#123; System.out.println("用绿色笔画图，radius:" + radius + ", x:" + x + ", y:" + y); &#125;&#125;public class BluePen implements DrawAPI &#123; @Override public void draw(int radius, int x, int y) &#123; System.out.println("用蓝色笔画图，radius:" + radius + ", x:" + x + ", y:" + y); &#125;&#125; 定义一个抽象类,此类的实现类都需要使用DrawAPI接口 123456789public abstract class Shape &#123; //私有化接口 protected DrawAPI drawAPI; //提供构造方法 protected Shape (DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw();&#125; 定义抽象类的子类 123456789101112131415161718192021222324252627282930//圆形public class Circle extends Shape &#123; //半径 private int radius; //调用父类的构造方法 public Circle(int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.radius = radius; &#125; public void draw() &#123; drawAPI.draw(radius, 0, 0); &#125;&#125;// 长方形public class Rectangle extends Shape &#123; private int x; private int y; public Rectangle(int x, int y, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; &#125; public void draw() &#123; drawAPI.draw(0, x, y); &#125;&#125; 调用 12345678public static void main(String[] args) &#123; Shape greenCircle = new Circle(10, new GreenPen()); Shape redRectangle = new Rectangle(4, 8, new RedPen()); greenCircle.draw(); redRectangle.draw();&#125; 通过最终的调用方式,可以知道桥梁模式的优点是解耦.通过把接口DrawAPI作为桥梁,而各种颜色画笔的类实现了该接口.通过定义抽象类,在抽象类中使用DrawAPI接口,同时图形(圆形或者长方形)的具体实现类又继承自该抽象类,在子类中通过子类的构造器调用父类构造器中的DrawAPI接口,就可以根据具体传入的参数(颜色画笔对象),获得颜色画笔的实现类.达到解耦的目的. 简而言之,就是通过定义一个接口.把该接口的实现类作为桥梁(参数)传入.通过继承图形的抽象类,定义需要具体的DrawAPI接口对象.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式_创建型模式]]></title>
    <url>%2F2019%2F11%2F29%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述设计模式总结,创建型模式篇. 创建型模式创建型模式,主要作用是创建对象.最简单的方式就是new一个对象.通过构造器或者set方法注入属性.也可以通过设计模式提供更好的创建对象的方式. 简单工厂模式只生产同一类型的工厂模式 123456789101112131415public class PhoneFactory &#123; public static Phone makePhone(String brand) &#123; if (brand.equals("huawei")) &#123; Phone huawei = new HUAWEIphone(); huawei.addType("mate30"); return huawei; &#125; else if (brand.equals("apple")) &#123; Phone iphone = new ApplePhone(); iphone.addType("11pro"); return iphone; &#125; else &#123; return null; &#125; &#125;&#125; 简单工厂模式.一个工厂模式(xxxFactory),通过静态方法传入特定的参数,根据不同的参数,多个子类(或实现同一接口)的不同的对象(huawei&amp;apple)并返回给调用者.强调一个工厂类只生产同一个类型,PhoneFactory就只是负责生产各个类型的phone. 工厂模式当需要两个以上的工厂时. 1234567891011121314151617181920212223242526272829public interface PhoneFactory &#123; Phone makePhone(String type);&#125;public class HUAWEIPhoneFactory implements PhoneFactory &#123; @Override public Phone makePhone(String type) &#123; if (type.equals("2019")) &#123; return new Mate30(); &#125; else if(type.equals("2018")) &#123; return new Mate20(); &#125; else &#123; return null; &#125; &#125;&#125;public class ApplePhoneFactory implements PhoneFactory &#123; @Override public Phone makePhone(String type) &#123; if (type.equals("2019")) &#123; return new Iphone11(); &#125; else if(type.equals("2018")) &#123; return new IphoneXR(); &#125; else &#123; return null; &#125; &#125;&#125; 其中Mate20,Mate30,Iphone11,IphoneXR都继承自Phone. 调用代码 1234567891011public class APP &#123; public static void main(String[] args) &#123; //创建一个具体的工厂对象 PhoneFactory factoryA = new HUAWEIPhoneFactory(); //根据不同的工厂造出不一样的对象 Phone phoneA = factoryA.makePhone("2019"); PhoneFactory factoryB = new ApplePhoneFactory(); Phone phoneB = factoryB.makePhone("2019"); &#125;&#125; 虽然factory.makePhone(“2019”);都是传入同样的参数(“2019”),但是创建的对象却是不一样的. 创建工厂对象的类型,决定了生产什么品牌的phone. 抽象工厂模式涉及到统一类型(品牌)的对象,需要引入抽象工厂模式了. 前面的工厂模式,生产的对象会出现一个问题. 12345678910//生产华为的数据线type-cDatalineFactory datalineFactory = new TypeCFactory();Dataline dataline = TypeCFactory.makeDataline();//生产苹果的手机PhoneFactory applePhoneFactory = new ApplePhoneFactory();ApplePhone applePhone = applePhoneFactory.makePhone();//包装手机PhoneBox box = new box(applePhone, dataline); apple家生产的手机和华为家生产的数据线并不能通用.容易出错. 此时需要抽象工厂模式. 1234567891011121314151617181920212223242526public interface PhoneFactory &#123; Dataline makeDataline(); Phone makePhone();&#125;public class HUAWEIPhoneFactory implements PhoneFactory &#123; @Override public Phone makePhone() &#123; return new HuaweiPhone(); &#125; @Override Dataline makeDataline() &#123; return new TypeC(); &#125;&#125;public class ApplePhoneFactory implements PhoneFactory &#123; @Override public Phone makePhone() &#123; return new IPhone(); &#125; @Override Dataline makeDataline() &#123; return new Lightning(); &#125;&#125; 调用方式 1234567891011public static void main(String[] args) &#123; //根据品牌创建工厂对象 PhoneFactory pf = new ApplePhoneFactory(); //从这个品牌创建phone对象 Phone iPhone = cf.makePhone(); //从这个品牌工厂创建数据线对象 Dataline lightning = cf.makeDataline(); //将同一个品牌工厂生产的对象包装在一起 PhoneBox box = new box(iPhone, lightning);&#125; 此时不再需要单独选择Factory生产手机和数据线了.只需要选择该品牌下的Factory,会针对性的生产互相兼容的产品. 单例模式饿汉式12345678910public class Singleton &#123; //私有化该类的构造器,保证其他类无法创建该类的对象. private Singleton() &#123;&#125;; //在本类中创建该类的对象,并且私有化该类对象保证其他类无法创建. private static Singleton instance = new Singleton(); public static Singleton getInstance() &#123; return instance; &#125;&#125; 优点: 线程安全. 在类加载的同时,已经创建好一个静态对象,调用时无需再次创建. 缺点: 资源效率不高.无论是否需要用到getInstance()方法,但是在执行该类的其他静态方法或者加载了该类(class.forName)时,依然会创建对象. 懒汉式1234567891011121314151617181920public class Singleton &#123; //私有化该类的构造器,保证其他类无法创建该类的对象. private Singleton() &#123;&#125; //不需要先创建对象,volatile关键字保证变量在多线程下的可见性 private static volatile Singleton instance = null; public static Singleton getInstance() &#123; //第一次检查 if (instance == null) &#123; //加锁 synchronized (Singleton.class) &#123; //必须判断,否则会出现并发问题 if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 双重检查,两次instance是否为null. 使用volatile修饰的变量,会保证线程可见性(当多个线程访问同一个变量时,一个线程修改了这个变量的值,其他线程能够立即看得到修改的值),但是并不会保证原子性(即一个操作或者多个操作,要么全部执行并且执行的过程不会被任何因素打断,要么就都不执行) 使用volatile关键字修饰共享变量还可以禁止重排序(编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段). 比如a=1;b=2;c=a+b.变量a和b可能会发生重排序(b=2先执行),因为a和b的执行顺序并不会影响到最终c的结果(c不会重排序).这是在单线程的前提下. 如果是多线程 1234567891011121314151617public class TestVolatile &#123; int a = 1; boolean status = false; //修改状态 public void changeStatus() &#123; a = 2; status = true; &#125; public void sum() &#123; //当状态为true时,执行. if(status) &#123; int b = a + 1; &#125; &#125;&#125; a = 2;和status = true;可能会发生重排序.status = true;先被执行,从而影响最终的结果. 嵌套类1234567891011public class Singleton3 &#123; private Singleton3() &#123;&#125; //嵌套类可以访问外部类的静态属性和静态方法 private static class Holder &#123; private static Singleton3 instance = new Singleton3(); &#125; public static Singleton3 getInstance() &#123; return Holder.instance; &#125;&#125; 枚举类用枚举实现单例,它在类加载的时候会初始化里面的所有的实例,而且 JVM 保证了它们不会再被实例化,所以它天生就是单例的. 建造者模式先 new 一个 Builder,然后可以链式地调用一堆方法,最后再调用一次 build() 方法,创建需要的对象. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class User &#123; //user属性 private String name; private String password; private String nickName; private int age; //私有化构造器,防止外界创建对象. private User(String name, String password, String nickName, int age) &#123; this.name = name; this.password = password; this.nickName = nickName; this.age = age; &#125; // 静态方法,用于生成一个 Builder.可以直接使用User.builder()的方式调用. public static UserBuilder builder() &#123; return new UserBuilder(); &#125; public static class UserBuilder &#123; //和User统一属性 private String name; private String password; private String nickName; private int age; //Builder 的构造方法中强制让调用者提供必填字段 private UserBuilder() &#123; &#125; //链式调用设置各个属性值,返回 this,即 UserBuilder public UserBuilder name(String name) &#123; this.name = name; return this; &#125; public UserBuilder password(String password) &#123; this.password = password; return this; &#125; public UserBuilder nickName(String nickName) &#123; this.nickName = nickName; return this; &#125; public UserBuilder age(int age) &#123; this.age = age; return this; &#125; //build() 方法负责将 UserBuilder 中设置好的属性 注入 到 User 中。 //在注入属性之前检验 public User build() &#123; if (name == null || password == null) &#123; throw new RuntimeException("用户名和密码必填"); &#125; if (age &lt;= 0 || age &gt;= 150) &#123; throw new RuntimeException("年龄不合法"); &#125; // 还可以做赋予"默认值"的功能 if (nickName == null) &#123; nickName = name; &#125; return new User(name, password, nickName, age); &#125; &#125;&#125; 当属性很多,而且有些必填,有些选填的时候.建造者模式会使代码清晰很多. 在 build() 方法中校验各个参数比在 User 的构造方法中校验,可以让代码优雅一些. lombok 插件,使用@Builder注解 1234567@Builderclass User &#123; private String name; private String password; private String nickName; private int age;&#125; 提供了建造者模式的注解. 原型模式一个原型实例,基于这个原型实例产生新的实例,也就是clone. Object 类中有一个 clone() 方法,它用于生成一个新的对象.Java要求该类必须先实现 Cloneable 接口.如果没有实现该接口,在 clone() 的时候,就会抛出 CloneNotSupportedException 异常. java 的克隆是浅克隆,碰到对象引用的时候,克隆出来的对象和原对象中的引用都会指向同一个内存地址. 通常实现深克隆的方法是将对象进行序列化,然后再进行反序列化. 总结简单工厂模式,通过一个工厂,创建同一类型的对象. 工厂模式,需要创建对应的工厂,如果根据该工厂对象创建对应的对象. 抽象工厂模式,抽象出来一个类型,在该类型上不必关心兼容,解决存在兼容性问题. 单例模式,创建单个对象,为安全的同时,节省资源. 建造者模式,当一个类属性很多,有些必填,有些选填的时候,可以使用建造者模式.让代码更加优雅. 原型模式,了解 Object 类中的 clone() 方法相关的知识即可,用的比较少.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud]]></title>
    <url>%2F2019%2F11%2F29%2FSpirngCloud%2F</url>
    <content type="text"><![CDATA[1//TODO...]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloud</tag>
        <tag>框架</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB]]></title>
    <url>%2F2019%2F06%2F29%2FMongoDB%2F</url>
    <content type="text"><![CDATA[概述MongoDB是一个基于分布式文件存储的数据库.MongoDB是非关系数据库,数据结构非常松散,是类似json的bson格式,可以存储比较复杂的数据类型. 特点 高性能 易部署 易使用 非常方便的存储数据 对比MySQL MongoDB MySQL 数据库模型 非关系型 关系型 存储方式 虚拟内存+持久化 不同的引擎有不同的存储方式 查询语句 独特的MongoDB查询方式 传统的SQL语句 构架特点 可以通过副本集,以及分片来实现高可用 常见有单点,M-S,MHA,MMM,cluster等架构方式 数据处理方式 基于内存,将热数据存在物理内存中,从而达到高速读写 不同的引擎拥有其自己的特点 成熟度 新兴数据库,成熟度较低 拥有较为成熟的体系,成熟度较高 广泛度 NoSQL数据库中,MongoDB是较为完善的DB之一,使用人群也在不断增长 开源数据库 数据结构MongoDB属于NoSQL数据库,没有表相关概念,该数据库存储使用的是集合,集合中存储的是文档(树状结构数据) 基本操作语法 show dbs: 查询所有数据库 use 数据库名: 创建并且选中数据库，数据库已经存在则直接选中 db: 查询当前选择的数据库 db.dropDatabase(): 删除当前选中的数据库 show collections: 查询当前库中的集合 db.createCollection(“集合名”): 创建集合 db.集合名.drop(): 删除集合 注意: db.集合名 == db.getCollection(“集合名”) 数据类型String(字符串): mongodb中的字符串是UTF-8有效的Integer(整数): 存储数值。整数可以是32位或64位，具体取决于您的服务器Boolean(布尔): 存储布尔(true/false)值Double(双精度): 存储浮点值Arrays(数组): 将数组或列表或多个值存储到一个键中Timestamp(时间戳): 存储时间戳Object(对象): 嵌入式文档Null (空值): 存储Null值Symbol(符号): 与字符串相同，用于具有特定符号类型的语言Date(日期): 以UNIX时间格式存储当前日期或时间Object ID(对象ID) : 存储文档IDBinary data(二进制数据): 存储二进制数据Code(代码): 将JavaScript代码存储到文档中Regular expression(正则表达式): 存储正则表达式 语法往集合中新增文档,当集合不存在时会自动先创建集合,再往集合中添加文档,但是不要依赖自动创建集合的特性. 插入操作 db.集合名.insert(文档):往集合中插入一个文档 db.集合名.find():查询集合中所有文档 12db.users.insert(&#123;id: NumberLong(1), name: "蛤蛤", age: NumberInt(18)&#125;)db.users.insert(&#123;id: 2, name: "cscar", age: 20&#125;) 不写包装类型,默认是Double类型 更新操作123456789db.集合名.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125; ) query:update的查询条件,类似sql update查询,where的条件 update:update的对象和一些更新的操作符,sql update查询,set的值 upsert:可选,这个参数的意思是,如果不存在update的记录,是否插入objNew,true为插入,默认是false,不插入 multi:可选,MongoDB默认是false,只更新找到的第一条记录,如果这个参数为true,就把条件查出来,多条记录全部更新 writeConcern :可选，抛出异常的级别 简化方法:更新1个:db.集合名.updateOne( … )更新所有:db.集合名.updateMany( … ) 123456//修改一条数据db.users.update(&#123;name: "蛤蛤"&#125;, &#123;$set: &#123;age:22&#125;&#125;)db.users.updateOne(&#123;name: "咕咕"&#125;, &#123;$set: &#123;age:30&#125;&#125;)//修改所有数据db.users.update(&#123;name: "蛤蛤"&#125;, &#123;$set: &#123;name: "蛤蛤", age: 20&#125;&#125;, &#123;multi: true&#125;)db.users.updateMany(&#123;name: "蛤蛤"&#125;, &#123;$set: &#123;name: "呼呼", age: 22&#125;&#125;) 删除操作1234567db.集合名.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125; ) 简化方法: 删除1个: db.集合名.deleteOne(…) 删除所有: db.集合名.deleteMany(…) 参数说明: query: (可选)删除的文档条件 justOne:(可选)如果设为true或1,则只删除一个文档,如果设置不修改该参数.使用默认值false,则删除所有匹配条件的文档 writeConcern:(可选)抛出异常的级别 12345678//删除_id(文档id)为xxx的文档db.users.deleteOne(&#123;_id: objectId("xxx")&#125;)//删除1个带有name=蛤蛤的文档db.users.deleteOne(&#123;name: "蛤蛤"&#125;)//删除所有带有name=蛤蛤的文档db.users.deleteMany(&#123;name: "蛤蛤"&#125;)//删除当前数据库中所有的文档db.users.deleteMany() 查询操作 db.集合名.find(query, projection) db.集合名.find(…).pretty() query: 可选, 使用查询操作符指定查询条件 projection: 可选,使用投影操作符指定返回的键.查询时返回文档中所有的键值,只需要省略该参数即可(默认省略) 调用pretty()可以格式化查询的内容 实例1234//查询所有文档db.users.find()//查询所有文档,并且格式化打印db.users.find().pretty() 排序查询 12db.users.find().sort(&#123;字段: 1&#125;) ---&gt; 按照字段升序排列db.users.find().sort(&#123;字段: -1&#125;) ---&gt; 按照字段降序排列 分页查询 1234skip(num): 跳过num个文档,相当于startlimit(num): 限制显示num个文档,相当于pageSize如:db.users.find().skip(num).limit(num) 高级查询等值find({字段: 值}) 比较查询语法 -&gt; find({字段: {比较操作符: 值, …}}) 比较操作符 符号 表达式 &gt; $gt &lt; $lt &gt;= $gte &lt;= $lte != $ne 集合运算 $in 如: {name: {$in: [“蛤蛤”, “嘤嘤”]}} 判断存在 $exists 如: {name: {$exists: true}} 逻辑查询语法 -&gt; find({逻辑操作符: [条件1, 条件2, …]}) 逻辑操作符 符号 作用 (&amp;&amp;) $and (\ \ ) $or (!) $not 模糊查询MongoDB的模糊查询使用的js的正则表达式的语法 {name: {$regex: /^.keyword.$/}} 设置用户12345//选择admin数据库use admin//添加一个超级管理员账号db.createUser(&#123;user: "root", pwd: "admin", roles: ["root"]&#125;)//user:账号 pwd:密码 roles:角色-&gt;root超级管理员 Spring Boot Data MongoDB依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 配置连接参数123456# application.properties# 配置数据库连接# 格式:MongoDB: //账号:密码 @ip:端口/数据库?认证数据库spring.data.mongodb.uri=mongodb://root:admin@localhost(端口)/数据库?authSource=admin# 配置mongoTemplate的执行日志logging.level.org.springframework.data.mongodb.core=debug 注入mongoTemplate 使用mongoTemplate对象的api方法 12@Autowiredprivate MongoTemplate mongoTemplate; mongoTemplate.方法名() 作用 insert(type, collectionName) 往集合中添加文档,返回的对象中包含数据库生成的_id updateFirst(query, update, collectionName) 更新集合中第一个找到的方法 updateMulti(…) 更新集合中所有找到的文档 remove(query, collectionName) 删除集合中找到的所有文档 findById(id, class, collectionName) 返回根据id找到的文档 findAll(class, collectionName) 查询集合中所有的文档 find(query, class, collectionName) 根据条件查询集合中的文档 update —&gt; 设置更新的内容 query —&gt; 通过Query对象的addCriteria把条件封装到Query对象中 class —&gt; Xxx.class,根据反射创建对象. 条件限定Query对象用于封装查询条件,配合Criteria一起使用,来完成各种条件的描述 Criteria对象设置了一个限定条件 Criteria.where(“key”).is(value) //设置了一个等值条件 Criteria.orOperator(Criteria对象,…) //设置一个或多个或的条件 andOperator //设置一个或多个与的条件 Criteria.where(String key).regex(String regex); //模糊查询 Query对象.addCriteria(Criteria criteria); //添加查询条件 Query对象.skip(start).limit(pageSize); //分页查询 123456789101112@Testpublic void testQuery3() &#123; Criteria name = Criteria.where("name").is("cai xv kun"); Criteria age = Criteria.where("age").lt(30); //"或者"条件 Criteria criteria = new Criteria().orOperator(name, age); Query query = new Query(); query.addCriteria(criteria); List&lt;User&gt; users = mongoTemplate.find(query, User.class, "users"); System.err.println(users);&#125;]]></content>
      <categories>
        <category>非关系型数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F06%2F28%2FRedis%2F</url>
    <content type="text"><![CDATA[概述NoSQL泛指非关系型数据库,采用区别于非关系型数据库的设计.主要针对关系型数据库的缺陷来设计. 键值存储:Redis多用于项目的高速缓存 文档存储:MongoDB多用于社交类型的应用 文件存储: FastDFS 多用于以文件为载体的在线服务,如相册网站/视频网站等等 列式存储: HBase 主要用于数据分析领域 Redis的数据结构Redis属于键值存储的NoSQL数据库.一个极其高性能的超大map 缺陷: Redis中事务只有同时成功,没有同时失败. 没有表的概念和表相关的操作 单线程执行,没有并发的线程安全问题 五大数据类型 string hash list set zset 特点 性能高,能高达10w次读/s,8w次写/s 具有比较简单的acid 单线程,每个操作都是原子操作,acid Redis支持的数据类型string类型 命令 作用 set key value 存入键值对 get key 根据键取出值 getset key value 返回旧值后存入新值 incr key 把值递增1 decr key 把值递减1 incrby key num 偏移值 append key ‘value’ 在原值后拼接新内容 setnx key value 存入键值对,键存在时不存入 setex key timeout value 存入键值对,timeout表示失效时间,单位s setrange key index value 存入键值对,timeout表示失效时间,单位s setex key timeout value 批量存入键值对 setex key timeout value 批量取出键值 del key 批量取出键值 hash类型 命令 作用 hset key hashkey hashvalue 存入一个hash对象 hget key hashkey 根据hash对象键去取值 hincrby key hashkey 递增值,递增hashkey对应的值 hexists key hashkey 判断hash对象是含有某个键 hlen key 获取hash对象键的数量 hkeys key 获取hash对象的所有键 hvals key 获取hash对象的所有值 hgetall key 获取hash对象的所有数据 hdel key hashkey 根据hashkey删除hash对象键值对 同样有hsetnx,其作用跟用法和setnx一样 list类型 命令 作用 rpush key value 往列表右边添加数据 lpush key value 往列表左边添加数据 lpop key value 弹出列表左边的数据 rpop key value 弹出列表右边的数据 lrange key start end 范围显示列表数据,全显示则设置0 -1 linsert key before/after refVal newVal 参考值之前/之后插入数据 lset key index value 根据索引修改数据 lrem key count value 在列表中按照个数删除数据 ltrim key start end 范围截取列表 lindex key index 范围截取列表 ltrim key start end 范围截取列表 set类型 命令 作用 sadd key value 往set集合中添加元素 smembers key 列出set集合中的元素 srem key value 删除set集合中的元素 spop key count 随机弹出集合中的元素 sdiff key1 key2 返回key1中特有元素 sdiffstore var key1 key2 返回key1中特有的元素存入另一个set集合 sinter key1 key2 返回两个set集合的交集 sinterstore var key1 key2 返回两个set集合的交集存入另一个set集合 sunion key1 key2 返回两个set集合的并集 sunionstore var key1 key2 返回两个set集合的并集并存入另一个set集合 smove key1 key2 value 把key1中的某元素移入key2中 scard key 返回两个set集合的并集 sismember key value 返回两个set集合的并集 srandmember key count 随机获取set集合中的元素 zset类型 命令 作用 zadd key num name 存入数值和名称 zrange key start end 按照数值升序输出名称 zrangebyscore key min max [withscore] 按照数值范围降序输出名称 zrem key name 删除名称和数值 zincrby key num name 偏移名称对应的数值 zrank key name 升序返回排名 zrevrank key name 降序返回排名 zremrangebyscore key min max [withscores] 根据分数范围删除元素 zremrangebyrank key start end 根据排名删除元素 zremrangebyrank key start end 根据排名删除元素 zremrangebyrank key start end 根据排名删除元素 Redis的管理命令 命令 作用 exists key 判断某个key是否存在 expire key 设置key的过期时间 persist key 取消key的过期时间 select index 切换数据库索引,范围是0 ~ 15共16个分区 move oldkey newkey 把oldkey重命名为newkey info 查看当前服务器信息 flushdb 清空当前库中的数据 flushall 清空所有库中的数据 Redis缓存123456789101112//业务层方法public User get(Long id) &#123;User user = null; //避免多个对象的key一致,采用全限定名:id的形式来作为缓存的key String cacheKey = "cn.wolfcode.xxx.domain.User:"+id; //从redis中取出数据String cacheVal = jedis.get(cacheKey);if (cacheVal == null) &#123;//redis中没有数据,再从关系型数据库中查询user = userMapper.selectByPrimaryKey(id); //把查询到的结果存到redis中jedis.set(cacheKey, JSON.toJSONString(user));&#125; else &#123; //redis中有数据,再把该数据解析成一个User对象 user = JSON.parse(cacheVal, User.class);&#125; return user;&#125; Redis集群模式 哨兵模式,如果发现master宕机,就会在剩下的服务器中,通过选举算法选择其他服务器]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot]]></title>
    <url>%2F2019%2F06%2F24%2FSpring-Boot%2F</url>
    <content type="text"><![CDATA[Spring Boot概述:设计目的是用来简化新Spring应用的初始搭建以及开发过程. 该框架使用了特定的方式来进行配置, 从而使开发人员不再需要定义样板化的配置. AnnotationConfig配置IoC:定义:使用注解彻底替代XML文件,把Bean定义到Java配置类中. 注解 作用 @Configuration 贴在配置类上,声明该类为Spring配置类 @Bean 贴在配置类的方法上,该方法的返回对象交给Spring容器管理 @ComponentScan 贴在配置类上,开启组件扫描器,默认扫描当前配置类所在的包,可指定包 AnnotationConfigApplicationContext: 该类是ApplicationContext接口的实现类,该对象是基于AnnotationConfig的方式来运作的Spring容器 注解方式声明自己定义的配置类 注解 作用 @Configuration 表示该类是Spring的配置类 @ComponentScan 开启组件扫描器,默认扫描当前类所在的包,及其子包 当扫描的包不是当前类所在的包时,可以通过注解中的value属性来修改扫描的包. 组件扫描的方式只能扫描我们自己写的组件,如果某个bean不是我们自己写的,例如:连接池.则还是要通过在配置类中定义方法来处理,两者是可以同时存在的. SpringTest方式加载配置类@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes={配置类1.class, 配置类2.class, …}):配置classes属性来指定哪些类是配置类 Bean标签在@bean标签中id,name,init-method,destroy-method,scope等属性来完成对应的配置. @Bean注解中的属性 属性名 作用 @name 用于给name取别名 @initMethod 配置bean的初始化方法 @destroyMethod 配置bean的销毁方法 @Scope 属性名prototype,配置多例,默认是单例 AnnotationConfig方式配置DI:前提: 先要把贴@bean,把bean交给Spring管理,然后在把bean注入过去,再使用setter方法设置关系. 把需要注入的Bean对象作为参数传入到另一个Bean的方法声明中,形参名称最好跟Bean的id一致 1234567//在声明SomeBean的方法形参中直接注入OtherBean对象@Beanpublic SomeBean someBean(OtherBean otherBean) &#123; SomeBean someBean = new SomeBean(); someBean.setOtherBean(otherBean); return someBean;&#125; 配置文件导入在Spring项目中,用到多个配置文件,分别配置不同的组件.最后关联到主配置文件中 使用注解@Import 1234567//主配置类 @Configuration @Import(OtherConfig.class) //在主配置类中关联分支配置类 public class MainConfig &#123; ... &#125; //分支配置类 @Configuration public class OtherConfig &#123; ... &#125; 在主配置类中关联XML配置 使用注解@ImportResource 1234//主配置类@Configuration@ImportResource("classpath:applicationContext.xml") //在主配置类中关联XML配置public class MainConfig &#123; ... &#125; 导入属性文件使用注解@PropertySource + @Value 12345678910111213141516171819202122232425/*** @PropertySource:把属性配置加载到Spring的环境对象中 * @Value:从Spring环境对象中根据key读取value*/@Configuration@PropertySource("classpath:db.properties")public class AnnotationConfig &#123; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; @Bean(initMethod="init", destroyMethod="close") public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 或者直接在配置类中注入Spring的环境对象 12345 /** * environment:表示Spring的环境对象,该对象包含了加载的属性数据 */ @Autowired private Environment environment; 123dataSource.setUrl(environment.getProperty("jdbc.url"));dataSource.setUsername(environment.getProperty("jdbc.username"));dataSource.setPassword(environment.getProperty("jdbc.password")); 切换运行环境 Spring Boot 的web对于Spring Boot项目来说无论是普通应用还是web应用打包方式都是jar包即可,web也可以打成war包.但是需要额外添加其他插件,比较麻烦. 模块 作用 spring-boot-starter-parent 管理和导入基础依赖 spring-boot-starter-web 集成了web应用所需的环境和工具 @SpringBootApplication 三大注解功能的集成 SpringApplication.run(..) 启动SpringBoot应用,加载自定义的配置类,启动嵌入的Tomcat服务器 @SpringBootApplication三大注解功能 @ComponentScan: 开启组件扫描 @SpringBootConfiguration: 作用等同于@Configuration注解,也是用于标记配置类 @EnableAutoConfiguration: 加载jar包中META-INF/spring.factories文件中配置的配置对象,自动配置定义的功能,包括: AOP / PropertyPlaceholder / FreeMarker / HttpMessageConverter / Jackson /DataSource / DataSourceTransactionManager / DispatcherServlet / WebMvc 等等 AutoConfigurationImportSelector自动配置类中的getCandidateConfigurations方法,加载spring.factories,其中有很多配置对象. SpringBoot项目的独立运行需要spring打包插件—&gt;spring-boot-maven-plugin 使用maven的package命令进行打包 使用命令java -jar xxx.jar运行jar包 spring boot 目录结构 SpringBoot参数配置application.properties优先级 一个项目中可以有多个application.properties文件存放在不同目录中,此时他们会遵循固定的优先级来处理有冲突的属性配置 项目/config/application.properties ——&gt;最高 项目/application.properties classpath:config/application.properties classpath:application.proper ——&gt;最低(常用) 属性绑定使用@Value绑定单个属性 @ConfigurationProperties绑定对象属性,可以把同类的配置信息自动封装成实体类 1234567//贴在类上@Component@ConfigurationProperties("jdbc")public class MyDataSource &#123; private String username; private String password;&#125; 或者 123456//贴在方法上@Bean@ConfigurationProperties("jdbc")public MyDataSource myDataSource() &#123; return new MyDataSource();&#125; 静态资源 Spring Boot默认会从classpath下的/static,/public,/resources,/META-INF/resources寻找静态资源 可以通过修改spring.resources.staticLocations来修改静态资源加载地址 文件上传必须去配置文件所在的路径 集成FreeMarker只需添加starter工具包 12345 &lt;!-- SpringBoot集成FreeMarker的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 统一异常处理自定义一个控制器增强器,专门用于统一异常处理 使用@ControllerAdvice注解: —&gt; 控制器增强器 12345678@ControllerAdvice //控制器增强器public class ExceptionControllerAdvice &#123; @ExceptionHandler(Exception.class) //处理什么类型的异常 public String handlException(Exception e, Model model) &#123; model.addAttribute("msg", e.getMessage()); return "errorView"; //逻辑视图名称 &#125;&#125; 集成Druid12345678910111213141516 &lt;!-- druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- SpringBoot集成jdbc的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 两种配置方式第一种:配置对象方式 12345#application.propertiesjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///rbac?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8jdbc.username=rootjdbc.password=admin 在java的方法上,使用@ConfigurationProperties注解绑定对象属性. 12345@Bean(initMethod="init", destroyMethod="close")@ConfigurationProperties("jdbc")public DruidDataSource dataSource() &#123; return new DruidDataSource();&#125; 第二种:自动配置方式 12345678#application.properties#自动配置连接池spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql:///rbac?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=admin 集成Mybatis123456&lt;!--mybatis集成到SpringBoot中的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 123456789101112#application.properties #之前在XML配置了哪些属性在这里就配置哪些属性,属性前缀#懒加载mybatis.configuration.aggressive-lazy-loading=truemybatis.configuration.lazy-load-trigger-methods=clone#扫描mapper文件mybatis.mapper-locations=classpath:me/cscar/xxx/mapper/*Mapper.xml#配置全限定名mybatis.type-aliases-package=me.cscar.xxx.domain#连接池对象不用配置,会自动注入#打印SQL日志 logging.level.包名=trace 在MyBatis框架使用注解操作数据库在mapper接口中的抽象方法中贴上各自对应的注解 在属性中写SQL语句 12@Insert("插入的SQL语句")//插入@Select("查询的SQL语句")//查询 查询后需要封装对象使用@Results注解 12345@Results(&#123; @Result(id=true, property="id", column="id"), @Result(property="name", column="name"), @Result(property="age", column="age")&#125;) Mapper接口扫描器只要在配置类上贴个注解@MapperScan(…)即可 事务管理12345&lt;!-- AOP织入的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt; 注解方式 在配置类(AppConfig)上贴@EnableTransactionManagement —&gt; 开启事物管理 (2.x)版本以上不需要配置 业务层实现类上或者其方法上直接贴 @Transactional注解 —&gt; 对业务操作做事物管理 SpringBoot默认优先选择CGLIB代理 如果需要改为优先使用JDK代理,则配置spring.aop.proxy-target-class=false #优先使用JDK代理 拦截器让自定义的拦截器实现WebMvcConfigurer接口,重写addInterceptors方法即可 123456789101112@SpringBootApplicationpublic class AppConfig implements WebMvcConfigurer &#123; public static void main(String[] args) &#123; SpringApplication.run(AppConfig.class, args);&#125;public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new AppConfig) //传入自定义拦截器对象 // 对哪些资源起过滤作用 .addPathPatterns("/**") // 对哪些资源起排除作用 .excludePathPatterns("/..");&#125; &#125;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端分离]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[REST设计 /users /sessions 路由地址加上s 前后端分离 core项目 存放domain/mapper/service/query/util/db等 注意:core打包方式为jar parent项目 由于每个项目的pom依赖版本要相同,所以抽出一个项目来装pom. api,domain,core通过继承来获取parent的pom 注意:每个项目都要加上自己项目名字的包名,方便分辨 注册 注册接口 资源地址:/users 请求动作:post 请求参数:昵称/邮箱/密码(用user接收) 返回结果:JsonResult domain 性别设置值和对应的性别,默认为未知 service 由于注册页面里面缺少一些值,所以要在service配置默认值 设置头像和背景图 app 在公共代码中定义api的域名和端口baseUrl ajax跨域请求在api模块的mvc.xml中配置spring许可12345678&lt;mvc:cors&gt; &lt;mvc:mapping path="/**" allowed-origins="http://localhost:8080" allowed-methods="GET, POST, PUT, DELETE, OPTIONS" allowed-headers="Content-Type,Origin,Accept,Access-Control-Allow-Headers, Authorization, X-Requested-With" allow-credentials="true" max-age="180"/&gt;&lt;/mvc:cors&gt; 属性 作用 allowed-origins 授权可以访问的客户端域名 allowed-methods 表明服务器支持的请求的方法 allowed-headers 表明服务器支持的头信息字段 allow-credentials 允许客户端携带跨域cookie，此时origin值不能为“*” max-age 授权的有效期时间 在前端页面,配置浏览器许可 1234567//为所有的ajax请求设置默认属性$.ajaxSetup(&#123; crossDomain: true, //允许跨域 xhrFields: &#123; withCredentials: true &#125; //允许携带跨域的cookie&#125;); 使用ajax跨域 登录 登录接口(会话session) 资源路径 /sessions 请求动作 post 请求参数 邮箱/密码 (用user对象接收) 返回结果 JsonResult 登录成功后对session的缓存 sessionStorage登录成功的时候,把用户信息存储到浏览器sessionStorage,作为页面的缓存 1sessionStorage.setItem("user",JSON.stringify(data.data)); JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串 能够存放session,以key,value方式存放 注意value是字符串格式 JsonResult定义一个data(Object类型)来接收用户对象 当controller判断登录成功后,将得到的user对象存入data中,返回给前台 前台拿到user后要转化为json字符串才能存入sessionStorage 个人信息的数据渲染jrender插件 jrender.min.js 将sessionStorage中的jsson字符串转化成js对象,然后进行数据渲染 通过配置将数据显示在页面上 注销 注销接口(会话session) 资源路径 /sessions 请求动作 delete 请求参数 无 返回结果 JsonResult/204状态码 注意 在清除session后,在app项目中还要清除sessionStorage 因为注销界面是在侧边栏,所以应该跳转父窗口而不是跳转该侧边栏 过滤操作 在个人信息页面进行过滤,没有登录则跳转登录页面 创建一个checkLogin.js文件 判定sessionStorage的字符串 有则将字符串转化成js对象 没有则跳转至登录页面(parent)]]></content>
      <categories>
        <category>ajax</category>
        <category>spring mvc</category>
        <category>json</category>
      </categories>
      <tags>
        <tag>前后端分离</tag>
        <tag>ajax跨域请求</tag>
        <tag>发送json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful]]></title>
    <url>%2F2019%2F06%2F13%2FRESTful%2F</url>
    <content type="text"><![CDATA[RESTful每一个实体就是一个资源,也可以说是一个具体信息,每一个资源都有一个特定的url(传统资源定位符) 表现层资源是一种信息实体,,它可以有多种外在表现形式,我们把资源呈现出来的形式叫做“表现层” url值代表资源的实体,不代表形式. HTTP请求头信息中,用Accept(期望)和content-type字段指定对表现层的描述 状态转化http是无状态协议,所有状态都保存在服务器端,如果客户端要操作服务器,必须让服务器发生“形态转化” 新增：从无到有 状态的变化 更新：从某个状态变成另外一种状态的转化 删除：从有到无 状态的变化 7个HTTP方法 GET 从服务器取出资源(一项或多项) POST 在服务器新建一个资源 PUT 在服务器更新资源(客户端提供改变后的完整资源) PUT更新整个对象 user DELETE 在服务器更新资源(客户端提供改变的属性) PATCH 从服务器删除资源 HEAD 获得一个资源的元数据，比如一个资源的hash值或者最后修改日期 OPTIONS 获得客户端针对一个资源能够实施的操作;(获取该资源的api(能够对资源做什么操作的描述)HTTP头信息（可自定义） content-typeHTTP响应状态代码（可自定义）这些就是HTTP1.1协议提供的统一接口 请求头1.一个API可以允许返回JSON，Xml甚至HTML等文档格式；建议使用json；2.以前通过URL来规定获取得格式类型，比如https://api.example.com/employee.json；https://api.example.com/employee.html等； 但是更建议使用Accept这个请求头； Accept与Content-Type的区别1.Accept属于请求头， Content-Type属于实体头。Http报头分为通用报头，请求报头，响应报头和实体报头。请求方的http报头结构：通用报头|请求报头|实体报头响应方的http报头结构：通用报头|响应报头|实体报头 2.Accept代表发送端（客户端）希望接受的数据类型。比如：Accept：application/json;代表客户端希望接受的数据类型是json类型,后台返回json数据 Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型比如：Content-Type：application/json;代表发送端发送的数据格式是json, 后台就要以这种格式来接收前端发过来的数据. 二者合起来，Accept:application/json；Content-Type:application/json;即代表希望接受的数据类型是json格式，本次请求发送的数据的数据格式也是json格式. 注解@RequestMapping的属性 value/path：映射路径 method：限定请求的方式,枚举：GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE params：限定要处理请求的参数,只有匹配该参数的请求,才会被该方法处理 headers：限定要处理请求的请求头信息,只有匹配该请求头内容的请求,才会被该方法处理 consumes消费： 指定处理请求的提交内容类型 produces生产: 指定返回的内容类型,仅当request请求头中的(Accept)类型中包含该指定类型才返回.方法仅处理request请求中Accept头中包含了”application/json”的请求,同时暗示了返回的内容类型为application/json. @PathVariable参数别名 @RestController相当于@Controller所有的方法自动添加上@ResponseBody @requestBody注解常用来处理content-type不是默认的application/x-www-form-urlcoded编码的内容. 比如说:application/json或者是application/xml等,一般情况下来说常用其来处理application/json类型 通过@requestBody可以将请求体中的JSON字符串绑定到相应的bean上，当然，也可以将其分别绑定到对应的字符串上]]></content>
      <categories>
        <category>api</category>
        <category>规范</category>
      </categories>
      <tags>
        <tag>rest</tag>
        <tag>规范</tag>
        <tag>api接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro框架]]></title>
    <url>%2F2019%2F06%2F03%2FShiro%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Shiro Apache Shiro是Java的一个安全框架. 用于身份认证,,授权,加密和会话管理与WEB集成,缓存. Shiro架构 组件 作用 Subject 当前访问系统的用户,进行认证的主体.getSubject()获取当前用户,委托Shiro实现功能. SecurityManager 安全管理器,负责与shiro的其他组件进行交互,实现Subject委托的各种功能. Realms 数据源,Realms是shiro与数据库之间的连接器,shiro从自定义的Realms查找相关的数据进行比对,检验. Authenticator 认证器,用于协调协调一个或者多个Realm,从Realm指定的数据源取得数据之后,进行认证. Authorizer 授权器,决定用户是否拥有执行指定操作的权限. SessionManager 会话管理 CacheManager 缓存组件,用于缓存认证信息等 Cryptography Shiro提供了一个加解密的命令行工具jar包 shiro构架核心 Subject SecurityManager Realms 用户登录认证—&gt;Authenticator 访问授权—&gt;Authorizer Shiro认证依赖包 包 作用 shiro-core shiro核心 shiro-web shiro的Web模块 shiro-spring shiro和Spring集成 shiro-ehcache shiro底层使用的ehcache缓存 认证流程图: 认证操作配置shiro.ini文件,用于被shiro读取ini里配置的用户信息 使用shiro相关Api进行认证 123456789101112131415161718192021222324@Testpublic void testShiro() &#123; //1. 加载shiro.ini配置文件，得到配置中的用户信息(账号+密码) IniSecurityManagerFactory factory = new IniSecurityManagerFactory("classpath:shiro.ini"); //2.创建Shiro安全管理器对象 SecurityManager instance = factory.getInstance(); //3.将创建的安全管理器添加到运行环境中,告诉shiro使用哪个安全管理器 SecurityUtils.setSecurityManager(instance); //4.获取登录的用户主体对象 Subject subject = SecurityUtils.getSubject(); //创建用户登录的身份凭证,封装令牌对象,携带用户数据 UsernamePasswordToken token = new UsernamePasswordToken("haha", "555"); System.out.println("登录前的认证状态"+subject.isAuthenticated()); //登录认证,将用户的和ini配置中的账号密码做匹配 subject.login(token); System.out.println("登录前的认证状态"+subject.isAuthenticated());&#125; SecurityUtils.getSubject(); 获取用户主体对象,调用login方法委托shiro进行登录的认证操作. factory.getInstance(); 创建安全管理器对象 添加到运行环境,告诉shiro使用哪个安全管理器调用Authenticator进行认证操作 异常信息UnknownAccountException** —&gt; 账号错误 IncorrectCredentialsException—&gt; 密码错误 shiro认证流程分析 在DelegatingSubject,调用login()方法,传入当前的subject对象和封装好的用户令牌. 在DefaultSecurityManager方法中,如果认证方法(令牌)失败.则抛出异常,调用onFailedLogin方法.成功则调用onSuccessfulLogin方法,传入token 在AbstractAuthenticator中,调用doAuthenticate方法,传入token 在ModularRealmAuthenticator中,getRealms拿到数据源,判断数据源个数调用不同的方法 AuthenticatingRealm,根据账户信息doGetAuthenticationInfo(重写),拿到用户的认证信息.然后做账户的认证和密码的认证. 在SimpleAccountRealm根据token.username获取账户对象.被锁,凭证过期抛异常,最终返回账户信息给调用者.然后继续验证密码. 在SimpleCredentialsMatcher拿到凭证匹配器,拿到token和账户对象比对 有异常回到onFailedLogin,没有异常onSuccessfulLogin 自定义Realm 需要的账户信息通常来自程序或数据库中,需要自定义Realm. 继承AuthorizingRealm(需要缓存,认证,授权所有的功能) 重写doGetAuthenticationInfo()方法 返回AuthenticationInfo对象 获取数据源123456789101112131415161718192021//获取认证信息//authenticationToken:用户的账号密码信息对象@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //获取用户账号 String username = (String) authenticationToken.getPrincipal(); //根据用户的账号去数据库查询真实的用户信息 Employee currentEmp = employeeMapper.selectByName(username); if (currentEmp != null) &#123; //currentEmp:作为身份对象使用,因为在后面需要使用到当前登录用户的信息 return new SimpleAuthenticationInfo( currentEmp,//身份信息 currentEmp.getPassword(),//凭证 ByteSource.Util.bytes(currentEmp.getName()),//盐 this.getName()//Realm名称 ); &#125; return null;&#125; 通过配置修改SecurityManager中的默认Realm的使用 1234#自定义Realm信息CrmRealm=me.cscar.rbac.shiro.CRMRealm#将CrmRealm设置到当前的环境中securityManager.realms=$CrmRealm 预处理操作 在认证之前,需要进行预处理.使用过滤器进行过滤操作. 在web.xml上配置shiroFilter过滤器 12345678910&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.DelegatingFilterProxy &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; shiro过虑器,DelegatingFilterProx会从spring容器中找shiroFilter,所以过滤器的生命周期还是交给Spring进行管理的. 配置操作为了方便对shiro的相关配置进行管理,分离出一个shiro.xml配置文件,在mvc.xml中引用 使用安全管理器DefaultWebSecurityManager,并且在该安全管理器中指定自定义的Realm 1234567&lt;!--配置安全管理器--&gt;&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="CrmRealm"/&gt; &lt;!--将自定义的Realm注入到安全管理器--&gt; &lt;property name="cacheManager" ref="cacheManager"/&gt;&lt;/bean&gt; 在shiro.xml中指定系统资源所需要的具体过滤器 123456789101112131415161718192021&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!--引用指定的安全管理器--&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;property name="loginUrl" value="/login.html"/&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; /js/**=anon /images/**=anon /css/**=anon /logout.do=logout /**=authc &lt;/value&gt; &lt;/property&gt; &lt;!--设置当前使用的认证过滤器--&gt; &lt;property name="filters"&gt; &lt;map&gt; &lt;entry key="authc" value-ref="crmFormAuthenticationFilter"&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 过滤器 过滤器名称 作用 anon 匿名拦截器,即不需要登录即可访问.一般用于静态资源过滤 authc 表示需要认证(登录)才能使用 authcBasic Basic HTTP身份验证拦截器 roles 角色授权拦截器,验证用户是否拥有资源角色 perms 权限授权拦截器,验证用户是否拥有资源权限 rest rest风格拦截器,自动根据请求方法构建权限字符串 ssl SSL拦截器,只有请求协议是https才能通过.否则自动跳转会https端口 在自定义的Realm中使用注解,让安全管理器能够找到指定的Realm. 注解的目的是把自定义的Realm交给Spring管理 1@Component("CrmRealm") 前端请求在前端使用ajax发生异步请求的方式,需要后端返回一个json格式的数据 1234567891011&lt;script type="text/javascript"&gt; $(function()&#123; $("#btn_submit").click(function () &#123; $.post("/login.html", $("#loginForm").serialize(), function(data) &#123;&#125;) &#125;);&lt;/script&gt; if(data.success)&#123; window.location.href="/employee/list.do";&#125;else&#123; $.messager.alert("温馨提示",data.msg);&#125; &#125;) 后端的处理操作 Shiro默认会在FormAuthenticationFilter调用onLoginFailure()和onLoginSuccess()方法对认证的结果进行处理. 因此需要继承FormAuthenticationFilter重写这两个方法 123456789101112131415161718192021222324252627282930//登录成功处理@Overrideprotected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception &#123; response.setContentType("text/json;charset=UTF-8"); JsonResult jsonResult = new JsonResult(); response.getWriter().print(JSON.toJSONString(jsonResult)); return false;&#125;//登录失败处理@Overrideprotected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) &#123; try &#123; response.setContentType("text/json;charset=UTF-8"); JsonResult jsonResult = new JsonResult(); jsonResult.mark("账号或密码错误"); response.getWriter().print(JSON.toJSONString(jsonResult)); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return false;&#125; 将继承自FormAuthenticationFilter的过滤器设置为当前使用的过滤器 1234567&lt;property name="filters"&gt; &lt;!--设置当前使用的认证过滤器--&gt; &lt;map&gt; &lt;entry key="authc" value-ref="crmFormAuthenticationFilter"&gt; &lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; Shiro封装了登录业务逻辑,根据请求判断访问登录页面,还是在登录页面中发送登录请求. get-&gt;访问登录页面 post-&gt;登录请求 Shiro授权获取授权信息 在自定义的Realm中重写doGetAuthorizationInfo()方法,获取数据库中的权限信息,根据对应的权限为当前用户授权 判断是否管理员,获得全部权限 根据当前用户的id查询所有对应的角色编号 查询当前用户的所有权限表达式 封装到AuthorizationInfo对象中 123456789101112131415161718192021222324//获取授权信息@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; //获取当前登录用户的角色和权限,封装到AuthorizationInfo对象中并返回 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //如果当前用户是admin管理员,获得所有权限 *:* Employee currentEmp = (Employee) principalCollection.getPrimaryPrincipal(); if (currentEmp.isAdmin()) &#123; info.addRole("admin"); info.addStringPermission("*:*"); &#125; //如果不是超级管理员,则去数据库查询当前用户的权限,然后授权 //查询当前用户的信息(sn)编号 List&lt;String&gt; sns = roleMapper.selectSNByEmpid(currentEmp.getId()); //查询当前用户的权限信息 List&lt;String&gt; expressions = permissionMapper.selectExpressionByEmpId(currentEmp.getId()); info.addRoles(sns); info.addStringPermissions(expressions); return info;&#125; 使用Shiro提供的权限注解Controller的方法上贴上Shiro提供的权限注解(@RequiresPermissions) logical属性: Logical.AND:必须存在多个权限表达式 Logical.OR:只拥有一个权限表达式即可 value属: 同时设置权限表达式和权限的名称 1@RequiresPermissions(value = &#123;"部门列表","department:list"&#125;, logical = Logical.OR) 在shiro.xml配置权限注解扫描器 1234&lt;!--权限注解扫描器--&gt;&lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt;&lt;/bean&gt; 当扫描到Controller中有使用@RequiresPermissions注解时,会使用动态代理为当前Controller生成代理对象,增强对应方法的权限校验功能. 生成权限信息到数据库 在PermissionServiceImpl实现类中 扫描Controller类中的方法 生成权限信息到数据库中 12345678910111213141516171819202122232425262728293031323334public void reload() &#123; List&lt;String&gt; expressions = permissionMapper.listAllExpressions(); //2.从容器中获取所有贴注解的控制器对象 Map&lt;String, Object&gt; beansWithAnnotation = ctx.getBeansWithAnnotation(Controller.class); Collection&lt;Object&gt; collections = beansWithAnnotation.values(); //3.从每个控制器获取方法 for (Object ele : collections) &#123; //获取controller对象的父类方法 Method[] methods = ele.getClass().getSuperclass().getDeclaredMethods(); //4.获取方法上的注解 for (Method method : methods) &#123; if (method.isAnnotationPresent(RequiresPermissions.class)) &#123; RequiresPermissions annotation = method.getAnnotation(RequiresPermissions.class); String[] values = annotation.value(); //5.获取注解中传递的参数 String name = values[0]; String expression = values[1]; if (!expressions.contains(expression)) &#123; //6.将参数保存到数据库中 Permission permission = new Permission(); permission.setName(name); permission.setExpression(expression); permissionMapper.insert(permission); &#125; &#125; &#125; &#125;&#125; 权限异常处理访问了没有权限的页面会抛出UnauthorizedException异常 使用Spring MVC的统一异常处理,在mvc.xml中配置异常页面 1234567891011121314&lt;!--配置异常页面--&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;!-- 定义默认的异常处理页面，当该异常类型的注册时使用 --&gt; &lt;property name="defaultErrorView" value="common/error"/&gt; &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt; &lt;property name="exceptionAttribute" value="ex"/&gt; &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt; &lt;property name="exceptionMappings"&gt; &lt;!-- 这里还可以继续扩展不同异常类型的异常处理 --&gt; &lt;value&gt; org.apache.shiro.authz.UnauthorizedException=common/nopermission &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 异步请求没有权限异常处理123456789101112131415@ControllerAdvicepublic class UnauthorizedExceptionUtil &#123; @ExceptionHandler(UnauthorizedException.class) public void handler(HttpServletResponse response, HandlerMethodmethod,UnauthorizedException e) throws IOException &#123; if(method.getMethod().isAnnotationPresent(ResponseBody.class))&#123; response.setContentType("text/json;charset=UTF-8"); JSONResult result = new JSONResult(); result.mark("对不起，您没有权限执行该操作"); response.getWriter().print(JSON.toJSONString(result)); &#125;else&#123; throw e; &#125; &#125;&#125; Shiro标签在前端页面使用shiro标签,从而更加细致的显示用户对应的权限,没有权限的相关操作隐藏. 引入jar包 12345&lt;dependency&gt; &lt;groupId&gt;net.mingsoft&lt;/groupId&gt; &lt;artifactId&gt;shiro-freemarker-tags&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 新建CRMFreeMarkerConfigurer类,在FreeMark中注册shiro标签 重写afterPropertiesSet()方法 12345678@Overridepublic void afterPropertiesSet() throws IOException, TemplateException &#123; super.afterPropertiesSet(); Configuration cfg = this.getConfiguration(); //创建标签头为shiro的shiro标签 cfg.setSharedVariable("shiro",new ShiroTags());&#125; 在mvc.xml中将MyFreeMarkerCong设置成当前环境中使用的配置对象 1234567&lt;!--配置freeMarker的模板路径 --&gt;&lt;bean class="me.cscar.rbac.shiro.CRMFreeMarkerConfigurer"&gt; &lt;!-- 配置freemarker的文件编码 --&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt; &lt;!-- 配置freemarker寻找模板的路径 --&gt; &lt;property name="templateLoaderPath" value="/WEB-INF/views/"/&gt;&lt;/bean&gt; shiro的freemarker常用标签 标签 作用 &lt;@shiro.authenticated&gt;… 已认证通过的用户 &lt;@shiro.notAuthenticated&gt;… 未认证通过的用户 &lt;@shiro.principal property=”name” /&gt; 输出当前用户信息,通常为登录帐号信息 &lt;@shiro.hasRole name=”admin”&gt;… 验证当前用户是否属于该角色 &lt;@shiro.hasAnyRoles name=”admin,user,operator”&gt;… 验证当前用户是否属于这些角色中的任何一个 &lt;@shiro.hasPermission name=”/order:*”&gt;… 当前用户是否拥有该权限 MD5加密在添加用户的时候，需要对添加的用户密码进行加密 在EmployeeServiceImpl中 1234567891011121314151617@Overridepublic void insertOrUpdate(Employee record, Long[] roleIds) &#123; //使用当前用户名为密码加盐 record.setPassword(new Md5Hash(record.getPassword(), record.getName()).toString()); if (record.getId() == null) &#123; employeeMapper.insert(record); &#125; else &#123; employeeMapper.updateByPrimaryKey(record); employeeMapper.deleteEmpAndRoleRelation(record.getId()); &#125; if (roleIds != null) &#123; for (Long roleId : roleIds) &#123; employeeMapper.insertEmpAndRoleRelation(record.getId(), roleId); &#125; &#125;&#125; 在CRMRealm中,认证的时候,密码匹配需要用到的密码应该和添加用户时的加密规则一致 123456789if (currentEmp != null) &#123; //currentEmp:作为身份对象使用,因为在后面需要使用到当前登录用户的信息 return new SimpleAuthenticationInfo( currentEmp,//身份信息 currentEmp.getPassword(),//凭证 ByteSource.Util.bytes(currentEmp.getName()),//盐 this.getName()//Realm名称 );&#125; 在shiro.xml配置需要的加密算法 1234567&lt;!--指定当前需要使用的凭证适配器--&gt;&lt;bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;!--指定加密算法--&gt; &lt;property name="hashAlgorithmName" value="MD5"/&gt; &lt;!--指定加密次数--&gt; &lt;!--&lt;property name="hashIterations" value="3"/&gt;--&gt;&lt;/bean&gt; 在Realm中,将容器中的配置的凭证匹配器注入给当前的Realm对象在该Realm中使用指定的凭证匹配器来完成密码匹配的操作 123456//注入给当前的Realm对象(@Autowired还可以注入set方法)@Autowired@Overridepublic void setCredentialsMatcher(CredentialsMatcher credentialsMatcher) &#123; super.setCredentialsMatcher(credentialsMatcher);&#125; EhCache缓存用户登陆后,授权信息一般很少变动,所有我们可以在第一次授权后就把这些授权信息存到缓存中,下一次就直接从缓存中获取,避免频繁访问数据库. 使用EhCache实现缓存 添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.6.8&lt;/version&gt;&lt;/dependency&gt; 在shiro.xml中 1234&lt;!--配置缓存管理器并引用缓存管理器--&gt;&lt;bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt; &lt;property name="cacheManagerConfigFile" value="classpath:shiro-ehcache.xml"/&gt;&lt;/bean&gt; 在上面的安全管理器中注入 123456&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="CrmRealm"/&gt; &lt;!--将缓存管理器注入到安全管理器--&gt; &lt;property name="cacheManager" ref="cacheManager"/&gt;&lt;/bean&gt; 添加ehcache配置文件:shiro-ehcache.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd" updateCheck="false"&gt; &lt;defaultCache maxElementsInMemory="1000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 属性 作用 maxElementsInMemory 缓存最大个数 eternal 对象是否永久有效 timeToIdleSeconds 设置对象在失效前的允许闲置时间(单位:秒) timeToLiveSeconds 设置对象在失效前允许存活时间(单位:秒) overowToDisk 当内存中对象数量达到maxElementsInMemory时,Ehcache将会对象写到磁盘中.LRU(最近最少使用) 清空缓存 如果用户正常退出,缓存自动清空. 如果用户非正常退出,缓存自动清空. 如果修改了用户的权限,而用户不退出系统,修改的权限无法立即生效. 当用户权限修改后,用户再次登陆shiro会自动调用realm从数据库获取权限数据,如果在修改权限后想立即清除缓存则可以调用realm的clearCache方法清除缓存 在realm中定义该方法 1234public void clearCached() &#123; PrincipalCollection principals = SecurityUtils.getSubject().getPrincipals(); super.clearCache(principals);&#125; 最后在角色或权限service中,delete或者update方法去调用realm的清除缓存方法.]]></content>
      <categories>
        <category>Spring</category>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Shiro</tag>
        <tag>认证</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的ajax]]></title>
    <url>%2F2019%2F05%2F26%2FjQuery%E7%9A%84ajax%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2019%2F05%2F25%2FJSON%2F</url>
    <content type="text"><![CDATA[JSON是一种轻量级的数据交换格式语法格式:1234[ &#123;“名称1” : 值, “名称2” : 值2&#125;, &#123;“名称1” : 值, ”名称2“ : 值2&#125;] JSON字符串和JS对象之间转换1JSON.parse(jsonStr)//json字符串转JS对象 1JSON.stringify(obj)//js对象转JSON字符串 JSON库Jackson:在 SpringMVC 中内置的一个转换 JSON 的插件,速度也挺快,稳定性比较好.Fastjson:阿里出品,号称是 Java 领域中转换 JSON 最快的一个插件,中文文档比较齐全.用起来比较友好的 Java 对象 JSON 字符串 java对象转json字符串1new ObjectMapper().writeValueAsString(java对象) json字符串转java对象12objectMapper.readValue(objectMapper.writeValueAsString(emps), objectMapper.getTypeFactory().constructParametricType(ArrayList.class, Employee.class)) java对象转json字符串1JSON.toJSON(java对象); json字符串转java对象12JSON.parseObject();JSON.parseArray(); jackson标签手动处理:把对象封装成map(键值对)再调用封装的方法.标签:@JsonIgnore : 忽略该字段.@JsonProperty(“xxx”) : 对象转换json时换一个名字@JsonFormat(pattern = “yyyy-MM-dd”,timezone=”GMT+8”)]]></content>
      <categories>
        <category>JSON</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>JS</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX和jQuery]]></title>
    <url>%2F2019%2F05%2F23%2FAJAX%E5%92%8CjQuery%2F</url>
    <content type="text"><![CDATA[AJAX:AJAX是Javascript,XHTML,CSS 和 DOM,XML,XMLHttpRequest的综合应用.AJAX核心是在JavaScript中调用 XMLHttpRequest 类,用这个特殊的JavaScript对象发送请求和接收响应.XMLHttpRequest也被称为AJAX对象. AJAX作用: 客户端于服务器进行异步交互. 网页内容的局部更新.缺陷: 浏览器的兼容性; 网页后退功能失效; 对流媒体支持不好; AJAX不支持跨域访问,不做特殊处理只能请求同源的资源; jQuery:jQuery是一个JavaScript框架.JS库,兼容CSS3作用: 操作文档对象,选择DOM元素,制作动画效果,事件处理,使用AJAX以及其他功能. jQuery引入1&lt;script type="text/javascript" src="../static/jquery-2.1.4.js"&gt;&lt;/script&gt; 验证引入123&lt;script type="text/javascript"&gt; alert($);&lt;/script&gt; jQuery体验12345678910111213141516171819window.onload = function () &#123; var btn = document.getElementById("btn"); btn.onclick = function () &#123; var div = document.getElementById("div"); if (div.style.display) &#123; div.style.display = ""; &#125; else &#123; div.style.display = "none"; &#125; &#125;&#125;;$(function () &#123; $("#btn_jq").click(function () &#123; $("#div_jq").toggle(1000); &#125;)&#125;); jQuery对象通过 document.getElementById() 找到的元素和通过 $() 找不到元素不一样.通过jQuery方法获取的页面元素,都是jQuery对象.jQuery对象其实就是对DOM对象进行了包装,增强了相关的方法.虽然jQuery对象包装了DOM对象,但是两种不能混用. $ 表示 jQuery对象. $===jQuery. DOM对象—&gt;jQuery对象1$(DOM对象) jQuery对象—&gt;DOM对象1$btn.get(o) jQuery常用方法.size() / .length: 获取jQuery中包含DOM个数.val : 获取元素的value属性值..val(‘xxx’) : 设置value属性值..html() : 获取所有标签中的内容..text : 获取所有标签中的文本内容..css : 设置样式. 基本选择器id : 返回值单个元素的组成的集合.1$("mydiv") element : 返回值元素集合1$("div") class : 返回值元素集合1$(".myClass") : 返回值元素集合1$("*") selector1, selector2, selectorN : 返回值元素集合1$("div,span,p,myClass") 层次选择器ancestor descendan 祖先 后代1$("form input"); //返回值元素集合 parent &gt; child 父亲 &gt; 儿子1$("form &gt; input"); // 返回值元素集合 prev + next 兄 + 二弟1$("label + input"); //返回值元素集合 prev ~ siblings 兄 + 所有弟弟1$("form ~ input"); 过滤选择器1$("初步过滤:准确过滤"); jQuery事件绑定mouseover + mouseout = hover DOM操作-内部插入1234567父.append(子);子.appendTO(父)父.prepend(子-&gt;带哥)(子-&gt;带哥).prependTO(父); DOM操作-外部插入1234567891011//在div后面插入span$('#div').after($('#span'));//在div前面插入span$('#div').before($('#span'));//将span插入到div后面$('#span').insertAfter($('#div'))//将span插入到div前面$('#span').insertBefore($('#div')) DOM操作-删除12345678//删除id为ul的所有子元素$('#ul').empty();//detach删除之后元素绑定事件跟数据不会被删除$('#btn').detach();//remove删除之后元素绑定事件跟数据会删除$('#btn').remove(); DOM操作-复制和替换123456//克隆id为btn的元素$('#btn').clone(true);//替换 $(源).replaceWith(目标)$('input').replaceWith('&lt;p&gt;123&lt;p&gt;')//(目标).replaceAll$(源)$('&lt;p&gt;123&lt;p&gt;').replaceAll($('input')) 获取和设置属性获取:1$('#li').attr('value') 设置:123$('li').attr('value',function(index,item)&#123; return item + '_' + index;&#125;) 样式操作为元素添加样式1$(':button').addClass('Mybtn') 删除元素样式1removeClass 判断某个样式1toggleClass 判断是否有某个样式1hasClass]]></content>
      <categories>
        <category>AJAX</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合总结]]></title>
    <url>%2F2019%2F05%2F21%2FSSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Spring作用:通过使用Spring提供的IoC容器,可以将对象之间的依赖关系交给Spring进行控制.方便解耦,简化开发. IoCIoC容器:BeanFactory 是 Spring 最底层的接口.只提供了的 IoC 功能,负责创建、组装、管理 bean.在应用中,一般不使用 BeanFactory,而推荐使用 ApplicationContextBeanFactory:需要等到获取某一个bean的时候才会创建该beanApplicationContext:在启动Spring容器的时候就会创建所有的bean,ApplicationContext接口继承了 BeanFactory.除此之外还提供 AOP 集成、国际化处理、事件传播、统 一资源价值等功能. IoC:控制反转.把创建对象的控制权交给Spring来管理,只需要描述对象如何被创建(在配置文件描述),之后一个容器(IoC容器)负责把他们组装起来 Bean的作用域指其创建的 Bean 对象相对于其他 Bean 对象的请求可见范围.Singleton - 单例,缺省值.在 Spring IoC 容器中仅存在一个 Bean 实例,在开发中主要使用scope=”singleton”.Prototype - 多例,每次从容器中调用 Bean 时,都返回一个新的实例. Request - 每一次 HTTP 请求都会产生一个新的实例,并且该 bean 仅在当前 HTTP 请求内有效.Session - 每一次 HTTP 请求都会产生一个新的 bean,同时该 bean 仅在当前 HTTP session 内有效.Global-session - 类似于标准的 HTTP Session 作用域,不过它仅仅在基于 portlet 的 web 应用中才有意义.Portlet 规范定义了全局 Session 的概念,它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享.在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内.如果你在 web 中使用 global session 作用域来标识 bean,那么 web 会自动当成 session 类型来使用. Bean的初始化和销毁init-method和destroy-method,一般用于连接池的初始化和销毁(关闭资源). DIDI注入:为IoC容器创建对象的时候,设置相关的属性值.IoC是开发目的,DI是实现的手段.注入方式有两种:setter方法注入构造器注入注入值的类型:常量值(简单类型) : value元素对象(复合类型) : ref 元素集合 : 对应集合类型元素 AOP代理模式的定义:为其他对象提供一种代理以控制对这个对象的访问.代理模式的特点:代理对象完全包含真实对象,客户端使用的都是代理对象的方法,和真实对象没有关系.代理模式的职责:把不是真实对象该做的事情从真实对象上撇开,职责清晰. 实现动态代理:针对有接口:使用JDK动态代理.针对无接口:使用CGLIB或Javassist组件 动态代理原理:调用代理对象方法,在代理对象中插入增强代码.通过invoke方法,去调用真实对象中的真实方法,实现业务功能. AOP思想:AOP 把多个业务方法需要调用的代码封装到不同的模块中去(责任分离思想),使用动态代理机制来动态的增强业务功能,从而达到了代码的复用,也提高了维护性. Joinpoint:通过在连接点插入代码,从而增强功能.Pointcut(切点) : 指定哪些类的哪些方法上织入横切逻辑Advice(增强) : 描述横切逻辑和方法的具体织入点Advisor(切面) : 将Pointcut和Advice两者组装起来,有了Advisor信息,Spring就可以利用JDK/CGLIB动态代理技术采用统一的方式为目标Bean创建织入切面的代理对象. 增强时机:aop:before(前置增强): 在方法执行之前增强aop:after-returning(后置增强): 在方法正常执行完成之后执行增强aop:throwing(异常增强): 在方法抛出异常退出时执行增强aop:after(最终增强): 在方法执行之后执行,相当于在finally里执行aop:around(环绕增强): 可以在方法调用前/后完成自定义增强 事务管理并发会导致以下问题:第一类丢失更新:两个事务更新相同的数据,如果一个事务提交,另一个事务回滚,第一个事务也会回滚脏读:第二个事务查询到第一个事务未提交的数据,第一个事务根据该数据进行操作,但是第一个事务却回滚了…虚读:一个事务查询到另一个事务已经提交的数据,导致多次查询数据不一致.不可重复读:一个事务查询到另一个事务已经修改的数据,导致多次查询不一致第二类丢失更新:多个事务同时读取相同的数据,并且完成各种对该数据的操作提交,会导致最后一次的提交覆盖前面所有对数据的修改. READ UNCOMMITED &lt; READ COMMITED &lt; REPEATABLE READ &lt; SERIALIZABLEOracle 支持 READ COMMITED(缺省)和 SERIALIZABLEMySQL 支持 四种隔离级别,缺省为 REPEATABLE READ(可重复读) 事务类型:本地事务,分布式事务,JDBC 事务,JTA 事务编程式事务:通过编写代码来管理事务声明式事务:通过 注解 或 XML 配置来管理事务 Spring MVC]]></content>
      <categories>
        <category>Spring MVC</category>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript语法]]></title>
    <url>%2F2019%2F05%2F20%2FJavaScript%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScriptjs是一种直译式脚本语言,动态类型,弱类型,基于原型的语言.解释器被称为JavaScript引擎,为浏览器的一部分. 组成ECMAScript(核心):JavaScript 语言基础DOM(文档对象模型):规定了访问 HTML 和 XML 的接口BOM:(浏览器对象模型) 变量声明变量:使用关键字 var.如果变量没有初始化,默认是 undefined不事先声明变量而直接使用会报错 打印变量:方式一:alert(变量名);方式二:console.log(变量名): (info,log,debug,warm,error) 基本类型和常量1.整数常量(10进制8进制16进制)十六进制以 0x 或 0X 开头，例:0x8a八进制必须以 0 开头 例如:0123十进制的第一位不能是 0 (数字0除外) 2.实数常量12.32、193.98、 5E7、4e5等.特殊数值:NaN、Infinity (除数为零),所对应的判断函数 isNaN()、isFinite() 3.typeof 运算符 typeof 判断变量的数据类型var msg=’hello’;console.log(typeof msg );msg=18;console.log(typeof msg ); 运算符比较运算符:= 和 == 以及 === 之间的区别：= 赋值运算符：用于把一个常量/变量的值赋值给另外一个变量== 比较运算符：用于比较两个数据的值是否相等，不会去判断类型 console.log(“18” == 18 );=== 比较运算符：先判断数据类型是否相等，然后在去判断值是否相等 console.log(“18” === 18); 逻辑运算符在逻辑运算中 0、””、false、NaN、undefined、null 表示为 false,其他类型数据都表示 trueNaN:not a number a &amp;&amp; b 将 a, b 先转换为 Boolean 类型,在执行逻辑与,若 a 为 false,则返回 a,否则就返回 b; a || b 将 a, b 先转换为 Boolean 类型,再执行逻辑或,若 a 为 true,则返回 a,否则就返回 b; 函数作用:写在函数里面的js代码,只需要定义一次,就可以多次调用定义普通函数:1234function 函数名([参数名称1, 参数名称2, ..., 参数名称N]) &#123; //程序代码 [return 值;]&#125; 无参数无返回,有参数无返回,有参数有返回.如果函数没有返回值,就默认返回 undefined 定义匿名函数:123var add = function(x, y)&#123; return x+y;&#125; 给函数一个固定的名称,我们称之为函数名,把匿名函数当成一个普通的值来理解 全局变量和局部变量全局变量:function外部定义的变量就是全局变量.局部变量:function内部定义使用var声明的变量就是局部变量.访问变量的原则:就近原则.变量声明会提前 全局函数encodeURI 及 encodeURIComponent 方法:返回对一个 URI 字符串编码后的结果.decodeURI 及 decodeURIComponent() 方法:将一个已编码的 URI 字符串解码成最初始的字符串并返回。. parseInt 方法 : 将一个字符串转换成对应的整数(尽可能多地转换) parseFloat 方法 : 将一个字符串转换成对应的小数(尽可能多地转换) eval 方法 : 将参数字符串作为一个 JavaScript 表达式执行. 面向对象对象的属性和方法统一的被称为成员对象的构造函数(函数首字母大写,以区分普通函数)语法格式:1var objInstance=new ObjName([实际参数列表]); 可以动态给对象添加属性 this关键字:在构造函数中,this指新创建的对象:在普通的函数/方法中,谁调用this所在的函数/方法,this就指向谁. 参数传值基本类型:传递的是值的拷贝引用类型:传递的是内存地址的拷贝. 内置对象1.Object创建对象,并设置属性和方法12345678910var obj = new Object();obj.name = "xxx";obj.age = 18;obj.sayHello = function()&#123;&#125;;//对象的构造函数alert(obj.constructor);//是否有指定的属性```jsconsole.log(obj.hasOwnProperty("name1")); 2.Date打印当前系统时间12var d = new Date();var time = d.getFullYear() + "-" + (d.getMonth()+1) + "-" + d.getDate() + " " + d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds(); 3.Math123var num = Math.random();//随机[0.0,1.0)//随机生成[0,25)//随机生成[65,91] 数组定义方式一:创建数组对象1var arr = new Array(); 方式二:类似数组中的静态初始化12var arr2 = new Array("西施","王昭君","貂蝉","杨贵妃");var arr2 = new Array(1, 2, 3, 4) --&gt; arr2=new Array(2); 方式三:类似数组的动态初始化1var arr3 = new Array(4); 方式四:1var arr4 = ["西施","王昭君","貂蝉","杨贵妃"]; 注意:对于js中的数组不会出现数组越界的异常,也不是定长的. 数组的属性和方法1.属性length属性,获取数组长度 2.方法连接两个或更多的数组,并返回结果1concat(array1, array2, ......, arrayX); 把数组的所有元素放入一个字符串.元素通过指定的分隔符进行分隔1join(separator); 颠倒数组中元素的顺序（该方法会改变原来的数组,而不会创建新的数组)1reverse(); 从某个已有的数组返回选定的元素(返回的是一个新数组)1slice(start[, end]); 删除并返回数组的最后一个元素1pop(); 删除并返回数组的第一个元素1shift(); 向数组的末尾添加一个或更多元素，并返回新的长度1push(newelement1, newelement2, ...., newelementX); 向数组的开头添加一个或更多元素,并返回新的长度1unshift(newelement1, newelement2, ...., newelementX); 用于插入、删除或替换数组的元素1splice(index, howmany, element1, ....., elementX); 数组遍历1.普通遍历123for (var i = 0; i &lt; arr.length; i++)&#123; console.log(arr[i]);&#125; 2.forEach123arr.forEach(function (value) &#123; console.log(value);&#125;) 3.for-in123456789for(var i in arr) &#123; console.log(arr[i]);&#125;var obj = &#123;name:"小强",age:'18'&#125;;for(var p in obj)&#123; console.log(obj.p); console.log(obj[p]);&#125; 4.map123arr.map(function(ele,index,arr)&#123; return ele+10;&#125;) BOMBOM:浏览器对象模型 消息框,输入框,对话框123456789101112console.log(window.location);console.log(location);window.alert(1);var v = window.prompt('蛤蛤','嘟嘟');var v2 = prompt('你是','蛤蛤');console.log(v);//嘟嘟console.log(v2);//蛤蛤var v3 = confirm("傻逼?");console.log(v3)//true 定时器第一种:只会执行一次,指定时间后,执行某一个操作.第二种:周期性执行,间隔多少时间后,周期性执行某一个操作.setTimeout(fn, time)函数,返回 timer,用于指定一段时间后执行某函数setInterval(fn, time)函数,返回 timer,用于周期性执行某函数. 参数 fn可以是字符串组成的 Javascript 代码,也可以是一个函数名称. 参数 time 表示时间,毫秒为单位. clearTimeout(timer) 函数清,除由 setTimeout 创建的定时器.clearInterval(timer) 函数,清除由 setInterval 指定的定时器. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript"&gt; var timer = setInterval(function () &#123; var spanEle = document.getElementById('time'); var time = spanEle.innerHTML; if (time &gt; 0) &#123; spanEle.innerHTML = time - 1; &#125; if (time == 0) &#123; location.href = 'http://cscar.me'; clearInterval(timer) &#125; &#125;,1000);&lt;/script&gt;&lt;body&gt;&lt;span id="time"&gt;5&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; DOM定义DOM是文档对象模型的缩写.DOM是一种于浏览器,平台,语言无关的接口,可动态的修改XML和HTML. HTML DOMDOM是将HTML文档表达为树结构,定义了访问和操作HTML文档的标准方法.DOM树:节点(node)的层次,文档节点(document),元素节点,属性节点,文本节点.DOM把一个文档表示为一颗家谱树. 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt; &lt;script type="text/javascript"&gt; console.log(window.navigator); console.log(window.document.images); console.log(window.document.links); console.log(window.document.forms); &lt;/script&gt;&lt;body&gt; &lt;a href=""&gt;a1&lt;/a&gt; &lt;a href=""&gt;a2&lt;/a&gt; &lt;form id="form1"&gt;&lt;/form&gt; &lt;form id="form2"&gt;&lt;/form&gt; &lt;img src=""/&gt; &lt;img src=""/&gt;&lt;/body&gt;&lt;/html&gt; DOM获取元素的三种方式1.通过元素id:1getElementById 返回拥有指定id的第一个元素,如果不存在则返回null.2.通过标签名字1getElementsByTagName 返回一个包含所有给定标签名称的元素,如果没有匹配的元素,返回一个空集.3.通过class名字1getElementsByClassName 返回一个包含所有指定class名称的元素集合,可以在任意元素上调用该方法. 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .b &#123; color: pink; &#125;&lt;/style&gt;&lt;script&gt; window.onload = function () &#123; var spanEle = document.getElementById("span1"); console.log(spanEle); var span = document.getElementsByTagName("span"); console.log(span[1]); var classEle = document.getElementsByClassName("b"); console.log(classEle[2]) &#125;&lt;/script&gt;&lt;body&gt;&lt;span id="span1" class="b"&gt;你好&lt;/span&gt;&lt;span id="span2" class="b"&gt;你好&lt;/span&gt;&lt;div id="div1" class="b"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Node对象的属性和方法1234567891011window.onload = function () &#123; var divEle = document.getElementById("div1"); console.log(divEle.firstChild); console.log(divEle.lastChild); console.log(divEle.childNodes); var span2Ele = document.getElementById("span2"); console.log(span2Ele.parentNode); console.log(span2Ele.previousSibling); console.log(span2Ele.nextSibling); &#125; 元素节点的属性操作元素上的标准属性和自定义属性操作1.操作标准属性获取属性值元素对象[“属性名”]元素对象.属性名元素对象.setAttribute(“属性名”, 值) 2.操作自定义属性获取属性值:元素对象.getAttribute(“属性名”) 设置属性值:元素对象.setAttribute(“属性”,值) 其他特殊属性操作1.操作属性名和默认属性值相同的属性,如: checked, selected元素对象.checked = true | false2.操作 class 属性元素对象.className = xxx,原因:class是js中的关键字3.操作style的属性,如:background-color4.操作readonly属性元素对象.readOnly=true | false1234567891011121314151617181920212223242526window.onload = function () &#123; var inputEle = document.getElementById("username"); console.log(inputEle.type); console.log(inputEle['type']); console.log(inputEle.getAttribute('type')); //inputEle['value'] = "中米"; //inputEle.value="大米"; inputEle.setAttribute('value', '黑米'); inputEle.setAttribute('xx', '嘟嘟'); console.log(inputEle.getAttribute('xx')); console.log(inputEle.className); inputEle.className = 'a'; console.log(inputEle.className); var inputEle2 = document.getElementById("admin"); console.log(inputEle2.checked); console.log(inputEle2.readOnly); console.log(inputEle2.style.backgroundColor); inputEle2.style.backgroundColor = "green"; console.log(inputEle2.style.backgroundColor); &#125; 元素节点的常用方法 事件处理事件驱动编程事件源:发出事件通知,发出消息,也是事件主体事件名称:发出什么样的通知的名称.事件响应函数,当这个事件发生时,执行操作.事件对象:一般来说,当事件发生时,会产生一个描述该事件的具体对象. 123456789101112131415161718192021222324//方式1function func(srcEle, event) &#123; console.log(srcEle); console.log(event);&#125;window.onload = function () &#123; //方式2 var btn2 = document.getElementById("btn2"); btn2.onclick = function (ev) &#123; console.log(ev); alert(111); &#125;; //方式3 var btn3 = document.getElementById("btn3"); btn3.addEventListener('click',function (ev) &#123; console.log(ev); alert(222); &#125;); btn3.addEventListener('click',function (ev) &#123; alert(333); &#125;)&#125; 事件相关鼠标事件123456789window.onload = function () &#123; var imgEle = document.getElementById("man"); imgEle.onmouseover = function () &#123; imgEle.src = "../image/man2.png"; &#125;; imgEle.onmouseout = function () &#123; imgEle.src = "../image/man.png"; &#125;; &#125; 原生JS事件绑定使用原生的加载事件,后面的会覆盖前面的.使用jQuery则不会.12345678910111213window.onload=function () &#123; alert(111);&#125;;window.onload=function () &#123; alert(222);&#125;;$(function () &#123; alert(111);&#125;);$(function () &#123; alert(222);&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM综合]]></title>
    <url>%2F2019%2F05%2F17%2FSSM%E7%BB%BC%E5%90%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[spring请求和响应]]></title>
    <url>%2F2019%2F05%2F16%2Fspring%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[spring注解归类]]></title>
    <url>%2F2019%2F05%2F15%2Fspring%E6%B3%A8%E8%A7%A3%E5%BD%92%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[IoC注解:XML:1&lt;ben id="" class=""/&gt; 作用:被贴的类,交给spring管理(会被创建对象,存储在spring容器中) 注解:(四个作用一样)Repository : 一般贴DAO类Service : 一般贴Service类Controller : 一般贴Controller类Component : 非上述三种类型的类 解析器:1&lt;context:component-scan basePackage="me.cscar.ssm"&gt; xml:1&lt;bean id="someBean" class="...SomeBean" scope="singleton" init-method="open" destory-method="close"/&gt; 1234567891011@Component("someBean")@Scope("singleton")class SomeBean&#123; @PostConstruct public void open()&#123;&#125; @PreDestory public void close()&#123;&#125; &#125; DI注解:作用:从容器中找到指定的bean对象,并设置给该字段. 注解:AutowiredResource二者功能一样 解析器:1&lt;context:annotation-config/&gt; xml:12345&lt;bean id="otherBean" class="..OtherBean"&gt;&lt;bean id="someBean" class="..SomeBean"&gt; &lt;property name="other" ref="otherBean"/&gt;&lt;/bean&gt; 12345678@Componentclass OtherBean&#123;&#125; @Component class SomeBean&#123; @Autowired private OtherBean other; &#125; Tx注解:作用:增加Service组件支持事务管理 注解:Transactional 解析器:1&lt;tx:annotation-driven transaction-manager="txManager"/&gt; xml配置配置事务管理器(what)123&lt;bean id="txManager" class="...DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt; 配置事务增强(配置事务方法的属性 when)12345678&lt;tx:advice id="txAdvice" tansaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;tx:method name="list*" read-only="true"/&gt; &lt;tx:method name="query*" read-only="true"/&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 配置切入点(where)1234&lt;aop:config&gt; &lt;aop:pointcut expression="execution(* com.huawei.xx.service.*Service.*(..))" id="txPointcut"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/&gt;&lt;/aop:config&gt; 注解操作:1:what:配置事务管理器123&lt;bean id="txManager" class"...DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt; 2:增加解析器1&lt;tx:annotation-driven transaction-manager="txManager"/&gt; 3:到service实现类上,使用Transactional注解 MVC注解:注解:Controller : 声明当前类为控制器,spring容器创建对象RequestMapping : 贴在方法上,表示访问当前方法的URL. 使用:12345678@Controller@RequestMapping("/hello")public class HelloController&#123; @RequestMapping("/say") public ModelAndView sayHello()&#123; return null; &#125;&#125; 此时的访问规则: http://localhost:8080/hello/say AOP注解:12345class LogAdvice&#123; public void writeLog()&#123; sout("记录日志...") &#125;&#125; XML:1234567891011&lt;!--what:--&gt;&lt;bean id="logAdvice" class="..LogAdvice"&gt;&lt;aop:config&gt; &lt;aop:aspect ref="logAdvice"&gt; &lt;!--where:--&gt; &lt;aop:pointcut expression="execution(* cn.wolfcode.ssm.*Service.*(..))" id="logPointcut"/&gt; &lt;!--when:--&gt; &lt;aop:before method="writeLog" pointcut-ref="logPointcut"/&gt; &lt;/aop:aspect&gt;&lt;aop:config&gt; 使用注解:注解: Aspect 贴在增强类之上,表示一个切面 Pointcut 编写切入点表达式 Before 前置增强 AfterReturning AfterThrowing After Around 解析器1234&lt;!-- 解析Component --&gt;&lt;context:component-scan basePackage="cn.wolfcde.ssm"/&gt;&lt;!--AOP注解解析器--&gt;&lt;aop:aspectj-autoproxy/&gt; 使用123456789101112@Component@Aspectclass LogAdvice&#123; @Pointcut("execution(* cn.wolfcode.ssm.*Service.*(..))") public void logPointcut()&#123;&#125; @Before("logPointcut()") public void writeLog()&#123; sysou("记录日志...") &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC]]></title>
    <url>%2F2019%2F05%2F14%2FspringMVC%2F</url>
    <content type="text"><![CDATA[MVC原理model(模型) : 数据模型,包含要展示的数据和业务功能.view(视图) : 用户界面,在界面上显示模型数据controller(控制器) : 起调度作用,接收用户请求,调用业务处理请求,共享数据模型并跳转界面. 在web开发中的模型是无法主动推给视图(无法主动更新用户界面),因为在web开发是请求-响应模型 前端控制器(controller)所有的请求都被发往该控制器统一处理,然后把请求分发给各自相应的处理程序. MVC框架都有前端控制器,在web开发中必须在web.xml中配置前端控制器,一般的要么是Filter,要么是Servlet.springMVC基于Servlet MVC流程图 涉及组件 springMVCspringMVC和spring WebFluxspring WebFlux是基于异步非阻塞springMVC是同步阻塞的IO模型 使用注解开发控制层(mvc) @Controller业务逻辑层(service) @Service数据持久层(DAO) @Resposotory其他组件使用通用注解 @Component java代码: xml配置: requestMapping注解 静态资源访问]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring注解开发]]></title>
    <url>%2F2019%2F05%2F14%2Fspring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[DI注解Autowired 注解和 Resource 注解:共同点:1.可以自动的把属性需要的对象找出来,并自动注入2.可以贴在字段或者 setter 方法上面,一般贴在字段上(不再需要 setter 方法)3.可以注入一些 Spring 内置的重要对象,甚至是 Servlet 的 API 比如 BeanFactory、 ApplicationContext、ServletContext 等不同点:1.Autowired 和 Resource 注解都必须要能找到对应的对象,否则报错.只是 Autowired 注解可以通过 required=false 来避免这个问题:@Autowired(required=false)2.Autowired:先按照类型找,找不到再按名字去找,可以配合@Qualifier 注解一起使用.Resource:先按照名字找,找不到再按类型找.@Resource(name=””) 开发中建议必须配置1&lt;context:annotation-config /&gt; 使用 Autowired 注解12345public class SomeBean &#123; @Autowired @Qualifier("otherBean") private OtherBean other;&#125; 使用 Resource 注解1234public class SomeBean &#123; @Resource(name=”otherBean”) private OtherBean other;&#125; Value 注解Autowired 和 Resource 注解用于注入对象,Value 注解用于注入常量数据(简单类型数据)server.properties 文件12server.port=8888server.path=/ Java 代码12@Value("$&#123;server.port&#125;")private int port; 引入配置文件1&lt;context:property-placeholder location="classpath:db.properties,classpath:server.properties"/&gt; 或者1234&lt;context:property-placeholder location="classpath:db.properties" ignore-unresolvable="true"/&gt;&lt;context:property-placeholder location="classpath:server.properties" ignore-unresolvable="true"/&gt; IoC 注解不同组件的注解bean 组件版型:组件的功能是相同的,只是用于标注不同类型的组件 @Repository 用于标注数据访问组件,即 DAO 组件.@Service 用于标注业务层组件,即 Service 组件.@Controller 只用于标注控制层组件(SpringMVC 的 Controller).@Component 泛指组件,当组件不好归类的时候,我们可以使用这个注解进行标注 此时需要配置 IoC 注解的解析器1&lt;context:component-scan base-package=""/&gt;表示去哪些包中及其子包中去扫描组件注解 Java 代码(同时实现 IoC 和 DI 配置)123456789@Component("otherBean") public class OtherBean &#123;&#125;@Componentpublic class SomeBean &#123; @Autowired private OtherBean other;&#125; xml配置1234&lt;!-- DI 注解解释器 --&gt;&lt;context:annotation-config/&gt;&lt;!-- IoC 注解解释器 --&gt;&lt;context:component-scan base-package="me.cscar.ssm"/&gt; 作用域注解XML配置1&lt;bean id="otherBean" class="...OtherBean" scope="singleton"/&gt; 使用:使用 Scope 注解，设置 Bean 的作用域12345@Component@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)public class OtherBean &#123;&#125; 初始化和销毁注解使用 XML 方式的配置 bean 的初始化和销毁方法1234&lt;bean id="someBean" class="...SomeBean" init-method="open" destroy-method="close"/&gt; @PostConstruct 用于贴在初始化方法上@PreDestroy 用于贴在销毁方法上12345678@PostConstructpublic void open() &#123; System.out.println("初始化方法"); &#125;@PreDestroypublic void close() &#123; System.out.println("销毁方法"); &#125; AOP 注解使用 XML 方式的配置 AOP(基于 JDK 动态代理)xml配置:一定要先开启 AOP 注解的解释器12345&lt;!-- IoC 注解解释器 --&gt;&lt;context:component-scan base-package="cn.wolfcode.ssm" /&gt; &lt;!-- DI 注解解释器 --&gt;&lt;context:annotation-config /&gt;&lt;!-- AOP 注解解释器 --&gt;&lt;aop:aspectj-autoproxy /&gt; Aspect : 声明一个切面,贴在增强类之上Pointcut : 贴到一个方法上,用于声明 pointcut 语法,被贴方法的名字作为 pointcut 语法 idBefore : 贴到需要做前置增强的方法上After : 贴到需要做后置增强的方法上AfterThroing : 贴到需要做异常增强的方法上AfterReturing : 贴到需要做最终增强的方法上Around : 贴到需要做环绕增强的方法上 Java 代码:123456789101112131415161718192021222324252627282930313233343536373839404142@Component@Aspectpublic class TransctionManager &#123; @Pointcut("execution(* cn.wolfcode.ssm.service.*Service.*(..))") public void txPoint() &#123; &#125; @org.aspectj.lang.annotation.Before("txPoint()") public void begin(JoinPoint jp) &#123; System.out.println("开启事务"); &#125; @org.aspectj.lang.annotation.AfterReturning("txPoint()") public void commit() &#123; System.out.println("提交事务"); &#125; @org.aspectj.lang.annotation.After("txPoint()") public void close() &#123; System.out.println("释放资源"); &#125; @org.aspectj.lang.annotation.AfterThrowing(value = "txPoint()", throwing = "ex") public void rollback(Throwable ex) &#123; System.out.println("回滚事务" + ex); &#125; @org.aspectj.lang.annotation.Around(value = "txPoint()") public Object around(ProceedingJoinPoint pjp) &#123; Object ret = null; System.out.println("开启事务"); try &#123; //执行目标方法 ret = pjp.proceed(); System.out.println("提交事务"); &#125; catch (Throwable ex) &#123; System.out.println("回滚事务"); &#125; finally &#123; System.out.println("释放资源"); &#125; return ret; &#125;&#125; 默认使用的 JDK 动态代理方式,可以设置使用 CGLIB 方式XML 配置:1&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 修改切入点表达式123@Pointcut("execution(* me.cscar.ssm.service..*(..))")public void txPoint() &#123;&#125; Tx注解1234567&lt;tx:advice id="crudAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;!-- service 中查询方法 --&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;tx:method name="list*" read-only="true"/&gt; &lt;tx:method name="query*" read-only="true"/&gt; &lt;!-- service 中其他方法 --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 具体使用贴在类上:该类中所有的方法,都使用 Transactional 注解的属性配置贴在方法上:只针对被贴的这一个方法,一般用于做单独配置.一般的,我们可以在业务类上直接贴该注解,并在查询方法上设置 readOnly 属性为 true.注意:一定要记得开启 Tx 注解的解释器 使用JDK12345678910111213&lt;!-- IoC 注解解析器 --&gt;&lt;context:annotation-config /&gt;&lt;!-- DI 注解解析器 --&gt;&lt;context:component-scan base-package="cn.wolfcode.ssm" /&gt; &lt;!-- TX 注解解析器 --&gt;&lt;tx:annotation-driven transaction-manager="txManager" /&gt;&lt;!-- 配置 JDBC 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;........... 使用 CGLIB1&lt;tx:annotation-driven transaction-manager="txManager" proxy-target-class="true"/&gt; java代码1234567891011@Service@Transactionalpublic class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDAO dao; public void trans(Long outId, Long inId, int money) &#123; dao.transOut(outId, money); int a = 1 / 0; dao.transIn(inId, money); &#125; &#125;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring事务管理]]></title>
    <url>%2F2019%2F05%2F14%2Fspring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Spring 事务管理事务的操作:1.原子性(Atomicity):事务是不可分割的最小工作单元,事务内的操作要么全做,要么全不做. 2.一致性(Consistency):在事务执行前数据库的数据处于正确的状态,而事务执行完成后数据库的数据依然处于正确的状态,即数据完整性约束没有被破坏,如 A 给 B 转账,不论转账成功与否转账之后 的 A 和 B 的账户总额和转账之前是相同的. 3.隔离性(Isolation):当多个事务处于并发访问同一个数据库资源时,事务之间相互影响程度,不同的隔离级别决定了各个事务对数据资源访问的不同行为. 4.持久性(Durability):事务一旦执行成功它,对数据库的数据的改变是不可逆的. Spring 的事务管理主要包括 3 个接口:1.PlatformTransactionManager:根据 TransactionDefinition 提供的事务属性配置信息,创建事务. 2.ransactionDefinition:封装事务的隔离级别和超时时间,是否为只读事务和事务的隔离级别和传播规则等事务属性. 3.TransactionStatus:封装了事务的具体运行状态.如是否是新开启事务,是否已经提交事务,设置当前事务为 rollback-only 等. PlatformTransactionManager:1:TransactionStatus getTransaction(TransactionDefinition definition):根据事务定义信息从事务环境中返回一个已存在的事务,或者创建一个新的事务.2:void commit(TransactionStatus status):根据事务的状态提交事务,如果事务状态已经标识为rollback-only,该方法执行回滚事务的操作.3:void rollback(TransactionStatus status):将事务回滚,当 commit 方法抛出异常时,rollback 会被隐式调用 TransactionDefinition:封装事务的隔离级别和超时时间,是否为只读事务和事务的隔离级别和传播规则等事务属性 TransactionStatus:封装了事务的具体运行状态.如是否是新开启事务,是否已经提交事务,设置当前事务为 rollback-only 等. 事务的传播规则spring支持7种传播行为 情况一:遵从当前事务 REQUIRED: 必须存在事务,如果当前存在一个事务,则加入该事务,如果当前没有事务,将新建一个事务 SUPPORTS: 支持当前事务,指如果当前存在事务,就加入到该事务,如果当前没有事务,就以非事务方式执行 MANDATORY: 使用当前事务执行,如果当前没有事务,则抛出异常IllegalTransactionStateException 情况二:不遵从当前事务 REQUIRES_NEW: 不管当前是否存在事务,每次都创建新的事务 NOT_SUPPORTRD: 以非事务方式执行,如果当前存在事务,就把当前事务暂停,以非事务方式执行 NEVER: 不支持事务,如果当前存在是事务,则抛出异常,IllegalTransactionStateException 情况三:寄生事务(外部事务和寄生事务) NESTED :寄生事务,如果当前存在事务,则在内部事务内执行.如果当前不存在事务,则创建一个新的事务(和 REQUIRED 相同). 嵌套事务使用数据库中的保存点(savepoint)来实现,即嵌套事务回滚不影响外部事务,但外部事务回滚将导致嵌套事务回滚.DataSourceTransactionManager 默认支持,而 HibernateTransactionManager 默认不支持, 需要手动开启. 事务方法属性配置 CRUD 通用事务配置1234567&lt;tx:advice id="crudAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;!-- service 中查询方法 --&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;tx:method name="list*" read-only="true"/&gt; &lt;tx:method name="query*" read-only="true"/&gt; &lt;!-- service 中其他方法 --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP]]></title>
    <url>%2F2019%2F05%2F13%2FAOP%2F</url>
    <content type="text"><![CDATA[增强增强(advice):就是在原方法的基础之上,通过插入一段代码从而来增强原方法的功能在 不同时机 插入一段额外代码环绕增强=前置增强+后置增强+异常增强+最终增强 没有AOP导致的问题1.责任不分离:业务方法只需要关系如何完成该业务功能,不用去关心事务管理/日志管理等2.代码结构重复 静态代理代理模式的定义:为其他对象提供一种代理以控制对这个对象的访问特点:1.代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系2.代理模式的职责:把不是真实对象该做的事情从真实对象上撇开——职责清晰 静态代理:在程序运行前就已经存在代理类的字节码文件,代理对象和真实对象的关系在运行之前就确定了. 缺点:该代理类不够通用 动态代理动态代理类是在程序运行期间由JVM通过反射等机制动态生成的,所以不存在代理类的字节码文件,代理对象和真实对象的关系是在程序运行时期才确定的 实现动态代理类:1.针对有接口:使用JDK动态代理2.针对无接口:使用CGLIB或javassist 字节码动态加载 JVM 通过字节码的二进制信息加载类的,如果我们在运行期系统中,遵循 Java 编译系统组织. class 文件的格式和结构,生成相应的二进制数据,然后再把这个二进制数据加载转换成对应的类. java.lang.reflect.Proxy 类:Java 动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法 来为一组接口动态地创建代理类及其对象 JDK 动态代理 主要方法: 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler hanlder) 原理图 通过 newProxyInstance 创建代理类对象,调用hanlder的invoke()方法,底层调用method.invoke()方法.代理类对象和真实类同时实现了实现类的接口. CGLIB 动态代理使用 JDK 的动态代理,只能针对于目标对象存在接口的情况,如果目标对象没有接口,此时可以考虑使用 CGLIB 的动态代理方式.Spring 已经自带了 cglib 库. CGLIB 是通过生成代理类,然后继承于目标类,再对目标类中可以继承的方法做覆盖,并在该方法中做功能增强的,因为多态的关系,通过代理对象调用方法,实则调用的是代理类中的方法 动态代理总结JDK 代理总结:1.JAVA 动态代理是使用 java.lang.reflect 包中的 Proxy 类与 InvocationHandler 接口这两个来完成的.2.要使用 JDK 动态代理,委托必须要定义接口.3.JDK 动态代理将会拦截所有 pubic 的方法(因为只能调用接口中定义的方法),这样即使在接口中增加 了新的方法,不用修改代码也会被拦截.4.动态代理的最小单位是类(所有类中的方法都会被处理),如果只想拦截一部分方法,可以在 invoke 方法 中对要执行的方法名进行判断. CGLIB 代理总结:1.CGLIB 可以生成委托类的子类,并重写父类非 final 修饰符的方法。2.要求类不能是 final 的,要拦截的方法要是非 final、非 static、非 private 的.3.动态代理的最小单位是类(所有类中的方法都会被处理). AOPAOP(Aspect Oritention Programming):把一个个的横切关注点放到某个模块中去,称之为切面.就是把多个业务方法共同调用的某种功能的代码封装到一个类中.切面的目的就是功能增强AOP 把多个业务方法需要调用的代码封装到不同的模块中去(责任分离思想).使用动态代理 机制来动态的增强业务功能,从而达到了代码的复用.也提高了维护性 AOP核心概念where:哪一些方法:一般使用方法的全限定名称来表示when:在方法体执行的什么时机:之前、之后、异常、最终、环绕what:做什么功能的增强:不同的增强功能使用不同的模块或类来封装 Joinpoint:连接点.程序执行过程中的某个特定位置,如类初始化之前/后,方法调用前/后,方法抛出异常后等.这些特定的位置就称之为连接点,通过在连接点插入代码,从而增强功能.相当于切面的增强时机:when.Spring 仅支持的五种连接点(五种增强时机). Pointcut:切入点.开发中,往往不需要对应用中所有的连接点都做增强,切点的作用就是缩小增强的范围,比如哪些包中的哪些类中的哪些方法.相当于切面的在何处增强:where. Advice:增强.拦截到连接点后具体做什么功能,相当于切面的增强什么:what. Aspect:切面.Pointcut+Advice,去哪些方法中+在方法执行的什么时机+做什么增强 Pointcot语法execution(&lt;修饰符&gt;? &lt;返回类型&gt; &lt;声明类型&gt;? &lt;方法名&gt;(&lt;参数&gt;) &lt;异常&gt;?) 切入点表达式中的通配符:*: 匹配任何部分,在包路径中只能表示一个包,不包括子包...: 可用于全限定名中和方法参数中,分别表示子包和 0 到 N 个参数. 应用场景: 增强方法参数配置1.在增强方法中获取异常信息XML 配置:1&lt;aop:after-throwing method="rollback" pointcut-ref="txPoint" throwing="ex" /&gt; 123public void rollback(Throwable ex) &#123; System.out.println("回滚事务" + ex); &#125; 2.获取被增强方法信息，并传递给增强方法Spring AOP 提供 org.aspectj.lang.JoinPoint 类,作为增强方法的第一个参数.1.JoinPoint:提供访问当前被增强方法的真实对象、代理对象、方法参数等数据.2.ProceedingJoinPoint:JinPoint子类,只用于环绕增强中,可以处理被增强方法. 使用 JoinPoint 类:12345678public void begin(JoinPoint jp) &#123; System.out.println("代理对象:"+jp.getThis().getClass()); System.out.println("目标对象:"+jp.getTarget().getClass()); System.out.println("被增强方法参数:"+Arrays.toString(jp.getArgs())); System.out.println("当前连接点签名:"+jp.getSignature()); System.out.println("当前连接点类型:"+jp.getKind()); System.out.println("开启事务");&#125; 使用 ProceedingJoinPoint 类:12345678910111213141516public Object around(ProceedingJoinPoint pjp) &#123; Object ret = null; System.out.println("开启事务"); try &#123; //执行目标方法 ret = pjp.proceed(); System.out.println("提交事务"); &#125; catch (Throwable ex) &#123; System.out.println("回滚事务"); &#125; finally &#123; System.out.println("释放资源"); &#125; return ret; &#125;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合]]></title>
    <url>%2F2019%2F05%2F11%2FSSM%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[集成思路和步骤0.创建项目,添加依赖和插件1.Spring 集成 MyBatis,通过单元测试,保证 CRUD 测试通过2.加入事务控制,通过单元测试,保证后台事务控制测试通过3.Spring 集成 Spring MVC,通过浏览器测试,保证前台 Web 版 CRUD 测试通过 Spring+MyBatis(Spring 配置)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 加载 db.properties 文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" system-properties-mode="NEVER"/&gt; &lt;!-- 创建 DataSource 对象 --&gt; &lt;bean id="myDataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;!-- 创建 SqlSessionFactory 对象 --&gt; &lt;bean id="mySqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--关联 dataSource 对象 --&gt; &lt;property name="dataSource" ref="myDataSource"/&gt; &lt;!--加载 MyBatis 全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:MyBatis-config.xml"/&gt; &lt;!--为哪些包下的类起别名 --&gt; &lt;property name="typeAliasesPackage" value="cn.wolfcode.ssm.domain"/&gt; &lt;!--加载Mapper映射配置文件 --&gt; &lt;property name="mapperLocations" value="classpath:mappers/*Mapper.xml"/&gt; &lt;/bean&gt; &lt;!-- 创建 Mapper 接口的代理对象 --&gt; &lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;!-- 关联 sqlSessionFactory --&gt; &lt;property name="sqlSessionFactory" ref="mySqlSessionFactory"/&gt; &lt;!-- 根据哪一个接口创建代理对象 --&gt; &lt;property name="mapperInterface" value="cn.wolfcode.ssm.mapper.UserMapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; 设置mybatis的配置信息123456789&lt;!--设置 MyBatis 配置信息 --&gt;&lt;property name="configurationProperties"&gt; &lt;value&gt; lazyLoadingEnabled=true aggressiveLazyLoading=false lazyLoadTriggerMethods=clone &lt;/value&gt;&lt;/property&gt;]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架-IoC-DI]]></title>
    <url>%2F2019%2F05%2F11%2FSpring%E6%A1%86%E6%9E%B6-IoC-DI%2F</url>
    <content type="text"><![CDATA[Spring框架概述Spring 是一个轻量级的 DI/IoC 和 AOP 容器的开源框架,致力于构建轻量级的 JavaEE 应用. 容器容器还要管理对象的生命周期,如 Tomcat 就是 Servlet 和 JSP 的容器 架构 1.Core Container(核心容器)包含有 Beans、Core、Context 和 SpEL 模块。 2.Data Access/Integration 层包含有 JDBC、ORM、OXM、 3.JMS 和 Transactions 模块。 4.Web 层包含了 Web、Servlet、WebSocket、Porlet 模块。 5.AOP 模块提供了遵循 AOP 联盟标准的面向切面编程的实现。 6.Test 模块支持使用 JUnit 和 TestNG 对 Spring 组件进行测试。 IoC和DI思想IoC:Inversion of Control(反转控制)将原本在程序中手动创建对象的控制权,交由 Spring 框架的 IoC 容器来管理.调用者只管负责从 Spring 容器中获取需要使用的对象,不关心对象的创建过程,也不关心该对象依赖对象的创建以及依赖关系的组装,也就是把创建对象的控制权反转给了 Spring 框架. IoC_Demodomain:123456789101112public class HelloWorld &#123; private String name; private int age; public void setName(String name) &#123; this.name = name;&#125; public void setAge(int age) &#123; this.age = age;&#125; public void sayHello() &#123;System.out.println(name + "你好,年龄" + age); &#125;&#125; XML 配置:12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;bean id="helloWorld" class="...HelloWorld"&gt; &lt;property name="name" value="will"/&gt; 对应HelloWorld中的setName方法 &lt;property name="age" value="17" /&gt; 对应 HelloWorld 中的 setAge 方法&lt;/bean&gt;&lt;/beans&gt; 测试类:12345678HelloWorld world = null;//加载 Spring 配置文件 applicationContext.xmlResource resource = new ClassPathResource("applicationContext.xml"); //创建 Spring 容器对象BeanFactory factory = new XmlBeanFactory(resource);//从 Spring 容器中获取制定名为 helloWorld 的 beanworld = (HelloWorld) factory.getBean("helloWorld"); world.sayHello(); BeanFactorySpring IoC 容器——生产 bean 对象的工厂,负责配置,创建和管理 bean.被 Spring IoC 容器管理的对象称之为 bean Spring IoC 管理 bean 的原理: 1.通过 Resource 对象加载配置文件2.解析配置文件,得到指定名称的 bean3.解析 bean 元素,id 作为 bean 的名字,class 用于反射得到 bean 的实例:注意:此时，bean 类必须存在一个无参数构造器(反射创建:和访问权限无关);4.调用 getBean 方法的时候,从容器中返回对象实例; 就是把代码从 JAVA 文件中转移到了 XML 中12345678910111213141516171819HelloWorld wolrd = null;String className="...HelloWorld";//-----------------------------------------------------Class clz = Class.forName(className);Constructor con = clz.getDeclaredConstructor();con.setAccessible(true);wolrd = (HelloWorld)con.newInstance();BeanInfo beanInfo = Introspector.getBeanInfo(wolrd.getClass());PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor pd : pds) &#123; String propertyName = pd.getName(); Method setterMethod =pd.getWriteMethod(); if("name".equals(propertyName))&#123; setterMethod.invoke(wolrd, "Will"); &#125;else if("age".equals(propertyName)) &#123; setterMethod.invoke(wolrd, 17);&#125; &#125;//-----------------------------------------------------wolrd.sayHello(); getBean 方法签名方式一:按照 bean 的名字拿 bean，按照名字拿 bean 不太安全1world = (HelloWorld) factory.getBean("helloWorld"); 方式二:按照类型拿 bean，要求在 Spring 中只配置一个这种类型的实例1world = factory.getBea (HelloWorld.class); 方式三:按照名字+类型(推荐)1world = factory.getBean("helloWorld",HelloWorld.class); bean元素id,name和importid:可以使用字母、数字、连字符、下划线、句话、冒号,不能以“/”开头(spring3.1之前)name:使用 name 属性为 bean 元素起多个别名,多个别名之间使用逗号或空格隔开. import resource:将一个applicationContext.xml 文件分解成多个配置文件,然后在 applicationContext.xml 文件中包含其他配置文件1&lt;import resource="classpath:路径1/路径2/hello.xml"/&gt; Spring 测试框架基于 JUnit4 的测试:12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:springTest.xml") public class SpringTestTest &#123; @Autowired private HelloWorld world; @Test public void test1() throws Exception &#123; world.sayHello(); &#125;&#125; @ContextConfiguration默认去找的当前测试类名-context.xml 配置文件,如:SpringTestTest-context.xml IoC 容器BeanFactory:Spring 最底层的接口,只提供了的 IoC 功能，负责创建、组装、管理 bean,在应用中一般不使用 BeanFactoryApplicationContext:ApplicationContext 接口继承了BeanFactory,除此之外还提供 AOP 集成、国际化处理、事件传播、统 一资源价值等功能. bean实例化方式2.静态工厂方法实例化:解决系统遗留问题3.实例工厂方法实例化:解决系统遗留问题 必须保证 SomeBean1 必须有无参数构造器,和访问权限无关1.构造器实例化(无参数构造器),最标准,使用最多.12345public class SomeBean1 &#123; public SomeBean1() &#123; System.out.println("SomeBean1 构造器"); &#125;&#125;&lt;bean id="someBean1" class="...SomeBean1"/&gt; 4.实现 FactoryBean 接口实例化:实例工厂变种用于其他框架和 Spring 集成,如集成 MyBatis 使用:org.mybatis.spring.SqlSessionFactoryBean1234567891011public class SomeBean4 &#123;&#125;public class SomeBean4FactoryBean implements FactoryBean&lt;SomeBean4&gt;&#123; public SomeBean4 getObject() throws Exception &#123; //TODO return new SomeBean4(); &#125; public Class&lt;?&gt; getObjectType() &#123; return SomeBean4.class;&#125; &#125;&lt;bean id="someBean4" class="...SomeBean4FactoryBean"/&gt; Bean 作用域1&lt;bean id="" class="" scope="作用域"/&gt; singleton: 单例prototype: 多例,每次从容器中调用 Bean 时,都返回一个新的实例 Bean 初始化和销毁1.init-method:bean 生命周期初始化方法,bean 对象创建后就进行调用.2.destroy-method:容器被正常销毁的时候,如果 bean 被容器管理,会调用该方法. DI 核心1.所谓注入,可以简单理解为 IoC 容器创建对象的时候,设置相关的属性值.2.给对象设置数据:要么是在创建对象的时候通过构造器传入.要么就是先创建对象,再通过setter 方法再设置所以，注入方式主要有两种: 1.setter 方法注入 123456789101112131415161718//注入常量&lt;property name="name" value="蛤蛤"/&gt;//注入对象&lt;property name="instance" ref="instance"/&gt;//注入集合&lt;property name="prop"&gt; &lt;props&gt; &lt;prop key="pKey1"&gt;pVal1&lt;/prop&gt; &lt;prop key="pKey2"&gt;pVal2&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;//简写&lt;property name="prop"&gt; &lt;value&gt; pKey1=pValue1 pKey2=pValue2 &lt;/value&gt;&lt;/property&gt; 2.构造器注入: 构造器方式注入使用:1234567&lt;constructor-arg/&gt;元素//安装构造器的参数名字设置值&lt;constructor-arg name="name" value="will"/&gt;&lt;constructor-arg name="age" value="17" /&gt;&lt;constructor-arg name="other" ref="otherBean"/&gt;&lt;constructor-arg name="prop"&gt; 配置连接池12345678&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/springdemo"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="admin"/&gt; &lt;property name="initialSize" value="5"/&gt;&lt;/bean&gt; 抽取 db.properties 文件12345jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///springdemojdbc.username=rootjdbc.password=adminjdbc.initialSize=5]]></content>
      <categories>
        <category>Spring</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis增强]]></title>
    <url>%2F2019%2F05%2F10%2FMyBatis%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[使用mapper接口1.这个接口的全限定类名===对应的Mapper文件的namespace;2.这个接口中的方法和Mapper文件中的SQL元素一一对应: XML文件1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- StudentMapper的全限定类名 --&gt;&lt;mapper namespace="me.cscar.many2many.mapper.StudentMapper"&gt; &lt;insert id="save" useGeneratedKeys="true" keyProperty="id" keyColumn="id"&gt; INSERT INTO student (name) VALUES (#&#123;name&#125; ) &lt;/insert&gt;&lt;/mapper&gt; 测试类文件1234SqlSession session = MybatisUtil.getSession();StudentMapper studentMapper = session.getMapper(StudentMapper.class);/* 通过传入StudentMapper.class获得全限定名,就是namespace返回StudentMapper对象,调用save方法 */ mapper接口12void save(Student stu);//方法名为id 动态SQLif set where switch在多个中选择一个 foreach trim #{}和${}的区别相同: #和$都可以从对象或者Map中获取参数值 不同:使用#设置参数时候,先将参数转为?占位符,然后再赋值:使用PreparedStatement 使用$设置参数时,直接将参数拼接到sql中,使用Statement使用$设置参数可能存在SQL注入隐患. 使用#设置参数,如果是字符串,会自动加上’’, 而$不会,它会原样输出 在一些情况下,比如排序,比如分组操作时候拼接参数时不应该拼接’’ 总结:一般设置参数使用#,如果要拼接sql比如 排序,分组等.使用 $ (因为他们是按照列名来排序和分组的) 使用@param设置多个参数MyBatis在#{}中参数流程:1.会去参数对象中,按照属性或者Map的key去查询;2.如果找不到,尝试直接把方法的实际参数作为查询参数值 如果一定要在Mapper接口上的一个方法中添加多个参数,就一定要在每个参数前使用@Param标签. 原理:Mybatis在处理这些Mapper方法的时候,会自动的把这些参数包装成一个Map对象,@Param中的value就会作为这个Map的key,对应的参数值,就会作为这个Key的value; 原理:mybatis自动把参数封装成map 对象关系1.依赖关系:如果A对象离开了B对象,A对象就不能正常编译,则A对象依赖B对象. 2.关联关系:A对象依赖B对象,并且把B对象作为A对象的一个属性,则A和B是关联关系.(特殊的依赖关系) 3.聚合关系:表示整体和部分的关系,整体和部分之间可以相互独立存在,一定是有两个模块来分别管理整体和部分. 4.组合关系:强聚合关系,但是整体和部分不能独立存在,一定是在一个模块中同时管理整体和部分,生命周期必须相同. 5.泛化关系:其实就是继承关系. 关联关系划分1.一对一:一个A对象属于一个B对象,一个B对象属于一个A对象.2.一对多:一个A对象包含多个B对象. (判断基准:谁占主导地位),通过谁找到谁3.多对一:多个A对象属于一个B对象,并且每个A对象只能属于一个B对象.4.多对多:一个A对象属于多个B对象,一个B对象属于多个A对象.(老师和学生) MyBatis一级缓存缓存的作用/原理: 缓存本质来说就是Map,缓存是存在内存中的,可以在查询的时候减少数据库的访问次数,加快查询速度. 1.当第一次查询的时候get(1L),先将这次的调用转出一个字符串的key =Employee:1L首先在缓存中查询是否有这个key对应的对象,如果没有,去数据库中查询.查询之后会把该对象放入到缓存中,在把数据返回给调用者. 2.第二次查询的时候get(1L),先将这次的调用转出一个字符串的key =Employee:1L,在缓存中查询是否有可以key对应的对象,直接从内存中的缓存获取到对应的对象,直接返回一级缓存默认是开启的.一级缓存生命周期==session的生命周期,在多个session中是无法进行数据共享. 在一次会话中,如果需要查询多次相同id的对象,此时后面几次的查询都会从的缓存中获取,加快了查询速度,减少了访问数据库的次数.一级缓存的作用有限,只提高了一点点的性能. sqlsession的缓存操作注意问题:1: 缓存在同一个sqlsession才有效 2: 一旦sqlsession执行DML/DDL操作, 会清空缓存 3: 如果不想使用缓存,想直接从数据库获取: 可以执行: session.clearCache(); 4:开发中, sqlsession缓存仅仅针对某一个session, 对于整个系统性能提升不是很高, 一般来说, 不使用. 一般会使用二级缓存.(对应SqlSessionFactory) 二级缓存1.二级缓存生命周期==sessionFactory的生命周期. 2.二级缓存可以在不同的session之间进行数据的共享. 3.二级缓存默认是关闭的,需要手动的去开启. 4.不是所有对象都适合放到二级缓存中,只有是读远远大于写的对象才适合放到二级缓存中. 5.只要对象发生DML操作,MyBatis中的二级缓存都会给清除. 6手动开启的二级缓存.在对应的mapper.xml文件中添加一行: 一添加上就报错. java.io.NotSerializableException: cn.wolfcode._1_crud.User要求缓存的对象需要实现序列化接口. 缓存有个策略,当内存中的对象已经达到设置的存储最大值.超出的对象如果需要也缓存起来.支持把缓存对象序列化到硬盘中.要获取的时候再反序列化回来.]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie & Session]]></title>
    <url>%2F2019%2F05%2F05%2FCookie-Session%2F</url>
    <content type="text"><![CDATA[会话跟踪技术: Cookie SessionHTTP是无状态协议,也就是没有记忆力,每个请求之间无法共享数据. CookieCookie是客户端技术,程序把每个用户的数据以cookie的形式写给用户各自的浏览器.当用户使用浏览器再去访问服务器中的 web资源时,就会带着各自的数据去.这样,web资源处理的就是用户各自的数据了. Cookie 的使用:1.Cookie 是谁来创建,怎么创建的? 服务器端程序来创建: Cookie cookie = new Cookie(String name,String value); 参数: name: 给共享的数据起一个唯一的标志 value: 要存入的用户的数据 Cookie c = new Cookie(“currentName”,”xiaoming”); 2.如何响应 Cookie 给 浏览器. response对象.addCookie(Cookie cookie); resp.addCookie(c); 3.如何获取 Cookie 中的数据. 浏览器带过来的数据理应在请求对象中. Cookie[] cookies = request对象.getCookies(); 遍历数组拼配一个name是currentName 的数据. cookie.getName() : 获取Cookie 中的唯一标志的名称 cookie.getValue(): 当前Cookie 的数据. 4.修改Cookie 方式一: 再创建一个同 name 值的Cookie 对象来做覆盖的操作: Cookie cookie = new Cookie(“currentName”,”小明”) 方式二: 直接重新给Cookie赋值 cookie.setValue(“新的数据”) 注意: 两种方式都需要重新响应给浏览器去覆盖之前的Cookie 5.Cookie的中文问题 URLEncoder : 把中文转为非中文的字符串 URLDecoder : 把非中文的字符串转回中文 6 Cookie的分类 : 会话Cookie: 浏览器关闭 Cookie 就失效. 持久Cookie: Cookie 可以保留一定的时间. cookie.setMaxAge(int value): 使用的秒为单位: 负数: -1 : 不保存Cookie (会话Coookie); 0: 删除Cookie 正数: 设置存活的时间(秒) SessionSession是服务器端技术,利用这个技术,服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象,由于session为用户浏览器独享.所以用户在访问服务器的web资源时,可以把各自的数据放在各自的session中,当用户再去访问服务器中的其它web资源时,其它web资源再从用户各自的session中取出数据为用户服务. Session的使用Session 的使用:1 创建或获取Session 对象 HttpSession request.getSession(true) : 获取HttpSession对象,如果存在直接返回,如果不存在,创建一个新的Session对象然后返回. HttpSession request.getSession(false) : 获取HttpSession对象,如果存在直接返回,如果不存在返回null HttpSession request.getSession() : 同 1 2 设置共享数据 session.setAttribute(String name,Object value); 参数: name : 共享的数据的唯一标志 value : 要设置的共享数据 3 获取共享数据 session.getAttribute(String name); 4 移除 Session 中的数据 1:删除Session中指定属性名的值. session.removeAttribute(String name); 2:销毁Session对象 session对象.invalidate(); 5 Session的超时管理. 默认的超时时间: 30分钟 : 在Tomcat/conf/web.xml session.setMaxInactiveInterval(int seconds) 6 URL重写:Session 是一个特殊的Cookic ,存在浏览器上,用户可选择不接受Cookie方式一: 使用参数形式 jsessionid 传递给下一个请求,使用 ; 来设置参数的值方式二: 调用方法来生成带有 jsessionid 的 urlString url = resp.encodeURL(“/session/content”);开发中不要拒收Cookie]]></content>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三层架构]]></title>
    <url>%2F2019%2F05%2F05%2F%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[三层构架 表示层:位于最上层,最接近用户,用于显示数据和接收用户输入的数据,为用户提供一种交互式操作的界面 业务逻辑层:表示层和 DAL(DAO)层之间的桥梁,实现业务逻辑.业务逻辑具体包含:验证,计算,业务规则等等 数据访问层:与数据库打交道.主要实现对数据的增、删、改、查.将存储在数据库中的数据提交给业务层,同时将业务层处理的数据保存到数据库(Dao) 逻辑图: 业务逻辑层(service)其实是一个组件(可以重复使用),包括:接口和接口的实现类 service 组件起名规范:以下使用 Xxx 都表示一个对象比如 Employee,Department.service 接口 : IEmployeeServiceservice 实现类: EmployeeServiceImplservice 测试类: EmployeeServiceTestservice 对象的名字: Employee,Department]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL增强]]></title>
    <url>%2F2019%2F05%2F03%2FMySQL%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[数据库数据库（DataBase）：是一个按数据结构来存储和管理数据的计算机软件系统. 简而言之:存储数据的仓库/存储数据的特殊文件. 1.数据定义语言:DDL数据库建立、修改、变更及扩充功能2.数据操纵语言:DML实现数据的插入,修改,删除,查询,统计等数据存取操作的功能称为数据操纵功能3.数据查询语言:DQL用以从表中获得数据,确定数据怎样在应用程序给出.保留字SELECT是DQL(也是所有SQL)用得最多的动词,其他DQL常用的保留字有WHERE,ORDER BY,GROUP BY和HAVING.这些DQL保留字常与其他类型的SQL语句一起使用 数据库基础关系型数据库和非关系型数据库关系型数据库：在关系模型中，数据的逻辑结构为满足一定条件的二维表，表具有固定的列数和任意的行数，在数学上称为”关系” 关系型数据库的三范式:第一范式(1NF):是对关系模式的基本要求,不满足第一范式就不是关系数据库.是指数据表的每一列都是不可分割的基本数据项,同一个列中不能有多个值. 第二范式(2NF):每个实例或行&apos;必须有主键&apos;,区分每一行数据(可以被打破) 第三范式(3NF):要求一个数据表中,不包含其它表中的非主键信息.(在设计表的时候,为了性能,有时会打破第3范式) 常见的数据库1.Oracle：大型企业数据库，支持数据量，速度较快，安全性非常好，提供完善的存储过程支持；新的版本提供了众多新功能； 2.DB2（IBM）：大型企业数据库，支持数据量，速度较快，安全性较好, 恢复性强； 3.SQL Server（MS）：大型企业数据库，支持数据量，速度较快，安全性较好； 4.MySQL（Oracle）：性能不错，使用方便，体积小，易扩展；是目前使用最广的关系型数据库； 查询多表查询-笛卡尔积没有连接条件的表关系返回结果,多表查询会产生笛卡尔积.解决方案: 在WHERE加入有效的连接条件—-&gt;等值连接隐藏内连接查询语法:1234SELECT &lt;select_list&gt;FROM 表名称 A, 表名称 BWHERE 查询条件 AND 消除笛卡尔积的连接条件[ORDER BY 排序字段 [ASC|DESC] [,排序字段 [ASC|DESC] ,…]]; 显示内连接查询语法:12SELECT &lt;select_list&gt;FROM A [INNER] JOIN B ON 消除笛卡尔积的连接条件 [JOIN ...] 内连接查询,两种查询的结果完全相同,区别在于是否能看到JOIN关键字 unionJOIN是用于把表横向连接，UNION/UNION ALL是用于把表纵向连接(一般用于做查询的临时表)UNION 操作符用于合并两个或多个 SELECT 语句的结果集.1234语法：SELECT column_name(s) FROM table_name1UNION|UNION ALLSELECT column_name(s) FROM table_name2 单行函数DAY(date):获取日期中的天数（DAYOFMONTH）HOUR(time):返回time 对应的小时数。对于日时值的返回值范围是从 0 到 23MINUTE(time):返回 time 对应的分钟数,范围是从 0 到 59MONTH(date):返回date 对应的月份，范围时从 1 到 12YEAR(date):返回date 对应的年份,范围是从1000到9999LAST_DAY(date):获取一个日期或日期时间值，返回该月最后一天对应的值DATE_FORMAT(data,format) 聚合分组函数AVG：计算平均值SUM：计算总和 COUNT ({ |[DISTINCT|ALL]expr})COUNT()返回表中所有符合条件的记录数COUNT(字段) 返回所有符合条件并且字段值非空的记录(右键设置某个字段为null,如果加了where条件后, 就以where 后面的列作为计数条件)COUNT(distinct(expr))返回不重复的，非空值的数量 MIN and MAX适用于任何数据类型MIN： 计算最小值MAX：计算最大值 分组查询分组查询的语法:SELECT [DISTINCT] *|分组字段1 [别名] [,分组字段2 [别名] ,…] | 统计函数/分组函数/聚合函数FROM 表名称 [别名], [表名称 [别名] ,…][WHERE 条件(s)][GROUP BY 分组字段1 [,分组字段2 ,…]][ORDER BY 排序字段 ASC | DESC [,排序字段 ASC | DESC]]; 注意: 1出现在SELECT列表中的字段,如果出现的位置不是在聚合函数中,那么必须出现在 GROUP BY 子句中 2.在GROUP BY 子句中出现的字段，可以不出现在SELECT列表中 3.如果没有GROUP BY子句, SELECT列表中的任何列或表达式不能和统计/分组/聚合函数同时使用： 错误操作: select ename, sal, count(empno) from emp; 如果现在要进行分组的话，则SELECT子句之后，只能出现分组的字段和统计函数，其他的字段不能出现 使用HAVING子句对分组的结果进行限制 1.不能在 WHERE 子句中 对分组之后的结果过滤. 2.使用group by语句后,如果需要过滤, 必须使用 HAVING 子句(分组后的过滤). 3.不能在 WHERE 子句中使用聚合函数. 其他123select -- from --- where --- group by ----having --- order by --- limit?,?sql 执行顺序~~~from -- where -- group by -- having -- select -- order by -- limit ?, ? 子查询子查询指的就是在一个查询之中嵌套了其他的若干查询.在where查询条件中的限制条件不是一个确定的值,而是来自于另一个查询结果. 子查询一般出现在FROM和WHERE子句中. 使用子查询的注意事项: 1.子查询要用括号括起来 2.将子查询放在比较运算符的右边(增强可读性) 3.对单行子查询使用单行运算符 4.对多行子查询使用多行运算符 语法:123SELECT &lt;select_list&gt;FROM 'table'WHERE 条件 操作符 (SELECT select_list FROM table); 子查询的分类:单行单列子查询,得到的是一个值,返回的结果只包含一行数据 多行单列子查询,得到的是一个集合,返回多行或零行 多行多列子查询,得到的是一个二维表,包含多个字段的返回(一张临时的表) 单行单列子查询:1.返回一行记录,好比一个值.2.使用单行记录比较运算符=;&gt;;&gt;=;&lt;;&lt;=!=(针对于一个值得运算符) 多行子查询返回多行单列1.返回多行,好比多个值2.使用多行比较运算符 IN:与列表中的任意一个值相等 =ANY:此时和IN操作符相同 &gt;ANY:大于子查询中最小数据 &lt;ANY:小于子查询中最大数据 &gt;ALL:大于子查询中最大的数据 &lt;ALL:小于子查询中最小的数据 多列子查询子查询返回的结果是多行多列/一行多列,只要是多列,就可以看成是一张表.一般会把多列子查询.返回的结果当成一个临时表,接着在临时表上继续查询或者询注意:多行多列的子查询返回的结果必须要设置一个临时表的名称. DML操作1.插入操作1INSERT INTO table [(column [, column...])] VALUES (value [, value...]),(value [, value...]),... 一条SQL的长度是有限的，可以通过调整max_allowed_packet参数(可以在my.ini文件中修改) 2.更新操作123UPDATE tableSET column = value [,column = value]…[WHERE condition]; UPDATE语句也可以使用表连接，子查询等多种方式执行3.删除操作12DELETE FROM table[WHERE condition]; 事务控制开启事务: begin提交事务: commit回滚事务: rollback 事务的ACID:原子性:Atomicity一致性:Consistency隔离性:Isolation持久性:Durability 控制事务的SQL语句(命令):commit 和 rollback可以显示的控制事务好处：1.保证数据一致性,修改过的数据在没有提交之前是不能被其他用户看到的2.在数据永久性生效前重新查看修改的数据3.将相关操作组织在一起,一个事务中相关的数据改变或者都成功,或者都失败 数据库的并发问题:MySQL使用的是repreatable read隔离级别 避免第二类丢失更新 方案1:悲观锁: 使用数据库自身的排它锁机制(写锁)(排斥其他锁).DML操作自动会加上排它锁 (排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁). DQL操作需要我们手动加上排他锁.1SELECT * FROM 表名 FOR UPDATE. 方案2:乐观锁: 在表中额外增加一个列,用来表示修改的版本(整数类型),修改一次就把版本增加1. 1:在表中新增一个列,用来表示修改的版本号,类型使用整数类型,初始值为0. 2:每次在修改数据之前,先发送SELECT语句去查询当前被修改数据的信息(包括版本号).1SELECT id,name,version FROM person WHERE id = 10; 查询出来的版本号为0. 3:发送UPDATE语句去更新数据:版本号修改递增1/判断条件中的版本号必须是刚刚查询出来的版本.1UPDATE person set name = 'Java' ,version = version + 1 WHERE id = 10 AND version = 刚刚查询出来的版本号(0). 4:判断update语句执行之后的受影响行数(rows),若rows&gt;0则提交事务,否则回滚事务. 数据库的权限权限相关命令:GRANT:MySQL中用于赋权限的命令是GRANT，语法为：完整语法：GRANT 权限 (columns)ON 数据库对象TO 用户 IDENTIFIED BY “密码”WITH GRANT OPTION 三种具体的语法: 给一个存在用户赋予权限:语法1:GRANT 权限 (columns) ON 数据库对象 TO 用户:赋予will账户:SELECT和INSERT权限.GRANT select,insert ON . TO will@localhost; 左边是数据库 . 右边是数据表. 表示全局权限 创建用户,设置密码,赋予权限:语法2:GRANT 权限 (columns) ON 数据库对象 TO 用户 IDENTIFIED BY “密码”创建lucy用户:GRANT ALL ON . TO lucy@localhost IDENTIFIED BY ‘1234’; 创建用户,设置密码,赋予权限,并且该用户可以继续授权给其他用户:语法3:GRANT 权限 (columns) ON 数据库对象 TO 用户 IDENTIFIED BY “密码” WITH GRANT OPTION]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web组件交互_el_jstl]]></title>
    <url>%2F2019%2F04%2F22%2Fweb%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92-el-jstl%2F</url>
    <content type="text"><![CDATA[web组件在web应用中,servlet/jsp就是web的组件 跳转:请求转发和重定向 共享数据:作用域对象 jsp页面取数据EL表达式 优雅的显示数据JSTL 请求转发1.请求转发:forward2.重定向:redirect3.请求包含:include常用api: 在HttpServletRequest对象中 RequestDispatcher getRequestDispatcher(String path):获取请求分发器. String path: 请求转发到的目标资源 void forward(ServletRequest request, ServletResponse response) :请求转发的动作. 12//获取到请求分发器,请求转发到WEB-INF/view/product/table.jsp资源上 req.getRequestDispatcher("WEB-INF/view/product/table.jsp").forward(req, resp); url重定向在HttpServletResponse对象中. void sendRedirect(java.lang.String location) : 重定向, String location: 重新定位的资源的地址.12//url重定向resp.sendRedirect("/pro?cmd=list"); 1.地址栏会发生变化.是s2. 2.只会有目标资源s2的响应,s1的响应不生效. 3.重定向会发送两次请求.在多个组件不能共享数据. 4.重定向,不能访问WEB-INF中的资源,相当于是把目标资源放在浏览器的地址栏敲回车. 5.重定向可以访问别人(域外)的资源. 请求转发和url重定向选择请求转发: 共享数据 请求到WEB-INF中的资源url重定向: 访问域外资源都能使用的情况,使用重定向 三大作用域对象 作用域 类型 描述 request HttpServletRequest 在一次请求中,多个组件都共享数据,需要使用请求.request在service方法中,tomcat在调用这个生命周期方法的时候,就会创建. session HttpSession HttpSession session = request.getSession(); 使用请求对象获取session对象 application ServletContext ServletContext application = getServletContext(); ServletContext application = request.getServletContext(); 共享数据的基本操作 1.新增数据: void setAttribute(java.lang.String name, java.lang.Object o): 保存数据,包含唯一的名字,和可重复值.2.删除数据: void removeAttribute(java.lang.String name):根据共享属性名.来删除共享数据3.修改数据: void setAttribute(java.lang.String name, java.lang.Object o):同新增4.查询数据: java.lang.Object getAttribute(java.lang.String name):通过共享数据(属性)的唯一名字,找到对应的值. 三大作用域范围1.请求作用域对象:1req.setAttribute("MSG_IN_REQUEST","request"); 只能在一次请求中共享数据,如果不是同一个请求,是多次请求,一定不能共享.如果想要在一次请求过程中的多个组件,要共享,需要使用请求转发. 2.会话作用域对象:1req.getSession().setAttribute("MSG_IN_SESSION","session"); 想在访问站点之后,多次请求都需要共享.可以使用session对象.从访问开始到浏览器关闭为止.3.应用作用域对象:1req.getServletContext().setAttribute("MSG_IN_APPLICATION","application"); 只要服务器开启,都可以共享. 上下文对象:环境.整个应用的生命周期.从服务器启动,到服务器关闭,只有一个. 对象的获取方式: 1.当前servlet中,可以调用getServletContext来获取. 2.request对象可以调用getServletContext获取. 3.session对象可以调用getServletContext来获取. 不管用什么对象来获取到的上下文对象,都是同一个对象. 常用的API: java.lang.String getRealPath(java.lang.String path) :传递一个地址,可以得到真正的磁盘地址. 负责把路径直接拼接到webapp根的后面,不负责去校验是否合法. String getContextPath();获取上下文路径. EL表达式:语法格式:${共享数据的属性名.属性名.属性名}.从page作用域开始,一直找到application为止,如果找到,直接返回,如果没找到,返回的是空字符串. JSTL使用JSTL标签库消除JSP中的java代码 条件判断1.if单条件判断123&lt;c:if test="$&#123;用EL表达式取出来的值&#125;" //如果test返回true,执行&lt;/c:if&gt; 2.choose多条件判断12345678&lt;c:choose&gt;&lt;c:when test="$&#123;用EL表达式取出来的值&#125;"&gt; //&lt;/c:when&gt;&lt;c:otherwise&gt; //TODO...&lt;/c:otherwise&gt;&lt;/c:choose&gt; 循环标签1234567&lt;c:forEach var="stu" items="$&#123;result.listData&#125;" varStatus="vs"&gt; &lt;tr&gt; &lt;td&gt;$&#123;vs.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; items代表源数据,需要使用EL表达式去取var代表每一个变量,该变量将会存储到PageContext作用域中varStatus代表迭代状态.vs.index:从0开始,vs.count:从1开始 时间格式化标签1&lt;fmt:formatDate value="$&#123;date&#125;" pattern="yyyy-MM-dd"/&gt;]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>网络编程</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis设计模式总结]]></title>
    <url>%2F2019%2F04%2F17%2FMyBatis%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MyBatis设计模式总结Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder； 工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory； 单例模式，例如ErrorContext和LogFactory； 代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；组合模式，例如SqlNode和各个子类ChooseSqlNode等；模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；迭代器模式，例如迭代器模式PropertyTokenizer； Builder模式在SqlSessionFactoryBuilder类中,重载了build方法这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决,对于builder的具体类，方法都大都用build*开头.即根据不同的输入参数来构建SqlSessionFactory这个工厂对象]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2019%2F04%2F17%2FMyBatis%2F</url>
    <content type="text"><![CDATA[ORM思想对象关系映射Object Relational MappingORM主要解决对象-关系的映射 对象 关系 类 表 对象 表的行(记录) 属性 表的列(字段) MyBatis:本是apache的一个开源项目iBatis,提供的持久层框架包括SQL Maps和DAO,允许开发人员直接编写SQL主配置文件,关联映射文件 XML映射配置文件 mybatis-config.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- properties配置文件 --&gt; &lt;properties resource="db.properties"&gt;&lt;/properties&gt; &lt;!-- domain的全限定名 --&gt; &lt;typeAliases&gt; &lt;package name="me.cscar.smis.domain.Student"/&gt; &lt;/typeAliases&gt; &lt;!-- 告知框架,链接数据库的四要素,以及事务的处理 --&gt; &lt;environments default="dev"&gt; &lt;!-- id属性是某一个环境的唯一标记 --&gt; &lt;environment id="dev"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 驱动名,键值对,对应properties --&gt; &lt;property name="driver" value="$&#123;driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 找到Sql的映射文件,包名开头(域名倒写)的路径 --&gt; &lt;mappers&gt; &lt;mapper resource="me/cscar/smis/mapper/StudentMapper.XML" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; StudentMapper.XML123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 命名空间mapper接口的全限定名 --&gt;&lt;mapper namespace="me.cscar.smis.mapper.StudentMapper"&gt; &lt;!-- id属性:当前的sql语句,在mapper的唯一标记 --&gt; &lt;insert id="save"&gt; &lt;!-- 占位符#&#123;&#125;,mybatis从对应的对象中,取出指定的属性值 --&gt; INSERT INTO student (name,age) VALUES (#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 如果是DML操作,直接告知sql.在执行的时候,传递参数,使用OGNL表达式来获取值. 如果是DQL(查询)操作,还必须告知框架,查询的结果的每一行封装成什么类型的对象. sql语句的执行流程: 首先,会将#{}更改成占位符?, 然后,通过传递过来的参数来设置给占位符. 如果列名和属性名匹配,可以使用resultType,也可以使用resultMap. 如果不匹配,要使用resultMap. Mybatis.java1234567891011121314151617181920212223242526package me.cscar.smis.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;public class MybatisUtil &#123; private static SqlSessionFactory factory = null; static &#123; try &#123; factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream("mybatis-config.xml")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession() &#123; return factory.openSession(); &#125;&#125; mybatis操作流程: 加载主配置文件,获取factory对象. factory = new SqlSessionFactoryBuilder().build(); 获取xml文件,等同于thread… Resources.getResourceAsStream(“mybatis-config.xml”) 通过factory对象获取session对象. 调用Mybatis的getSqlSession方法,返回openSession 通过session执行sql. … DML操作要手动提交事务. … 关闭资源]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2F04%2F15%2FServlet%2F</url>
    <content type="text"><![CDATA[Servlet概述Java Servlet(服务小程序),生成动态的web内容Servlet运行于支持Java的web应用服务器中 1.导入jar包.在/Library/Tomcat/lib/servlet-api.jar 2.创建一个类,实现servlet接口 3.配置web.xml web.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!-- 配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;me.cscar.network.servlet.HelloServlet&lt;/servlet-class&gt; &lt;!-- 初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 映射 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 一个实现servlet接口的类1234567891011121314151617181920212223242526272829303132333435package me.cscar.network.servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.IOException;public class HelloServlet implements javax.servlet.Servlet&#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("success"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; servlet的生命周期1.创建对象 2.初始化 3.执行操作 4.销毁 整个生命周期的过程都是用Tomcat来管理调用123456789101112131415161718192021//初始化方法public void init(ServletConfig servletConfig) throws ServletException &#123;&#125;//获取当前servlet的配置信息public ServletConfig getServletConfig() &#123; return null;&#125;//执行操作的方法public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;&#125;//返回作者,版权信息,版本信息public String getServletInfo() &#123; return null;&#125;//销毁方法public void destroy() &#123;&#125; 注意:在servlet整个生命周期中,都是单例的.servlet的构造器必须是公共无参数构造器 servlet的请求流程1.在当前项目的根路径下的WEB-INF目录中,读取web.xml文件2.获取web.xml中所有的元素,判断是否存在标签里的资源名称,不存在返回404错误3.根据/资源名称获取对应的servlet的全限定名.4.根据获取到的全限定名,使用反射来调用构造器,创建对象1Object obj = Class.forName("全限定名").newInstance(); 5.使用创建的servlet对象,调用init(config)方法.或者,从Tomcat中的servlet实例缓冲池中取出”全限定名”对应的对象,Servlet obj = …6.创建ServletRequest对象,ServletResponse对象,再使用servlet对象调用service方法.1obj.service(req,resp) 7.在service方法中对客户端做响应操作 Servlet接口配置web.xml初始化参数12345&lt;!-- 初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; 通过servlet对象获取参数1String encoding = obj.getInitParameter("encoding") //utf-8 获取所有的初始化参数名称123456Enumeration&lt;String&gt; names = obj.getInitParameterNames(); //使用迭代器遍历while (names.hasMoreElements()) &#123; String name = names.nextElement(); String value = config.getInitParameter(name); System.out.println(name + ":" + value);&#125; 方法1234String getServletName() //获取当前Servlet 的&lt;servlet-name&gt;中的内容ServletContext getServletContext() //获取上下文对象,一个应用就只有一个上下文对象String getInitParameter(String name) //获取指定名称的初始化参数值Enumeration&lt;String&gt; getInitParameterNames() //获取所有的初始化参数的名称 Servlet的继承体系12345678910111213141516171819package me.cscar.network.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HttpServletDemo extends HttpServlet &#123; @Override public void init() throws ServletException &#123; System.out.println("自己的初始化代码"); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("执行操作"); &#125;&#125; HttpServletRequest常用方法 常用方法 返回 req.getMethod() 请求方式(post,get) req.getRequestURI 返回请求行中的资源名字部分 req.getRequestURL() 返回客户端请求的完整url req.getContextPath() 获取当前项目的上下文路径path的值 req.getRemoteAddr() 发出请求的客户机ip地址 req.getHeader(“User-Agent”) 指定名称的头字段的值 获取表单请求参数 方法 返回 req.getParameter(“value”) 获取表单请求参数 getParameterValues(“hobby”) 指定名字参数的多个参数值。(复选框) req.getParameterNames() 获取表单的所有参数名 req.getParameterMap() 把所有的表单数据保存在map中 getOutputStream() 获取字节输出流对象. ( 文件下载) getWriter() 获取字符输出流对象 response.setContentType(“text/html;charset=utf-8”) 设置输出的MIME类型和编码方式 123456789101112131415161718192021222324252627282930313233343536//req.getMethod():返回请求方式System.out.println(req.getMethod());//req.getRequestURI:返回请求行中的资源名字部分System.out.println(req.getRequestURI());//返回客户端请求的完整urlSystem.out.println(req.getRequestURL());//获取当前项目的上下文路径&lt;context&gt;path的值System.out.println("ContextPath" + req.getContextPath());//返回发出请求的客户机ip地址System.out.println(req.getRemoteAddr());//返回指定名称的头字段的值System.out.println(req.getHeader("User-Agent"));//设置编码req.setCharacterEncoding("UTF-8");System.out.println("name:" + req.getParameter("username"));System.out.println("password:" + req.getParameter("psw"));//获取表单中的多个数据String[] values = req.getParameterValues("hobby");System.out.println(Arrays.toString(values));//获取表单的所有参数名Enumeration&lt;String&gt; names = req.getParameterNames();while (names.hasMoreElements()) &#123; String name = names.nextElement(); System.out.println(name);&#125;//把所有的表单数据保存在map中Map&lt;String, String[]&gt; map = req.getParameterMap();Set&lt;Map.Entry&lt;String, String[]&gt;&gt; entrySet = map.entrySet();for (Map.Entry&lt;String, String[]&gt; entry : entrySet) &#123; String name = entry.getKey(); String[] value = entry.getValue(); System.out.println(name + ":" + Arrays.toString(value));&#125; JSP的原理流程:1.所有的jsp,jspx的访问都交给JspServlet来处理2.把jsp文件转化为java文件3.把所有java文件都转化为字节码文件4.把转化的文件存放在tomcat/work/…文件下 体系:HttpServlet &lt;- HttpJspBase &lt;- myDemo_jspjsp就是一个Servlet在java文件中123out.write("");...out.print(...); 存在字符输出流对象,输出了html jsp语法:123456789&lt;%!Java代码%&gt;&lt;%-- 注释,不会编译到servlet中 --%&gt;&lt;%= 表达式(调用out.print,输出到页面上) %&gt; JSP 三大指令 page include taglib page指令:作用：定义JSP页面的各种属性 属性：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748language:指示JSP页面中使用脚本语言。默认值java，目前只支持java。extends：指示JSP对应的Servlet类的父类。不要修改。*import：导入JSP中的Java脚本使用到的类或包。（如同Java中的import语句）JSP引擎自动导入以下包中的类： javax.servlet.* javax.servlet.http.* javax.servlet.jsp.*注意：一个import属性可以导入多个包，用逗号分隔。*sessioin:指示JSP页面是否创建HttpSession对象。默认值是true，创建*buffer：指示JSP用的输出流的缓存大小.默认值是8Kb。autoFlush：自动刷新输出流的缓存。isThreadSafe：指示页面是否是线程安全的（过时的）。默认是true。 true：不安全的。 false：安全的。指示JSP对应的Servlet实现SingleThreadModel接口。 *errorPage: 指示当前页面出错后转向（转发）的页面。 目标页面如果以"/"（当前应用）就是绝对路径。配置全局错误提示页面：web.xml&lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;&lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt;&lt;/error-page&gt;*isErrorPage:指示当前页面是否产生Exception对象。*contentType：指定当前页面的MIME类型。作用与Servlet中的response.setContentType()作用完全一致*pageEncoding：通知引擎读取JSP时采用的编码（因为要翻译） 还有contentType属性的作用。*isELIgnored:是否忽略EL表达式。$&#123;1+1&#125;。默认值是false。 page指令最简单的使用方式：&lt;%@ page pageEncoding="UTF-8"%&gt;2.include（静态包含,开发中能用静的不用动的） 作用：包含其他的组件。 语法：&lt;%@include file=""%&gt;file指定要包含的目标组件。路径如果以"/"（当前应用）就是绝对路径。 原理：把目标组件的内容加到源组件中，输出结果。 动态包含： 采用动作元素：&lt;jsp:include page=""/&gt;路径如果以"/"（当前应用）就是绝对路径。 3.taglib 作用：引入外部的标签 语法 &lt;%@ taglib uri="标签名称空间" prefix="前缀"%&gt; &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>网络编程</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F04%2F15%2FHttp%2F</url>
    <content type="text"><![CDATA[HTTP概述特点:无状态,,默认端口是80HTTP协议:浏览器(客户端)于web服务器之间一问一答的交互过程必须遵循一定的规则 UDP:面向数据报包,基于无连接,可能会丢包,速度快.广播.一堆人都可以听到,但是可能有部分人丢失数据.TCP:面向连接,传输可靠.性能低一些.相当于是一对一的教学,保证客户端和服务端一定能传输数据.基于浏览器的开发,都是TCP连接. HTTP1.1规范在一次TCP连接之间,多次请求,多次响应,响应完之后再关闭连接 GET和POST的区别GET:在请求某个服务器资源,如果没有指定请求方式,默认为GET可以通过GET的方式向服务器传递数据.方式:在URL路径加上?,多个参数用&amp;分割GET请求方式数据不安全(在URL显示),且URL有长度限制1Kget可以缓存,查询的时候可以使用getPOST:数据安全,且没有长度限制只有post才有请求实体.表单全部使用post提交]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>网络编程</tag>
        <tag>服务器</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接池]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[连接池在Java中,连接池使用javax.sql.DataSource接口来表示连接池.DataSource(数据源)和连接池(Connection Pool)是同一个. DBCP: Spring框架推荐的 druid: 阿里巴巴的连接池(号称Java语言中性能最好的连接池) DBCP连接池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package me.cscar.dbcp.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCutil &#123; private static Properties prs = new Properties(); private static BasicDataSource bds = null; //private static DataSource dsf = null; static &#123; try &#123; InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("db.properties"); prs.load(in); Class.forName(prs.getProperty("driverClassName")); //在静态代码块中初始化连接池对象,连接池只需一个即可 bds = BasicDataSourceFactory.createDataSource(prs); //druid连接池 //dsf = DruidDataSourceFactory.createDataSource(prs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; Connection conn = bds.getConnection(); //Connection conn = dsf.getConnection(); return conn; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(ResultSet rs, PreparedStatement ps, Connection conn) &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; druid连接池阿里巴巴研发出来的号称Java语言领域性能最高的连接池.wiki地址:https://github.com/alibaba/druid/wiki 使用起来,类似于DBCP连接池.方便检测性能/状态.支持:MySQL,Oracle,DB2,sql Server等.支持:对配置文件的密码加密.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package me.cscar.dbcp.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCutil &#123; private static Properties prs = new Properties(); //private static BasicDataSource bds = null; private static DataSource dsf = null; static &#123; try &#123; InputStream in = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("db.properties"); prs.load(in); Class.forName(prs.getProperty("driverClassName")); //在静态代码块中初始化连接池对象,连接池只需一个即可 //bds = BasicDataSourceFactory.createDataSource(prs); //druid连接池 dsf = DruidDataSourceFactory.createDataSource(prs); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; //Connection conn = bds.getConnection(); Connection conn = dsf.getConnection(); return conn; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(ResultSet rs, PreparedStatement ps, Connection conn) &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码重构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package me.cscar.dbcp.dao.impl;import me.cscar.dbcp.dao.IemployeeDAO;import me.cscar.dbcp.domain.Employee;import me.cscar.dbcp.util.JDBCutil;import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class EmployeeDAOimpl implements IemployeeDAO &#123; public static EmployeeDAOimpl instance = new EmployeeDAOimpl(); /** * dml操作 * * @param sql * @param obj */ @Override public void dml(String sql, Object... obj) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; obj.length; i++) &#123; ps.setObject(i + 1, obj[i]); &#125; ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(null, ps, conn); &#125; &#125; /** * 查 * * @param emp,args * @return */ @Override public List&lt;Employee&gt; get(String sql, Object emp, Object... args) &#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); Class&lt;?&gt; clz = emp.getClass(); while (rs.next()) &#123; BeanInfo info = Introspector.getBeanInfo(clz, Object.class); PropertyDescriptor[] pds = info.getPropertyDescriptors(); Object obj = clz.newInstance(); for (PropertyDescriptor ele : pds) &#123; //id,name,salary String cloumnName = ele.getName(); Object cloumnValue = rs.getObject(cloumnName); //getter,setter Method m = ele.getWriteMethod(); m.invoke(obj, cloumnValue); &#125; list.add((Employee) obj); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(rs, ps, conn); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>DataBase</category>
        <category>pool</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2019%2F04%2F10%2F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务事务(Transaction,简写为tx)1.当一个逻辑操作单元全部完成的时候,提交(commit)事务,这个操作就永久的保存到数据库中 2.如果回退(rollback),则放弃这个逻辑单元的所有操作 3.对于多个操作来说,作为一个整体(不可分割),所有操作成功(提交事务),数据库的数据才会改变 事务的ACID属性1.原子性(Atomicity) 2.一致性(Consistency) 3.隔离性(Isolation) 4.持久性(Durability) 事务的操作1.如果要控制事务,需要手动提交2.在MySQL中,只有InnoDB存储引擎支持事务123456789101112131415161718192021222324252627282930313233343536373839404142434445package me.cscar.account.test;import me.cscar.account.dao.impl.AccountDAOimpl;import me.cscar.account.util.JDBCutil;import org.junit.Test;import java.math.BigDecimal;import java.sql.Connection;import java.sql.SQLException;public class TXBalance &#123; @Test public void testTx() throws Exception &#123; BigDecimal money = new BigDecimal("1000"); AccountDAOimpl account = AccountDAOimpl.getInstance(); Connection conn = null; try &#123; if (account.getBalance("嘤嘤", money)) &#123; conn = JDBCutil.getConnection(); //设置手动处理事务 conn.setAutoCommit(false); account.addBalance("蛤蛤", money, conn); //假设出错 int i = 1 / 0; account.reduceBalance("嘤嘤", money, conn); //全部操作成功,提交事务 conn.commit(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); conn.rollback(); &#125; &#125;&#125; 获取自动生成的主键在数据库中保存数据的时候,要使用到自增id的时候就需要取出来. 1.如果要获取,需要设置一个标记. PreparedStatement prepareStatement(String sql, int autoGeneratedKeys):获取预编译语句对象的时候,可以设置标记,是否要获取自动生成的主键. autoGeneratedKeys: 是否要获取自动生成的主键. Statement.RETURN_GENERATED_KEYS 2.获取自动生成的主键. ResultSet getGeneratedKeys(): 获取自动生成的主键. 12345678910111213141516171819202122public class GetKey &#123; @Test public void testGetKey() throws Exception &#123; //插入一条数据到account表中获取自动生成的组件 String sql = "INSERT INTO account (name,balance) VALUES (?,?)"; Connection conn = JDBCutil.getConnection(); PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); ps.setObject(1, "包包"); ps.setObject(2, 10000); ps.executeUpdate(); //获取自动生产的组件 ResultSet rs = ps.getGeneratedKeys(); while (rs.next()) &#123; System.out.println(rs.getObject(1)); &#125; rs.close(); JDBCutil.close(ps, conn); &#125;&#125;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F04%2F06%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC概述可以为多种关系数据库提供统一访问,为开发者屏蔽了一些细节问题 获取数据库链接对象Connection -&gt; 数据库连接对象 导入驱动包 获取数据库连接对象 1.加载注册驱动: Driver驱动类:应该加载驱动包中实现Driver接口类的对象 public static void registerDriver(Driver driver):注册驱动 API中,建议使用Class.forName(“com.mysql.jdbc.Driver”);加载字节码对象的时候,会执行这个类的静态代码块. 调用Class.forName不是目的,目的是为了执行com.mysql.jdbc.Driver这个类的静态代码块. 而这个类的静态代码块就是在加载注册驱动 2.获取数据库连接对象 DriverManager驱动管理类: public static Connection getConnection(String url, String user, String password): 获取数据库连接对象. JDBC操作模板1.加载注册驱动 2.获取数据库连接对象 3.生成预编译语句对象 4.执行SQL命令 5.释放资源 相关操作executeQuery(String sql): 执行DQL操作,返回单个ResultSet对象.executeUpdate(String sql): 执行DDL和DML操作 DML操作123456789101112131415161718192021222324252627package me.cscar.dml;import me.cscar.util.JDBCUtil;import org.junit.Test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class InsertTable &#123; @Test public void testInsertTable() throws Exception &#123; String sql = "INSERT INTO student(name,age) VALUES('东方翠花',20)"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.链接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javaweb", "***", "***"); //3.创建语句对象 Statement st = conn.createStatement(); //4.执行SQL命令 st.executeUpdate(sql); //5.释放资源 JDBCUtil.close(conn, st); &#125;&#125; 抽象出JDBCUtil包,复用释放资源代码 1234567891011121314151617181920212223public class JDBCUtil &#123; public JDBCUtil() &#123; &#125; public static void close(Connection conn, Statement st) &#123; try &#123; if (st != null) &#123; st.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 预编译语句对象PreparedStatement对象:又叫做预编译语句对象,是一个包含占位符?的sql模板. 1.PreparedStatement ps= conn.prepareStatement(sql模板);// 传递的是sql模板,不能直接执行. 2.ps.setObject(int parameterIndex, Object x):给占位符?设置值,parameterIndex代表第N个?号,x是具体参数 3.执行sql语句:不能调用父类带参数的方法. 如果直接调用父类的带sql参数方法,会直接将带占位符?的sql模板拿过去执行 123456789101112131415161718192021222324public class Insert &#123; @Test public void TestInsert() throws Exception &#123; Student stu = new Student(null, "小茗同学", 20); //问号表示占位符 String sql = "INSERT INTO student(name,age) VALUES(?, ?)"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.链接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///javaweb", "root", "admin"); //3.获取预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //4.执行SQL语句,给占位符设置值 ps.setObject(1, stu.getName()); ps.setObject(2, stu.getAge()); ps.executeUpdate(); //释放资源 JDBCUtil.close(conn, ps); &#125;&#125; DQL操作ResultSet常用的API: Object getObject(int columnIndex): 根据数据的列的索引获取数据. columnIndex: 表示第几列的意思,从1开始. Object getObject(String columnLabel): 根据数据的列名来获取数据. columnLabel: 表示列名. boolean next(): 是否有下一行, 如果返回是true,表示已经移动到下一行了. 获取单条数据12345678910111213141516171819202122232425public class TestGet &#123; @Test public void testGet() throws Exception &#123; //?表示占位符 String sql = "SELECT * FROM student WHERE id=?"; //注册加载驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //获得数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/javaweb", "root", "admin"); //获取预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //给SQL设置值 ps.setObject(1, 5L); ResultSet resultSet = ps.executeQuery(); if (resultSet.next()) &#123; Object obj = resultSet.getObject("name"); System.out.println(obj); &#125; JDBCUtil.close(conn, ps); &#125;&#125; 获取全部数据,用list装1234567891011121314151617181920212223242526272829303132public class TestListAll &#123; @Test public void testListAll() throws Exception &#123; List&lt;Student&gt; list = new ArrayList&lt;&gt;(); String sql = "SELECT * FROM student"; //1.加载注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2.获得连接数据库对象 Connection conn = DriverManager.getConnection("jdbc:mysql:///javaweb", "root", "admin"); //3.获得预编译语句对象 PreparedStatement ps = conn.prepareStatement(sql); //执行查询 ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; Student stu = new Student(); long id = rs.getLong("id"); String name = rs.getString("name"); Integer age = rs.getInt("age"); stu.setId(id); stu.setName(name); stu.setAge(age); list.add(stu); &#125; System.out.println(list); JDBCUtil.close(conn, ps); &#125;&#125; DAO规范使用DAO规范对数据库的增删改查,避免重复代码,直接调用DAO方法 DAO的设计1.保存方法 void save(Object obj) 把要保存的信息,封装成一个对象,传递给方法. 用来描述数据库表结构的javabean, 是一个特殊的javabean. ---&gt; domain 2.删除方法 void delete(Long id) 根据主键id来删除数据 3.修改方法 void update(Object obj) 把传递过来的新的信息设置到指定的数据库的记录 4.查询单个 Student get(Long id) 把查询数据封装到domain中. 5.查询多个 List&lt;Student&gt; listAll(); 使用ArrayList装 DAO的规范DAO规范,只要有操作数据库的地方,都需要该规范.主要就是针对包以及类名进行规范. 1.DAO接口. me.cscar.smis.dao:IXxxDAO ====&gt; Xxx 就是domain 2.DAO接口的实现类. me.cscar.smis.dao.impl:StudentDAOImpl 3.domain类: me.cscar.smis.domain:Student 4. 测试类: me.cscar.smis.test:StudentDAOTest 5. 工具类: me.cscar.smis.util:StringUtil/JDBCUtil 开发流程1.创建数据库表 2.根据数据库表来创建domain包以及类.1234567891011121314151617package me.cscar.refactorpro.domain;import lombok.*;import java.math.BigDecimal;@Getter@Setter@AllArgsConstructor@NoArgsConstructor@ToStringpublic class Product &#123; private Long id; private String productName; private BigDecimal salePrice; private BigDecimal cutoff;&#125; 3.根据domain来创建DAO包以及接口.1234567891011121314151617181920212223242526272829303132333435363738394041424344package me.cscar.refactorpro.dao;import me.cscar.refactorpro.domain.Product;import java.util.List;public interface IProductDAO &#123; /** * 增加 * * @param pro */ void save(Product pro); /** * 删除 * * @param id */ void delete(Long id); /** * 修改 * * @param pro */ void update(Product pro); /** * 查询指定 * * @param id * @return */ Product get(Long id); /** * 查询全部 * * @return */ List getAll();&#125; 4.根据DAO接口来生成实现类.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190package me.cscar.refactorpro.dao.impl;import me.cscar.refactorpro.dao.IProductDAO;import me.cscar.refactorpro.domain.Product;import me.cscar.refactorpro.util.JDBCutil;import java.math.BigDecimal;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class ProductDAOImpl implements IProductDAO &#123; public static ProductDAOImpl getInstance() &#123; return new ProductDAOImpl(); &#125; /** * 增加 * * @param pro */ @Override public void save(Product pro) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "INSERT INTO t_product (productName,salePrice,cutoff) VALUES (?,?,?)"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, pro.getProductName()); ps.setObject(2, pro.getSalePrice()); ps.setObject(3, pro.getCutoff()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(conn, ps); &#125; &#125; /** * 删除 * * @param id */ @Override public void delete(Long id) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "DELETE FROM t_product WHERE id = ?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, id); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBCutil.close(conn, ps); &#125; /** * 修改 * * @param pro */ @Override public void update(Product pro) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; String sql = "UPDATE t_product SET productName=?,salePrice=?,cutoff=? WHERE id=?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, pro.getProductName()); ps.setObject(2, pro.getSalePrice()); ps.setObject(3, pro.getCutoff()); ps.setObject(4, pro.getId()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCutil.close(conn, ps); &#125; &#125; /** * 查询指定 * * @param id * @return */ @Override public Product get(Long id) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; String sql = "SELECT * FROM t_product WHERE id = ?"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); ps.setObject(1, id); rs = ps.executeQuery(); while (rs.next()) &#123; Product pro = new Product(); String productName = rs.getString("productName"); BigDecimal salePrice = rs.getBigDecimal("salePrice"); BigDecimal cutoff = rs.getBigDecimal("cutoff"); Long proid = rs.getLong("id"); pro.setId(proid); pro.setProductName(productName); pro.setSalePrice(salePrice); pro.setCutoff(cutoff); return pro; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JDBCutil.close(conn, ps); &#125; throw new RuntimeException("查询错误"); &#125; /** * 查询全部 * * @param pro * @return */ @Override public List getAll() &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; String sql = "SELECT * FROM t_product"; conn = JDBCutil.getConnection(); ps = conn.prepareStatement(sql); rs = ps.executeQuery(); List&lt;Product&gt; list = new ArrayList&lt;&gt;(); while (rs.next()) &#123; Product pro = new Product(); String productName = rs.getString("productName"); BigDecimal salePrice = rs.getBigDecimal("salePrice"); BigDecimal cutoff = rs.getBigDecimal("cutoff"); Long proid = rs.getLong("id"); pro.setId(proid); pro.setProductName(productName); pro.setSalePrice(salePrice); pro.setCutoff(cutoff); list.add(pro); &#125; return list; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); JDBCutil.close(conn, ps); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; throw new RuntimeException("查询出错"); &#125;&#125; 5.根据测试先行,根据DAO接口生成测试类.完成测试类.12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.refactorpro.test;import me.cscar.refactorpro.dao.impl.ProductDAOImpl;import me.cscar.refactorpro.domain.Product;import me.cscar.refactorpro.util.JDBCutil;import org.junit.Test;import java.math.BigDecimal;import java.sql.Connection;import java.util.List;public class ProductDAOTest &#123; @Test public void save() &#123; Product pro = new Product(null, "mac", new BigDecimal("15000"), new BigDecimal("0.9")); ProductDAOImpl.getInstance().save(pro); &#125; @Test public void delete() &#123; ProductDAOImpl.getInstance().delete(6L); &#125; @Test public void update() &#123; Product newpro = new Product(5L, "suffer", new BigDecimal("14000"), new BigDecimal("0.99")); ProductDAOImpl.getInstance().update(newpro); &#125; @Test public void get() &#123; Product product = ProductDAOImpl.getInstance().get(4L); System.out.println(product); &#125; @Test public void getAll() &#123; List all = ProductDAOImpl.getInstance().getAll(); System.out.println(all); &#125;&#125; 抽取和完善JDBCutil新建配置文件,properties1234ClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql:///javawebuserName=xxxpassword=xxx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package me.cscar.refactorpro.util;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;import java.util.Properties;public class JDBCutil &#123; private static Properties pre = new Properties(); static &#123; InputStream is = Thread.currentThread() .getContextClassLoader() .getResourceAsStream("prodb.properties"); try &#123; pre.load(is); Class.forName(pre.getProperty("ClassName")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; try &#123; Connection conn = DriverManager.getConnection(pre.getProperty("url"), pre.getProperty("userName"), pre.getProperty("password")); return conn; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; throw new RuntimeException("数据库链接失败"); &#125; public static void close(Connection conn, PreparedStatement ps) &#123; try &#123; if (ps != null) &#123; ps.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 预编译语句对象原理避免了sql语句字符串拼接.有的数据库有DBMS有缓冲区,预编译语句对象可以提交效率. mysql不支持 DBMS1.安全检查2.语义分析检查语句在缓存中是否存在3.编译SQL4.执行SQL 有缓存区会存储编译好的sql模板,? 使用预编译语句对象可以防止SQL注入 其他问题jdbc驱动8.0以上版本时区,少一天连接数据库的url加上1serverTimezone=Asia/Shanghai]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pocketbook]]></title>
    <url>%2F2019%2F04%2F04%2Fpocketbook%2F</url>
    <content type="text"><![CDATA[pocketbook基于Swing和JDBC开发的桌面程序,JavaSE基础的综合.使用git进行版本管理,合作开发 github地址:https://github.com/Cscar2H/pocketbook 数据库和表1create database pocketbook 根据需求,设计了3个表 1.配置表信息 config 用于保存预算和用于备份还原的路径 2.消费分类表 category 用于保存消费分类 3.记录表 record 用于保存每一笔的消费记录,并且会用到消费分类 config表使用键值对保存了key_和value,例如key=”budget” value=”200”,表示预算是200元 category表name表示分类的类名 record表spend 表示单次花费cid 对应的消费分类表的中记录的idcomment 备注信息date 日期分类表和记录表之间的关系是一对多,record表中cid就是外键 功能开发主界面:在startup包下新建一个类Bootstrap,这个类专门负责启动程序,作为一个程序的启动入口,可以执行一些初始化操作. 使用了SwingUtilities.invokeAndWait的方式启动图形界面同时使用了调度线程,保证创建和显示界面的操作都在同一个线程中123456789SwingUtilities.invokeAndWait(new Runnable() &#123; @Override public void run() &#123; //是否显示主窗体 MainFrame.instance.setVisible(true); //在主界面中显示SpendPanel的界面 MainPanel.instance.workingPanel.show(SpendPanel.instance); &#125; &#125;); 使用监听器界面效果创建一个独立的监听器类ToolBarListener,实现接口ActionListener,重写了该接口中的actionPerformed方法。 在工具栏里的每一个按钮都使用一个这样的监听器. 通过ActionEvent.getSource()获取事件是哪个按钮发出来的.根据不同的按钮,发出切换不同的功能面板.1234567891011121314151617181920212223242526272829public class ToolBarListener implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; MainPanel p = MainPanel.instance; JButton b = (JButton) e.getSource(); if (b == p.bReport) &#123; p.workingPanel.show(ReportPanel.instance); &#125; if (b == p.bCategory) &#123; p.workingPanel.show(CategoryPanel.instance); &#125; if (b == p.bSpend) &#123; p.workingPanel.show(SpendPanel.instance); &#125; if (b == p.bRecord) &#123; p.workingPanel.show(RecordPanel.instance); &#125; if (b == p.bConfig) &#123; p.workingPanel.show(ConfigPanel.instance); &#125; if (b == p.bBackup) &#123; p.workingPanel.show(BackupPanel.instance); &#125; if (b == p.bRecover) &#123; p.workingPanel.show(RecoverPanel.instance); &#125; &#125;&#125; 实例化一个ToolBarListener监听器,给工具栏的按钮添加listener监听器对象.在MainPanel面板中使用监听器123456789101112private void addListener() &#123; ToolBarListener listener = new ToolBarListener(); bSpend.addActionListener(listener); bRecord.addActionListener(listener); bCategory.addActionListener(listener); bReport.addActionListener(listener); bConfig.addActionListener(listener); bBackup.addActionListener(listener); bRecover.addActionListener(listener);&#125; 初始化数据库配置效果 业务类ConfigService业务类,这个类是监听器直接调用的类,然后再通过ConfigService去调用ConfigDAO。 之前DAO是直接链接数据库,在操作数据库之前,需要对一些数据进行预处理,这些就可以放在业务类里进行. ConfigService 1.初始化 因为设置信息里有两个数据，一个是预算，一个是Mysql路径。 这两个信息，无论如何都应该是存在数据库中的。 所以会调用init把他们俩初始化。 2.init(String key, String value) 方法 首先根据key去查找，如果不存在，就使用value的值插入一条数据。 3.get(String key) 根据键获取相应的值 4.update(String key, String value) 更新键对应的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package me.cscar.service;import me.cscar.dao.ConfigDAO;import me.cscar.domain.Config;public class ConfigService &#123; public static final String BUDGET = "budget"; public static final String PATH = "mysqlPath"; public static final String DEFAULT_BUDGET = "500"; static ConfigDAO dao= new ConfigDAO(); static&#123; init(); &#125; public static void init()&#123; init(budget, default_budget); init(mysqlPath, ""); &#125; private static void init(String key, String value) &#123; Config config= dao.getByKey(key); if(config==null)&#123; Config c = new Config(); c.setKey(key); c.setValue(value); dao.add(c); &#125; &#125; public String get(String key) &#123; Config config= dao.getByKey(key); return config.getValue(); &#125; public void update(String key, String value)&#123; Config config= dao.getByKey(key); config.setValue(value); dao.update(config); &#125; public int getIntBudget() &#123; return Integer.parseInt(get(budget)); &#125; &#125; ConfigListener 监听器ConfigListener，这个监听器是用在更新按钮上的 1.判断输入的预算是否为整数 2.判断输入的MySQL 3.如果判断通过,就调用业务类ConfigService更新数据 12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.gui.listener; import me.cscar.gui.panel.ConfigPanel;import me.cscar.gui.util.GUIUtil;import me.cscar.service.ConfigService;import java.awt.event.ActionEvent; import java.awt.event.ActionListener;import java.io.File; import javax.swing.JOptionPane; public class ConfigListener implements ActionListener&#123; @Override public void actionPerformed(ActionEvent e) &#123; ConfigPanel p = ConfigPanel.instance; //判断 if(!GUIUtil.checkNumber(p.tfBudget, "预算")) &#123; return; &#125; String mysqlPath =p.tfMysqlPath.getText(); //判断MySQL路径是否正确 if(0!=mysqlPath.length())&#123; File commandFile = new File(mysqlPath,"bin/mysql"); if(!commandFile.exists())&#123; JOptionPane.showMessageDialog(p, "Mysql路径不正确"); p.tfMysqlPath.grabFocus(); return; &#125; &#125; ConfigService cs= new ConfigService(); cs.update(ConfigService.budget,p.tfBudget.getText()); cs.update(ConfigService.mysqlPath,mysqlPath); JOptionPane.showMessageDialog(p, "设置修改成功"); &#125; &#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>desktop</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F04%2F03%2FMySQL%2F</url>
    <content type="text"><![CDATA[SQLSQL：结构化查询语言(Structured Query Language)SQL包含6个部分 1.数据库查询语言(DQL) 2.数据操作语言(DML) 3.事务处理语言(TCL) 4.数据控制语言(DCL) 5.数据定义语言(DDL) MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。MyISAM：拥有较高的插入，查询速度，但不支持事务，不支持外键。InnoDB：支持事务，支持外键，支持行级锁定，性能较低。 InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但对比MyISAM，处理效率差，且会占用更多的磁盘空间以保留数据和索引。 ORM思想: 对象关系映射 –&gt; Java的对象和关系型数据库的映射 表 面向对象 表结构 类 表的列 属性 表的行 对象 MySQL命令行1.sudo mysql.server start : 启动数据库 2.sudo mysql.server stop : 关闭数据库 3.mysql -u root -p : 进入数据库(我的版本信息:Server version: 8.0.12 Homebrew) 4.use mysqlname; : 进入数据库 5.show tables; : 查看表 6.desc table_name; : 查看表结构 7.create table table_name : 创建表 8.drop table table_name : 删除表 MySQL列的常见类型 Java MySQL int INT long BIGINT BigDecimal DECIMAL boolean BIT java.util.Date DATE/DATETIME String VARCHAR 表约束 1.非空约束：NOT NULL(NK)，不允许某列的内容为空。 2.设置列的默认值：DEFAULT。 3.唯一约束：UNIQUE(UK)，在该表中，该列的内容必须唯一。 4.主键约束：PRIMARY KEY(PK)， 非空且唯一。 5.主键自增长：AUTO_INCREMENT，从1开始，步长为1。(MySQL特有) 6.外键约束：FOREIGN KEY(FK)，A表中的外键列的值必须参照于B表中的某一列(B表主键)。 数据操作(DML)保存操作 1INSERT INTO table_name(column1,column2,colum3...) VALUES (value1, value2, value3); 更新操作 1UPDATE table_name SET `columnName` = &apos;value&apos; WHERE (`condition` = &apos;num&apos;); 删除操作 1DELETE FROM table_name WHERE (`condition` = &apos;num&apos;); 数据查询操作(DQL)基本语法1SELECT * FROM table_name; 说明：SELECT 选择查询列表,列与列之间用逗号隔开FROM 提供数据源(表、视图或其他的数据源) 如果为 * 和创建表时的顺序一致。可以自己调整顺序，在select后边加上要查询的列名。 消除结果中重复的数据1SELECT DISTINCT 列名.. FROM table_name; 数学运算 数学运算:对NUMBER型数据可以使用算数操作符创建表达式（+ - * /） 对DATE型数据可以使用部分算数操作符创建表达式 （+ -） 运算符优先级： 1、乘法和除法的优先级高于加法和减法 2、同级运算的顺序是从左到右 3、表达式中使用&quot;括号&quot;可强行改变优先级的运算顺序 设置显示格式: 一旦遇到变量和常量拼接就必须使用CONCAT函数 把多个值以字符串拼接的形式拼在一起,可以使用函数concat(...) 设置列名的别名 1.改变表的名字； 2.用于表示计算结果的含义； 3.作为列的别名； 4.如果别名中使用特殊字符，或者是强制大小写敏感，或有空格时，都需加引号；别名以后都不加引号.加了引号的别名导致排序失效. 过滤查询 过滤查询比较运算符 运算符 含义 = 等于 &gt; 大于 &gt;= 大于或等于 &lt; 小于 &lt; 小于 &lt;= 小于或等于 !=(&lt;&gt;) 不等于 逻辑运算符 运算符 含义 AND(&amp;&amp;) 如果组合的条件都是TRUE,返回TRUE OR(&#124;&#124;) 如果组合的条件之一是TRUE,返回TRUE NOT(!) 如果下面的条件是FALSE,返回TRUE 范围查询 使用BETWEEN运算符显示某一值域范围的记录，这个操作符最常见的使用在数字类型数据的范围上，但对于字符类型数据和日期类型数据同样可用。 格式： SELECT &lt;columnList&gt; FROM table_name WHERE 列名 BETWEEN minvalue AND maxvalue：闭区间。 集合查询 使用IN运算符，判断列的值是否在指定的集合中。 格式： WHERE 列名 IN (值1，值2....); 空值查询 IS NULL:判断列的值是否为空。 空值是特指没有值的列 格式：WHERE 列名 IS NULL; 模糊查询 使用LIKE运算符执行通配查询，查询条件可包含文字字符或数字： %通配符：可表示任意个数的任意字符。 _通配符：可表示一个任意字符。 通配符：用来实现匹配部分值得特殊字符。 结果排序使用ORDER BY子句将记录排序ASC升序DESC降序ORDER BY 子句出现在SELECT语句的最后。格式：SELECT FROM table_nameWHERE 条件ORDER BY 列名1 [ASC/DESC],列名2 [ASC/DESC]…;]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识XML]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%88%9D%E8%AF%86XML%2F</url>
    <content type="text"><![CDATA[XMLXML概述使用XML文件,可以保存复杂的数据,数据结构清晰(树状结构) 传输数据是一种通用的数据格式 传递数据,作为配置文件存在 XML语法 版本 &lt;?xml version=&quot;1.0&quot;?&gt; 用encoding属性说明文档所使用的字符编码，默认为UTF-8。保存在磁盘上的文件编码要与声明的编码一致。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 用standalone属性说明文档是否独立，即是否依赖其他文档。 &lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt; 标签的属性,描述该标签 &lt;linkman 属性名=&quot;属性值&quot;&gt; 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;contacts&gt; &lt;person id="1"&gt; &lt;name&gt;蔡徐坤&lt;/name&gt; &lt;address&gt;荷兰&lt;/address&gt; &lt;email&gt;kk@nmsl&lt;/email&gt; &lt;age&gt;17&lt;/age&gt; &lt;/person&gt; &lt;person id="2"&gt; &lt;name&gt;孙笑川&lt;/name&gt; &lt;address&gt;日本&lt;/address&gt; &lt;email&gt;cc@nmsl&lt;/email&gt; &lt;age&gt;18&lt;/age&gt; &lt;/person&gt;&lt;/contacts&gt; DOM解析(Document Object Model)文档对象模型,可以将xml的操作当做是操作对象 特点: 在加载XML文档的时候,会一次性把所有的信息加载到内存中(DOM树) 使用document这一对象来描述,剩下的操作都是操作内存中的对象 缺点: 如果XML文档内容比较多,文件比较大,一加载到内存中会导致,内存溢出 注意: 1.使用DOM解析,导入的类都是在org.w3c.dom包中.如果发现让你强转.意识到可能导错包了. 2.在XML中,一切皆节点 ####获取Document对象 三个类 Document DocumentBuilder DocumentBuilderFactory newDocumentBuilder:单例设计模式,需要通过自身的newInstance方法,获取一个新的实例 DocumentBuilder:需要通过newDocumentBuilder的实例中的newDocumentBuilder获取对象,该类重写了parse方法和newDocument方法 Document:接口,不能创建对象.抽象的parse方法和newDocument方法 12345678910111213141516171819202122232425262728package me.cscar.DOM.object;import org.junit.Test;import org.w3c.dom.Document;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.File;import java.io.InputStream;public class GetDOMObject &#123; @Test public void getObject() throws Exception &#123; File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.newDocument(); InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); Document doc1 = db.parse(is); //Document doc = db.parse(file); System.out.println(doc.equals(doc1)); &#125;&#125; ####常用API(增删改查)常用的API: Document对象: Element getDocumentElement(): 获取根节点. Element getElementById(String elementId) :根据唯一ID获取节点. Element对象: NodeList getElementsByTagName(String name):根据标签名获取到标签列表. String getAttribute(String name) :根据属性名,获取属性值 void setAttribute(String name, String value) :设置属性名和属性值. Node 对象: String getTextContent(): 返回当前节点的文本内容. void setTextContent(String value): 设置文本内容. ADD1234567891011121314151617181920212223242526272829303132333435363738394041424344package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;public class Add &#123; @Test public void useAdd() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //创建document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根节点 Element element = doc.getDocumentElement(); //创建节点 Element person = doc.createElement("person"); person.setAttribute("id", "4"); Element name = doc.createElement("name"); Element email = doc.createElement("email"); Element address = doc.createElement("address"); Element age = doc.createElement("age"); //创建层级关系 element.appendChild(person); person.appendChild(name); person.appendChild(email); person.appendChild(address); person.appendChild(age); //给节点设置数据 name.setTextContent("蛤蛤"); email.setTextContent("haha@china.com"); address.setTextContent("中国"); age.setTextContent("90"); SynchroFile.synchor(doc); &#125;&#125; REMOVE123456789101112131415161718192021222324252627282930313233343536373839package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 删除操作 */public class Remove &#123; @Test public void useRemove() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //获取document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根节点 Element de = doc.getDocumentElement(); //person标签 NodeList person = de.getElementsByTagName("person"); //获取第三个人的标签 Element p3 = (Element) person.item(2); System.out.println(p3.getAttribute("id")); p3.getParentNode().removeChild(p3); //同步操作,把修改的document对象写入 SynchroFile.synchor(doc); &#125;&#125; QUERY12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 查询操作 */public class Query &#123; @Test public void useQuery() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); Element de = doc.getDocumentElement(); //第1个人的信息节点 NodeList person = de.getElementsByTagName("person"); System.out.println("长度是"+person.getLength()); Element item = (Element) person.item(2); //获取ID编号 //System.out.println(item.getAttribute("id")); //找到第1个联系人的name节点 Element nameNode = (Element) item.getElementsByTagName("name").item(0); int re = item.getElementsByTagName("name").getLength(); //System.out.println(re); String name = nameNode.getTextContent(); System.out.println(name); //获取所有人的信息 for (int i = 0; i &lt; person.getLength(); i++) &#123; Element item1 = (Element) person.item(i); String name1 = item1.getElementsByTagName("name").item(0).getTextContent(); String email = item1.getElementsByTagName("email").item(0).getTextContent(); String address = item1.getElementsByTagName("address").item(0).getTextContent(); String age = item1.getElementsByTagName("age").item(0).getTextContent(); System.out.println(name1 + '\n' + email + '\n' + address + '\n' + age); System.out.println("-------------"); &#125; &#125;&#125; UPDATE12345678910111213141516171819202122232425262728293031323334353637package me.cscar.DOM.frequently;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.InputStream;/** * 修改操作 */public class Update &#123; @Test public void useUpdate() throws Exception &#123; InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("MyXML.xml"); //获取document对象 Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is); //获取根标签 Element element = doc.getDocumentElement(); //获取第3个人信息 Element person = (Element) element.getElementsByTagName("person").item(2); //获取name标签 Element name = (Element) person.getElementsByTagName("name").item(0); //修改name标签 name.setTextContent("包包"); //调用同步方法 SynchroFile.synchor(doc); &#125;&#125; 同步操作12345678910111213141516171819202122232425262728293031323334package me.cscar.DOM.frequently;import org.w3c.dom.Document;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.File;import java.io.InputStream;/** * 增删改的同步操作 * 把修改的document真正写入 */public class SynchroFile &#123; public static void synchor(Document doc) throws Exception &#123; File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); //获取工厂对象 TransformerFactory factory = TransformerFactory.newInstance(); //获取转换器 Transformer transformer = factory.newTransformer(); //调用转换器中的方法 Source src = new DOMSource(doc); Result target = new StreamResult(file); transformer.transform(src, target); &#125;&#125; 创建新的XML12345678910111213141516171819202122232425262728293031323334353637383940package me.cscar.DOM.create;import me.cscar.DOM.frequently.SynchroFile;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.File;public class Create &#123; @Test public void CreateDoc() throws Exception &#123; //File file = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML.xml"); File newFile = new File("/Users/cscar/IdeaProjects/wolfCode/day03/resource/MyXML_Copy.xml"); Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument(); //创建一个根节点 Element element = doc.createElement("contacts"); //添加根节点 doc.appendChild(element); TransformerFactory factory = TransformerFactory.newInstance(); Transformer tf = factory.newTransformer(); Source src = new DOMSource(doc); Result target = new StreamResult(newFile); tf.transform(src, target); &#125;&#125; ####XML约束(了解)]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>配置文件</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaUtility]]></title>
    <url>%2F2019%2F03%2F31%2FJavaUtility%2F</url>
    <content type="text"><![CDATA[LombokJavaBean规范代码生成工具]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>utility</tag>
        <tag>tool</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaBean]]></title>
    <url>%2F2019%2F03%2F30%2FJavaBean%2F</url>
    <content type="text"><![CDATA[JavaBean在Java中一个非常重要的组件,可重用.如果想要在多个模块中重用,必须遵循一定的规范. 1.必须使用public修饰 2.必须提供公共的无参数构造器 3.字段都是私有化的 4.提供get和set方法 JavaBean中重要成员方法 事件 属性:property,不是字段,而是通过get/set方法推导出来的 12345678910111213141516171819class HelloWorld &#123; private String name; /** * 标准的get方法 * get之后首字母小写,称之为属性 * */ public String getName() &#123; return name; &#125; /** * 标准的set方法 * set之后首字母大写,称之为属性 * */ public void setName(String name) &#123; this.name = name; &#125;&#125; 内省操作内省机制 核心类:Introspector 专门用来操作JavaBean的属性 核心方法 BeanInfo getBeanInfo(class&lt;?&gt; beanclass) 常用API java.beans.Introspector类常用API: static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass) : 获取字节码对象对应的JavaBean信息 static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass, Class&lt;?&gt; stopClass) java.beans.BeanInfo接口常用API: PropertyDescriptor[] getPropertyDescriptors() : 获取所有的属性描述器 java.beans.PropertyDescriptor类常用API: String getName() : 获得属性的名称 Class&lt;?&gt; getPropertyType() : 获得属性的类型 Method getReadMethod() : 获得用于读取属性值的方法 Method getWriteMethod() : 获得用于设置属性值的方法 JavaBean和Map的转换从浏览器传递过来的数据,服务器获取数据后.需要将数据放到一个对象中,传递的数据类似于key=value的形式.所以需要将map转换成JavaBean 都具有相似的结构 转换操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package me.cscar.con.conversion;import org.junit.Test;import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class JavaBeanMap &#123; @Test public void test() throws Exception &#123; //Person p = new Person("蛤蛤", 90); Class&lt;Person&gt; clz = Person.class; Constructor&lt;Person&gt; con = clz.getConstructor(String.class, Integer.class); Person p = con.newInstance("蛤蛤", 90); Map&lt;String, Object&gt; map = bean2map(p); System.out.println(map); System.out.println(map2bean(map, clz)); &#125; /** * JavaBean对象转换成map * 把JavaBean对象中的属性值,获取出来,放在map中 */ public static Map&lt;String, Object&gt; bean2map(Object obj) throws Exception &#123; BeanInfo beanInfo = Introspector.getBeanInfo(obj.getClass(), Object.class); //创建map对象 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Method m = ele.getReadMethod(); Object value = m.invoke(obj); map.put(key, value); &#125; return map; &#125; /** * map转换成JavaBean对象 * 把map的数据取出来,放到JavaBean对应的属性上 */ public static Object map2bean(Map&lt;String, Object&gt; map, Class clz) throws Exception &#123; //使用字节码对象创建对象 Object obj = clz.newInstance(); //获取字节码对象对应JavaBean信息 BeanInfo beanInfo = Introspector.getBeanInfo(clz, Object.class); //获取所有的属性描述器 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); //遍历 for (PropertyDescriptor ele : pds) &#123; String key = ele.getName(); Object value = map.get(key); Method m = ele.getWriteMethod(); m.invoke(obj, value); &#125; return obj; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>JavaBean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Annotation注解]]></title>
    <url>%2F2019%2F03%2F30%2FAnnotation%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解(标签)注解的概述解决xml臃肿的问题 在Java5之后,开始对元数据的支持,就是Annotation(注解) 可以用来描述其他数据的一种数据,可以赋予其他数据一些功能 常用注解: @Override 限定覆写父类方法 @Deprecated 标记已过时,不推荐使用.在JDK1.5之前,使用文档注释来标记过时 @SuppressWarings 抑制编译器发出的警告,@SuppressWarings(value=&quot;all&quot;) @SafeVarargs 抑制堆污染警告(Java7开始出现的) @Functionallnterface 标记该接口是一个函数接口(Java8开始出现的) 注解的定义:123public @interface Test&#123; //抽象方法 属性&#125; 注解的使用语法: @注解名(属性名1=属性值1,属性名2=属性值2,...) 注解想要具有某一些功能,最重要的是需要三方程序的参与,必须使用反射来给注解赋予功能 元注解注解是用来约束其他程序元素的(字段,方法,),元注解是用来约束注解的 @Target: 表示注解可以贴在哪些位置(类,方法上,构造器上等等) @Retention: 表示注解可以保存在哪一个时期,存活时间 @Documented: 使用@Documented标注的标签会保存到API文档中 @Inherited: @Inherited标注的标签可以被子类所继承. 自定义注解语法格式 1. 可以为属性设置默认值, 使用default. 2. 如果必须要写的属性(可以有多个,其他的都有默认值),并且这个属性的名字叫value, 可以省略属性名,直接写值. 3. 属性的类型只能是基本类型,String,Class,注解,枚举,以及其数组类型. 4. 抽象方法不能有参数 使用注解是一种硬编码方式**]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Annotation</tag>
        <tag>注解</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置文件]]></title>
    <url>%2F2019%2F03%2F30%2F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[配置文件使用配置文件经常修改,从源文件的编写到部署的过程,都需要重新修改. 解决方案: 把配置保存在一个文件中, Java代码可以通过流(stream)动态的读取 真正解决的问题: 代码中的硬编码,写死到Java代码中,而且是经常改动的值 常用的配置文件1.properties文件. 文件后缀名.properties,用来保存一些简单的数据.保存格式:key=value 重复的key表示更新操作,不能存多个用户信息 2.xml文件 文件后缀名.xml,用来保存一些复杂的数据,按照清晰的格式保存(结构化) properties文件的基本使用常见的操作 创建properties文件,并存储数据 1.文件存放在resource文件夹中. 2.在该配置文件中,所有数据到Java后,都是String类型 3.等号不需要空格 123#这是注释,保存格式:key=valueusername=rootpassword=admin 使用jdk提供好的工具类来加载和获取 void load(InputStream inStream):通过输入流把数据加载到properties对象中 String getProperty(String key):通过指定的key获取value值 使用相对路径12//默认去bin中找Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;user.properties&quot;); 123456789101112131415161718public class PropertiesTest &#123; @Test public void loadProperties() throws Exception &#123; //创建properties对象 Properties pt = new Properties(); //获取相对路径 InputStream in = Thread.currentThread(). getContextClassLoader(). getResourceAsStream("user.properties"); //加载 pt.load(in); //获取 String username = pt.getProperty("username"); System.out.println(username); String password = pt.getProperty("password"); System.out.println(password); &#125;&#125; 反射的优势反射的应用场景 更多的是使用一个全限定名来创建对象(反射) 为了解决硬编码,为了降低代码的耦合性,一般将具体的实现类配置到配置文件中 1234567891011121314151617181920212223package me.cscar.con.reflect;import org.junit.Test;import java.io.InputStream;import java.util.Properties;public class Math implements IMath &#123; @Test public void testMath() throws Exception &#123; Properties ps = new Properties(); InputStream is = Thread. currentThread(). getContextClassLoader(). getResourceAsStream("math.properties"); ps.load(is); //forName获取properties文件中的全限定名称,并且创建对象 IMath math = (IMath) Class.forName(ps.getProperty("clssName")) .newInstance(); //getClass获取math的全限定名 System.out.println(math.getClass()); &#125;&#125; 优点: 1.反射提高了程序的灵活性和扩展性。 2.降低耦合性，提高自适应能力。 3.它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 1.性能问题：使用发射基本上是一种在运行期间解析字节码操作，效率较低，一般程序不建议使用，对灵活性和拓展性要求较高的工具或框架上使用较多。 2.代码复杂性：反射发生在运行期，程序员无法在源代码中看到程序的逻辑，反射代码比相应的直接的代码更复杂，因而会带来维护的问题 框架中大量使用反射,用来提高框架的扩展性和灵活性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JunitTest]]></title>
    <url>%2F2019%2F03%2F29%2FJunitTest%2F</url>
    <content type="text"><![CDATA[Junit回归测试框架的基本使用测试先行的思想 单元测试Junit属于白盒测试 定义一个测试方法:1.测试方法,必须是公共的无参数无返回的方法.建议使用test开头. 2.想要测试哪个方法,需要在该方法上贴一个注解@Test 12345678import org.junit.Test;public class HelloTest &#123; @Test public void addTest() &#123; System.out.println("添加用户信息"); &#125;&#125; Junit细节:更多是针对接进行测试,要测试一个接口中的方法,必须按照规范流程 定义一个接口:1234567891011121314151617181920212223242526package me.cscar.Junit;/** * 接口规范:文档注释 * 数学运算的加减乘除方法 * * @author cscar * @date 2019/3/29 */public interface IMath &#123; /** * 计算两个数相加 * @param a * @param b * @return 和 */ int add(int a, int b); /** * 计算两个数相除 * @param a * @param b * @return 商 */ int div(int a, int b);&#125; 根据接口生成实现类:1234567891011121314151617package me.cscar.Junit;/** * 实现IMath接口 */public class Math implements IMath &#123; @Override public int add(int a, int b) &#123; return a + b; &#125; @Override public int div(int a, int b) &#123; return a / b; &#125;&#125; 根据接口生成实现类:1234567891011121314151617181920212223242526package me.cscar.Junit;import org.junit.Test;import static org.junit.Assert.*;//测试数学运算public class MathTest &#123; /** * 面向接口,创建数学类对象 */ private IMath math = new Math(); @Test public void add() &#123; int result = math.add(3, 4); System.out.println(result); &#125; @Test public void div() &#123; int result = math.div(10, 0); System.out.println(result); &#125;&#125; 断言:猜测一个程序结果是否是期望结果 1.:Assert.assertEquals(message, expected, actual):比较的值 三个参数: message: 断言失败的提示信息,断言成功不会显示. expected: 期望值 actual: 真实值 2.:Assert.assertSame(message, expected, actual):比较地址,是同一个对象 Assert.assertNotSame(message, expected, actual):断言不是同一个对象 3.:Assert.assertTrue(message, condition):断言condition应该为TRUE. Assert.assertFalse(message, condition):断言condition应该为FALSE. 4.:Assert.assertNull(message, object):断言对象object为null. Assert.assertNotNull(message, object):断言对象object不为null. 5.:@Test(expected=ArithmeticException.class) 期望该方法报错ArithmeticException. 6.:@Test(timeout=400) 期望该方法在400毫秒之内执行完成. 123456789101112@Testpublic void add() &#123; int result = math.add(3, 4); //System.out.println(result); Assert.assertEquals(&quot;3+4我都能算错?&quot;, 8, result);&#125;@Test(expected = ArithmeticException.class)public void div() &#123; int result = math.div(10, 0); System.out.println(result);&#125; Junit自动化操作自动初始化自动销毁 1.@Test:需要测试的方法,必须贴Test注解.并且测试方法必须是公共无参数无返回的方法. 2.@Before:在所有的测试方法之前,都会执行的代码 3.@After:在所有的测试方法之后,都会执行的代码 4.@BeforeClass:在所有操作之前执行,只执行一次. 5.@AfterClass:在所有操作之前执行,只执行一次. 1234567891011121314151617181920212223242526272829303132333435package me.cscar.junit.work;import org.junit.*;public class WorkTest &#123; @Test public void query() &#123; System.out.println("查询用户信息"); &#125; @Test public void delete() &#123; System.out.println("删除用户信息"); &#125; @Before public void init() &#123; System.out.println("登录"); &#125; @After public void story() &#123; System.out.println("注销"); &#125; @BeforeClass public static void BeforeClass() &#123; System.out.println("所有操作之前"); &#125; @AfterClass public static void AfterClass() &#123; System.out.println("所有操作之后"); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Junit</tag>
        <tag>测试类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reflect反射]]></title>
    <url>%2F2019%2F03%2F29%2FReflect%2F</url>
    <content type="text"><![CDATA[反射为什么要使用反射1234567891011121314151617181920//定义一个类class Person&#123; public Object work()&#123; //假设看不到源码,无法获取真实类型 return new Date(); &#125; //调用work方法 @Test public void testWork()&#123; Person p = new Person(); Object obj = new Person(); //返回值是一个对象,可以继续调用该对象的方法. Date d = (Date)obj; //打印本地的时间风格,但是却不知道应该用什么来接收(不知道返回的是date) String str = d.toLocalString(); System.out.println(str); &#125;&#125; Person类是别人提供好的字节码文件.看不到源码是不能直接强转的. 不爽:我都已经获取到真正的对象了,居然不能知道他的真实类型. 什么是反射:通过字节码(Class)对象,动态的获取该字节码中的成员(构造器,方法,字段,父类,包…) 字节码对象(Class):将多个Class类抽象出来,形成一个字节码的结构(everything is object) 当JVM加载完字节码后.会使用一个对象,来描述该字节码文件的结构.该对象包含操作字节码中成员的方法. 字节码对象,是JVM加载字节码文件的时候,给我们创建的一个对象,一份字节码,只会创建一个字节码对象. 获取字节码对象的三种方法:1.通过Class类的forName来获取. public static Class&lt;?&gt; forName(String className):根据全限定名来获取字节码对象. 全限定名:包名.类名.指定到唯一的一个类上. 2.所有的对象,都有一个公共的方法.getClass. public final Class&lt;?&gt; getClass(): 通过对象返回字节码对象. 3.任何类型都有一个class属性. int.class / Person.class/ 1234567891011121314151617181920212223242526272829303132package me.cscar.reflect.getClassObject;import org.junit.Test;public class GetClassTest &#123; @Test public void getClassObject() throws Exception &#123; //1.通过forName静态方法获取,抛出异常 Class clz = Class.forName("me.cscar.reflect.getClassObject.Person"); //2.通过对象.getClass()方法获取 Object obj = new Person(); Class clz1 = obj.getClass(); //3.任何类型都有一个class属性 Class clz2 = Person.class; //class me.cscar.reflect.getClassObject.Person System.out.println(clz); //true System.out.println(clz == clz1); //true System.out.println(clz == clz2); //int类型的class属性不等于integer的class属性,结果为false System.out.println(int.class == Integer.class); //integer的包装类型是int,结果为true System.out.println(int.class == Integer.TYPE); //class [Ljava.lang.String; System.out.println(String[].class); &#125;&#125; 构造器的操作获取构造器获取单个构造器 parameterTypes:参数类型 想要定位到一个构造器,必须要指明构造器的参数列表. 1.获取单个构造器: public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes):获取public的指定的构造器 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) :获取不管权限的构造器 2.获取所有构造器: Constructor&lt;?&gt;[] getConstructors() :获取所有public 的构造器 Constructor&lt;?&gt;[] getDeclaredConstructors() :获取所有构造器,不管权限. 123456789101112131415161718192021222324252627282930313233343536package me.cscar.reflect.getConstructor;import org.junit.Test;import java.lang.reflect.Constructor;public class GetConstructor &#123; @Test public void testGetConstructor() throws Exception &#123; //创建字节码对象 Class clz = Class.forName("me.cscar.reflect.getConstructor.Person"); //1.获取所有的public构造器 Constructor[] cons = clz.getConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //2.获取所有的构造器 cons = clz.getDeclaredConstructors(); for (Constructor ele : cons) &#123; //System.out.println(ele); &#125; //3.获取无参数构造器 Constructor con = clz.getConstructor(); //System.out.println(con); //4.获取带参数的public构造器 Constructor conagsP = clz.getDeclaredConstructor(Long.class, String.class, int.class); //System.out.println(conagsP); //5.获取带参数的构造器(暴力反射) Constructor conage = clz.getDeclaredConstructor(String.class, int.class); System.out.println(conage); &#125;&#125; 通过构造器创建对象 public T newInstance(Object... initargs):通过构造器,创建对象. initargs:实际参数. 如果想要调用私有的成员.必须要先设置可以访问. public void setAccessible(boolean flag): 设置为true. 12345678910111213141516171819202122232425262728293031323334package me.cscar.reflect.createObject;import org.junit.Test;import java.lang.reflect.Constructor;public class CreateObject &#123; @Test public void createObj() throws Exception &#123; Class&lt;Person&gt; clz = Person.class; //1)调用空参构造 Constructor&lt;Person&gt; con = clz.getConstructor(); Person p = con.newInstance(); System.out.println(p); //调用空参构造器方式二,字节码对象需要加泛型,直接使用字节码对象调用 p = clz.newInstance(); System.out.println(p); //2)获取带参数构造并创建对象 Constructor&lt;Person&gt; conargs = clz.getConstructor(Long.class, String.class, int.class); Person p1 = conargs.newInstance(9527L, "蛤蛤", 70); System.out.println(p1); //3)获取私有构造并创建对象 Constructor&lt;Person&gt; constructor = clz.getDeclaredConstructor(String.class, int.class); //设置非public的成员访问许可 constructor.setAccessible(true); Person p2 = constructor.newInstance("包包", 51); System.out.println(p2); &#125;&#125; 操作方法获取方法 name:方法名 parameterTypes:参数列表的类型 想要定位到一个方法,必须要指定方法签名(方法名+参数列表) 1.获取多个方法 Method[] getMethods() :获取到所有的public方法,包括继承的. Method[] getDeclaredMethods() :获取所有的方法,不包括继承的. 2.获取单个方法 Method getMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的public方法 Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) :获取指定的方法,不管权限. 12345678910111213141516171819202122232425262728293031323334353637383940414243package me.cscar.reflect.getMethod;import org.junit.Test;import java.lang.reflect.Method;public class GetMethod &#123; @Test public void getMethod() throws Exception &#123; //使用反射创建对象 Class&lt;Person&gt; clz = Person.class; Person p = clz.newInstance(); //1)执行无参无返回的方法 Method m = clz.getMethod("method1"); Object ret = m.invoke(p); System.out.println(ret); //2)执行有参无返回的方法 Method m1 = clz.getMethod("method2", String.class); Object ret1 = m1.invoke(p, "蛤蛤"); System.out.println(ret1); //3)执行无参有返回的方法 Method m2 = clz.getMethod("method3"); Object ret2 = m2.invoke(p); System.out.println(ret2); //4)执行有参有返回的方法 Method m3 = clz.getMethod("method4", String.class); Object ret3 = m3.invoke(p, "蛤蛤蛤"); System.out.println(ret3); //5)执行私有方法 Method m4 = clz.getDeclaredMethod("method5"); //设置可以访问 m4.setAccessible(true); Object ret4 = m4.invoke(p); System.out.println(ret4); &#125;&#125; 反射的其他API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package me.cscar.reflect.staticmethod;import org.junit.Test;import java.lang.reflect.Method;public class MethodTest &#123; /** * 调用静态方法 */ @Test public void testInvokeStaticMethod() throws Exception &#123; //找到静态方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method6", String.class); //调用方法.由于是static修饰,执行静态方法,不需要对象,第一个参数传递为null m.invoke(null, "蛤蛤蛤"); &#125; /** * 调用参数是基本类型数组的方法 */ @Test public void testInvokeIntArray() throws Exception &#123; //找到基本类型数组方法 Class&lt;?&gt; clz = Class.forName("me.cscar.reflect.staticmethod.Person"); Method m = clz.getMethod("method7", int[].class); int[] arr = new int[]&#123;1, 2, 3&#125;; //person有公共的无参数构造器,可以直接通过,字节码对象去调用 m.invoke(clz.newInstance(), new Object[]&#123;arr&#125;); &#125; /** * 调用参数是引用类型数组的方法 * 在Invoke方法中,第二个参数实际上要的是一个Object数组 * 底层将所有的实际参数放在一个Object类型的数组中 */ @Test public void testInvokeString() throws Exception &#123; Class&lt;? extends Person&gt; clz = new Person().getClass(); Method m = clz.getMethod("method8", String[].class); String[] str = new String[]&#123;"A", "B"&#125;; //wrong number of arguments:参数个数错误 /* 如果显式的传递到Invoke方法中,已经是一个Object数组了.那么会解包 解开之后是-&gt;String[].class 如果传递的是散数据-&gt;1,2,3,会装成一个Object数组,装包之后,invoke再解包 解开之后是-&gt;int.class,int.class 基本类型数组,不是Object类型的数组,所以会装包,也会拆包. 把int类型数组装进Object数组,再拆成int类型数组 引用类型数组,已经是Object类型数组,不会装包,直接拆-&gt; String.class,String.class不匹配方法参数的String[]数组 */ m.invoke(clz.newInstance(), new Object[]&#123;str&#125;); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>reflect</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL初识]]></title>
    <url>%2F2019%2F03%2F28%2FGraphQL%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[GraphQL是一个用于API的查询语言.一个GraphQL服务是通过定义类型和类型上的字段来创建,然后给每个类型上的每个字段提供解析函数.基本用法:12345678type Query &#123; me: User &#125;type User &#123; id: ID name: String&#125; 每个类型上字段的解析函数1234567function Query_me(request) &#123; return request.auth.user;&#125;function User_name(user) &#123; return user.getName();&#125; 一个GraphQL服务运行起来(通常在web服务的一个URL上),它就能接收GraphQL查询,并验证和执行.查询会检查确保只会引用已经定义的类型和字段,然后运行指定的解析函数来生成结果12345&#123; me&#123; name &#125;&#125; 会返回一个JSON结果12345&#123; "me": &#123; "name": "hhh" &#125;&#125; 字段也能指代对象类型(Object).对这个对象的字段进行次级选择(Sub-selection).遍历相关对象及其字段,使得客户端可以一次请求查询大量相关数据.12345678910&#123; hero&#123; name # 这是注释 # 这里friens指代一个对象类型 friends &#123; name &#125; &#125;&#125; 返回结果:123456789101112131415161718&#123; "data": &#123; "hero": &#123; "name": "R2-D2", "friends": [ &#123; "name": "Luke Skywalker" &#125;, &#123; "name": "Han Solo" &#125;, &#123; "name": "Leia Organa" &#125; ] &#125; &#125;&#125; friens返回了一个数组的项目,GraphQL查询会同等看成单个项目或者一个列表项目 传递参数:1234567&#123; human(id: "1000")&#123; id name height &#125;&#125; 返回结果:123456789&#123; "data": &#123; "human": &#123; "id": "1000", "name": "Luke Skywalker", "height": 1.72 &#125; &#125;&#125; 每一个字段和嵌套对象都能有自己的一组参数,从而使得GraphQL可以替代多次API请求.可以给标量(scalar)字段传递参数,用于实现服务端的一次转换1234567&#123; human(id: "1000")&#123; name #传入参数把单位转换为英尺 height(unit: FOOT) &#125;&#125; 12345678&#123; "data": &#123; "human": &#123; "name": "Luke Skywalker", "height": 5.6430448 &#125; &#125;&#125; 别名:通过设置别名可以通过不同参数查询相同字段12345678&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125; 12345678910&#123; "data": &#123; "empireHero": &#123; "name": "Luke Skywalker" &#125;, "jediHero": &#123; "name": "R2-D2" &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>PHP</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
</search>
